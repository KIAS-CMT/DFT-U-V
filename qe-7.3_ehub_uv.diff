diff --git a/Modules/input_parameters.f90 b/Modules/input_parameters.f90
index 460f1fe12..cdfb5311f 100644
--- a/Modules/input_parameters.f90
+++ b/Modules/input_parameters.f90
@@ -443,6 +443,28 @@ MODULE input_parameters
         LOGICAL :: reserv_back(nsx) = .FALSE.
         LOGICAL :: hub_pot_fix = .FALSE.
         LOGICAL :: backall(nsx) = .FALSE.
+        ! by LSH
+        INTEGER, PARAMETER :: ntypes = 10
+        INTEGER, PARAMETER :: natoms = 100
+        INTEGER, PARAMETER :: nchis  = 6
+        INTEGER, PARAMETER :: smqn   = 9   ! ( 1 (s orbital) + 3 (p orbital) + 5 (d orbital) )
+        INTEGER, PARAMETER :: ncells = 100
+        LOGICAL  :: lda_plus_v = .false.
+        LOGICAL  :: lacbn0 = .false.
+        LOGICAL  :: read_ehub_ns_file = .false.
+        LOGICAL  :: read_ehub_uv_file = .false.
+        LOGICAL  :: ehub_pot_fix = .false.
+        LOGICAL  :: stop_acbn0 = .false.
+        REAL(DP) :: ehub_u(natoms,smqn,smqn) = 0.0_DP
+        REAL(DP) :: ehub_v(natoms,natoms,smqn,smqn,ncells) = 0.0_DP
+        REAL(DP) :: ehub_nn_distance = 3.0_DP
+        REAL(DP) :: ehub_conv_thr = 1.0D-8
+        REAL(DP) :: ehub_mixing = 0.7_DP
+        INTEGER  :: acbn0_type = 1
+        INTEGER  :: ehub_l_choice(ntypes,nchis) = 0
+        INTEGER  :: remove_ehub_u(ntypes,nchis) = 1
+        INTEGER  :: remove_ehub_v(ntypes,nchis) = 1
+        ! by LSH
 
           ! For linking to DMFT calculations
         LOGICAL :: dmft = .FALSE.
@@ -698,7 +720,13 @@ MODULE input_parameters
              gcscf_gk, gcscf_gh, gcscf_beta,                                  &
              space_group, uniqueb, origin_choice, rhombohedral,               &
              zgate, relaxz, block, block_1, block_2, block_height,            &
-             nextffield
+             nextffield,                                                      &
+             ! by LSH
+             lda_plus_v, lacbn0, acbn0_type, ehub_nn_distance, ehub_l_choice, &
+             ehub_conv_thr, ehub_mixing, ehub_u, ehub_v, remove_ehub_u,       &
+             remove_ehub_v, read_ehub_ns_file, read_ehub_uv_file,             &
+             ehub_pot_fix, stop_acbn0
+             ! by LSH
 
 !=----------------------------------------------------------------------------=!
 !  ELECTRONS Namelist Input Parameters
diff --git a/Modules/io_files.f90 b/Modules/io_files.f90
index 7340885b2..5245c2e15 100644
--- a/Modules/io_files.f90
+++ b/Modules/io_files.f90
@@ -89,6 +89,10 @@ MODULE io_files
   !! unit with exx wavefunctions
   INTEGER :: iunhub_noS  = 17
   !! unit for saving Hubbard-U atomic wfcs
+  ! by LSH
+  INTEGER :: iunhubv     = 18
+  !! unit for saving Hubbard-V atomic wfcs (eACBN0)
+  ! by LSH
   !
   INTEGER :: iunexit     = 26
   !! unit for a soft exit  
@@ -112,6 +116,10 @@ MODULE io_files
   !! length of record in atomic hubbard wfc file
   INTEGER :: nwordwann   =  2
   !! length of record in sic wfc file
+  ! by LSH
+  INTEGER :: nwordwfcv   = 2
+  !! length of record in atomic hubbard wfc file (eACBN0)
+  ! by LSH
   !
   !... finite electric field
   !
diff --git a/Modules/qes_bcast_module.f90 b/Modules/qes_bcast_module.f90
index 47ee95750..fea7adb74 100644
--- a/Modules/qes_bcast_module.f90
+++ b/Modules/qes_bcast_module.f90
@@ -127,6 +127,14 @@ MODULE qes_bcast_module
     MODULE PROCEDURE qes_bcast_scalarQuantity
     MODULE PROCEDURE qes_bcast_rism3d
     MODULE PROCEDURE qes_bcast_rismlaue
+    ! by LSH WIY
+    MODULE PROCEDURE qes_bcast_ehub
+    MODULE PROCEDURE qes_bcast_ehub_l_choice
+    MODULE PROCEDURE qes_bcast_ehub_u
+    MODULE PROCEDURE qes_bcast_ehub_v
+    MODULE PROCEDURE qes_bcast_ehub_na0
+    MODULE PROCEDURE qes_bcast_ehub_ne0
+    ! by LSH WIY
   END INTERFACE qes_bcast
   !
   CONTAINS
@@ -729,6 +737,11 @@ MODULE qes_bcast_module
     CALL mp_bcast(obj%dftU_ispresent, ionode_id, comm)
     IF (obj%dftU_ispresent) &
       CALL qes_bcast_dftU(obj%dftU, ionode_id, comm)
+    ! by LSH
+    CALL mp_bcast(obj%ehub_ispresent, ionode_id, comm)
+    IF (obj%ehub_ispresent) &
+      CALL qes_bcast_ehub(obj%ehub, ionode_id, comm)
+    ! by LSH
     CALL mp_bcast(obj%vdW_ispresent, ionode_id, comm)
     IF (obj%vdW_ispresent) &
       CALL qes_bcast_vdW(obj%vdW, ionode_id, comm)
@@ -3237,4 +3250,243 @@ MODULE qes_bcast_module
   END SUBROUTINE qes_bcast_rismlaue
   !
   !
-END MODULE qes_bcast_module
\ No newline at end of file
+  ! by LSH WIY
+  SUBROUTINE qes_bcast_ehub( obj, ionode_id, comm )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_type), INTENT(INOUT) :: obj
+    INTEGER,         INTENT(IN)    :: ionode_id, comm
+    INTEGER                        :: i
+    !
+    CALL mp_bcast(obj%tagname, ionode_id, comm)
+    CALL mp_bcast(obj%lwrite, ionode_id, comm)
+    CALL mp_bcast(obj%lread, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%lacbn0_ispresent, ionode_id, comm)
+    IF ( obj%lacbn0_ispresent ) &
+      CALL mp_bcast(obj%lacbn0, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%acbn0_type_ispresent, ionode_id, comm)
+    IF ( obj%acbn0_type_ispresent ) &
+      CALL mp_bcast(obj%acbn0_type, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%ehub_nn_distance_ispresent, ionode_id, comm)
+    IF ( obj%ehub_nn_distance_ispresent ) &
+      CALL mp_bcast(obj%ehub_nn_distance, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%ehub_nnnc_ispresent, ionode_id, comm)
+    IF ( obj%ehub_nnnc_ispresent ) &
+      CALL mp_bcast(obj%ehub_nnnc, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%ehub_lm_max_ispresent, ionode_id, comm)
+    IF ( obj%ehub_lm_max_ispresent ) &
+      CALL mp_bcast(obj%ehub_lm_max, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%ehub_l_choice_ispresent, ionode_id, comm)
+    IF ( obj%ehub_l_choice_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_l_choice, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_l_choice(obj%ndim_ehub_l_choice) )
+      DO i = 1, obj%ndim_ehub_l_choice
+        CALL qes_bcast_ehub_l_choice(obj%ehub_l_choice(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%ehub_u_ispresent, ionode_id, comm)
+    IF ( obj%ehub_u_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_u, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_u(obj%ndim_ehub_u) )
+      DO i = 1, obj%ndim_ehub_u
+        CALL qes_bcast_ehub_u(obj%ehub_u(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%ehub_v_ispresent, ionode_id, comm)
+    IF ( obj%ehub_v_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_v, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_v(obj%ndim_ehub_v) )
+      DO i = 1, obj%ndim_ehub_v
+        CALL qes_bcast_ehub_v(obj%ehub_v(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%ehub_na0_ispresent, ionode_id, comm)
+    IF ( obj%ehub_na0_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_na0, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_na0(obj%ndim_ehub_na0) )
+      DO i = 1, obj%ndim_ehub_na0
+        CALL qes_bcast_ehub_na0(obj%ehub_na0(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%ehub_ne0_ispresent, ionode_id, comm)
+    IF ( obj%ehub_ne0_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_ne0, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_ne0(obj%ndim_ehub_ne0) )
+      DO i = 1, obj%ndim_ehub_ne0
+        CALL qes_bcast_ehub_ne0(obj%ehub_ne0(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%ehub_na0_nc_ispresent, ionode_id, comm)
+    IF ( obj%ehub_na0_nc_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_na0_nc, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_na0_nc(obj%ndim_ehub_na0_nc) )
+      DO i = 1, obj%ndim_ehub_na0_nc
+        CALL qes_bcast_ehub_na0(obj%ehub_na0_nc(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%ehub_ne0_nc_ispresent, ionode_id, comm)
+    IF ( obj%ehub_ne0_nc_ispresent ) THEN
+      CALL mp_bcast(obj%ndim_ehub_ne0_nc, ionode_id, comm)
+      IF ( .NOT.ionode ) ALLOCATE ( obj%ehub_ne0_nc(obj%ndim_ehub_ne0_nc) )
+      DO i = 1, obj%ndim_ehub_ne0_nc
+        CALL qes_bcast_ehub_ne0(obj%ehub_ne0_nc(i), ionode_id, comm)
+      ENDDO
+    ENDIF
+    !
+    CALL mp_bcast(obj%U_projection_type_ispresent, ionode_id, comm)
+    IF ( obj%U_projection_type_ispresent ) &
+      CALL mp_bcast(obj%U_projection_type, ionode_id, comm)
+    !
+  END SUBROUTINE qes_bcast_ehub
+  !
+  !
+  SUBROUTINE qes_bcast_ehub_l_choice( obj, ionode_id, comm )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_l_choice_type), INTENT(INOUT) :: obj
+    INTEGER,                  INTENT(IN)    :: ionode_id, comm
+    !
+    CALL mp_bcast(obj%tagname, ionode_id, comm)
+    CALL mp_bcast(obj%lwrite, ionode_id, comm)
+    CALL mp_bcast(obj%lread, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%ntyp_ispresent, ionode_id, comm)
+    IF (obj%ntyp_ispresent) &
+      CALL mp_bcast(obj%ntyp, ionode_id, comm)
+    CALL mp_bcast(obj%ehublchoice, ionode_id, comm)
+    !
+  END SUBROUTINE qes_bcast_ehub_l_choice
+  !
+  !
+  SUBROUTINE qes_bcast_ehub_u( obj, ionode_id, comm )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_u_type), INTENT(INOUT) :: obj
+    INTEGER,           INTENT(IN)    :: ionode_id, comm
+    INTEGER                          :: length
+    INTEGER                          :: i
+    !
+    CALL mp_bcast(obj%tagname, ionode_id, comm)
+    CALL mp_bcast(obj%lwrite, ionode_id, comm)
+    CALL mp_bcast(obj%lread, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%rank, ionode_id, comm)
+    IF (.NOT.ionode) ALLOCATE(obj%dims(obj%rank))
+    CALL mp_bcast(obj%dims, ionode_id, comm)
+    CALL mp_bcast(obj%order, ionode_id, comm)
+    IF (.NOT. ionode) THEN
+      length = 1
+      DO i=1, obj%rank
+        length = length * obj%dims(i)
+      END DO
+      ALLOCATE ( obj%ehubu(length) )
+    ENDIF
+    CALL mp_bcast(obj%ehubu, ionode_id, comm)
+    !
+  END SUBROUTINE qes_bcast_ehub_u
+  !
+  !
+  SUBROUTINE qes_bcast_ehub_v( obj, ionode_id, comm )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_v_type), INTENT(INOUT) :: obj
+    INTEGER,           INTENT(IN)    :: ionode_id, comm
+    INTEGER                          :: length
+    INTEGER                          :: i
+    !
+    CALL mp_bcast(obj%tagname, ionode_id, comm)
+    CALL mp_bcast(obj%lwrite, ionode_id, comm)
+    CALL mp_bcast(obj%lread, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%rank, ionode_id, comm)
+    IF (.NOT.ionode) ALLOCATE(obj%dims(obj%rank))
+    CALL mp_bcast(obj%dims, ionode_id, comm)
+    CALL mp_bcast(obj%order, ionode_id, comm)
+    IF (.NOT. ionode) THEN
+      length = 1
+      DO i=1, obj%rank
+        length = length * obj%dims(i)
+      END DO
+      ALLOCATE ( obj%ehubv(length) )
+    ENDIF
+    CALL mp_bcast(obj%ehubv, ionode_id, comm)
+    !
+  END SUBROUTINE qes_bcast_ehub_v
+  !
+  !
+  SUBROUTINE qes_bcast_ehub_na0( obj, ionode_id, comm )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_na0_type), INTENT(INOUT) :: obj
+    INTEGER,             INTENT(IN)    :: ionode_id, comm
+    INTEGER                            :: length
+    INTEGER                            :: i
+    !
+    CALL mp_bcast(obj%tagname, ionode_id, comm)
+    CALL mp_bcast(obj%lwrite, ionode_id, comm)
+    CALL mp_bcast(obj%lread, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%rank, ionode_id, comm)
+    IF (.NOT.ionode) ALLOCATE(obj%dims(obj%rank))
+    CALL mp_bcast(obj%dims, ionode_id, comm)
+    CALL mp_bcast(obj%order, ionode_id, comm)
+    IF (.NOT. ionode) THEN
+      length = 1
+      DO i=1, obj%rank
+        length = length * obj%dims(i)
+      END DO
+      ALLOCATE ( obj%ehubna0(length) )
+    ENDIF
+    CALL mp_bcast(obj%ehubna0, ionode_id, comm)
+    !
+  END SUBROUTINE qes_bcast_ehub_na0
+  !
+  !
+  SUBROUTINE qes_bcast_ehub_ne0( obj, ionode_id, comm )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_ne0_type), INTENT(INOUT) :: obj
+    INTEGER,             INTENT(IN)    :: ionode_id, comm
+    INTEGER                            :: length
+    INTEGER                            :: i
+    !
+    CALL mp_bcast(obj%tagname, ionode_id, comm)
+    CALL mp_bcast(obj%lwrite, ionode_id, comm)
+    CALL mp_bcast(obj%lread, ionode_id, comm)
+    !
+    CALL mp_bcast(obj%rank, ionode_id, comm)
+    IF (.NOT.ionode) ALLOCATE(obj%dims(obj%rank))
+    CALL mp_bcast(obj%dims, ionode_id, comm)
+    CALL mp_bcast(obj%order, ionode_id, comm)
+    IF (.NOT. ionode) THEN
+      length = 1
+      DO i=1, obj%rank
+        length = length * obj%dims(i)
+      END DO
+      ALLOCATE ( obj%ehubne0(length) )
+    ENDIF
+    CALL mp_bcast(obj%ehubne0, ionode_id, comm)
+    !
+  END SUBROUTINE qes_bcast_ehub_ne0
+  ! by LSH WIY
+  !
+  !
+END MODULE qes_bcast_module
diff --git a/Modules/qes_init_module.f90 b/Modules/qes_init_module.f90
index 5b5f1ae78..8178b115e 100644
--- a/Modules/qes_init_module.f90
+++ b/Modules/qes_init_module.f90
@@ -134,6 +134,14 @@ MODULE qes_init_module
     MODULE PROCEDURE qes_init_scalarQuantity
     MODULE PROCEDURE qes_init_rism3d
     MODULE PROCEDURE qes_init_rismlaue
+    ! by LSH WIY
+    MODULE PROCEDURE qes_init_ehub
+    MODULE PROCEDURE qes_init_ehub_l_choice
+    MODULE PROCEDURE qes_init_ehub_u
+    MODULE PROCEDURE qes_init_ehub_v
+    MODULE PROCEDURE qes_init_ehub_na0
+    MODULE PROCEDURE qes_init_ehub_ne0
+    ! by LSH WIY
     !
   END INTERFACE qes_init
   !
@@ -1050,7 +1058,9 @@ MODULE qes_init_module
   END SUBROUTINE qes_init_cell
   !
   !
-  SUBROUTINE qes_init_dft(obj, tagname, functional, hybrid, dftU, vdW)
+  ! by LSH
+  SUBROUTINE qes_init_dft( obj, tagname, functional, hybrid, dftU, ehub, vdW )
+  ! by LSH
     !
     IMPLICIT NONE
     !
@@ -1059,6 +1069,9 @@ MODULE qes_init_module
     CHARACTER(LEN=*),INTENT(IN) :: functional
     TYPE(hybrid_type),OPTIONAL,INTENT(IN) :: hybrid
     TYPE(dftU_type),OPTIONAL,INTENT(IN) :: dftU
+    ! by LSH
+    TYPE(ehub_type),OPTIONAL,INTENT(IN) :: ehub
+    ! by LSH
     TYPE(vdW_type),OPTIONAL,INTENT(IN) :: vdW
     !
     obj%tagname = TRIM(tagname)
@@ -1078,6 +1091,14 @@ MODULE qes_init_module
     ELSE
       obj%dftU_ispresent = .FALSE.
     END IF
+    ! by LSH
+    IF ( PRESENT(ehub) ) THEN
+      obj%ehub_ispresent = .TRUE.
+      obj%ehub = ehub
+    ELSE
+      obj%ehub_ispresent = .FALSE.
+    END IF
+    ! by LSH
     IF ( PRESENT(vdW)) THEN
       obj%vdW_ispresent = .TRUE. 
       obj%vdW = vdW
@@ -5047,4 +5068,382 @@ MODULE qes_init_module
   END SUBROUTINE qes_init_rismlaue
   !
   !
-END MODULE qes_init_module
\ No newline at end of file
+  ! by LSH WIY
+  SUBROUTINE qes_init_ehub(obj, tagname, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc,&
+                          ehub_l_choice, ehub_lm_max, U_projection_type, ehub_u, ehub_v,&
+                          ehub_na0, ehub_ne0, ehub_na0_nc, ehub_ne0_nc)
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_type),                                  INTENT(OUT) :: obj
+    CHARACTER(LEN=*),                                 INTENT(IN)  :: tagname
+    LOGICAL,                  OPTIONAL,               INTENT(IN)  :: lacbn0
+    INTEGER,                  OPTIONAL,               INTENT(IN)  :: acbn0_type
+    INTEGER,                  OPTIONAL,               INTENT(IN)  :: ehub_nnnc
+    INTEGER,                  OPTIONAL,               INTENT(IN)  :: ehub_lm_max
+    REAL(DP),                 OPTIONAL,               INTENT(IN)  :: ehub_nn_distance
+    TYPE(ehub_l_choice_type), OPTIONAL, DIMENSION(:), INTENT(IN)  :: ehub_l_choice
+    TYPE(ehub_u_type),        OPTIONAL, DIMENSION(:), INTENT(IN)  :: ehub_u
+    TYPE(ehub_v_type),        OPTIONAL, DIMENSION(:), INTENT(IN)  :: ehub_v
+    TYPE(ehub_na0_type),      OPTIONAL, DIMENSION(:), INTENT(IN)  :: ehub_na0
+    TYPE(ehub_ne0_type),      OPTIONAL, DIMENSION(:), INTENT(IN)  :: ehub_ne0
+    TYPE(ehub_na0_type),   OPTIONAL, DIMENSION(:), INTENT(IN)     :: ehub_na0_nc
+    TYPE(ehub_ne0_type),   OPTIONAL, DIMENSION(:), INTENT(IN)     :: ehub_ne0_nc
+    CHARACTER(LEN=*),         OPTIONAL,               INTENT(IN)  :: U_projection_type
+    !
+    obj%tagname = TRIM(tagname)
+    obj%lwrite = .TRUE.
+    obj%lread = .TRUE.
+    !
+    IF ( PRESENT(lacbn0) ) THEN
+      obj%lacbn0_ispresent = .TRUE.
+      obj%lacbn0 = lacbn0
+    ELSE
+      obj%lacbn0_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(acbn0_type) ) THEN
+      obj%acbn0_type_ispresent = .TRUE.
+      obj%acbn0_type = acbn0_type
+    ELSE
+      obj%acbn0_type_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_nn_distance) ) THEN
+      obj%ehub_nn_distance_ispresent = .TRUE.
+      obj%ehub_nn_distance = ehub_nn_distance
+    ELSE
+      obj%ehub_nn_distance_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_nnnc) ) THEN
+      obj%ehub_nnnc_ispresent = .TRUE.
+      obj%ehub_nnnc = ehub_nnnc
+    ELSE
+      obj%ehub_nnnc_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_lm_max) ) THEN
+      obj%ehub_lm_max_ispresent = .TRUE.
+      obj%ehub_lm_max = ehub_lm_max
+    ELSE
+      obj%ehub_lm_max_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_l_choice) ) THEN
+      obj%ehub_l_choice_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_l_choice(SIZE(ehub_l_choice)) )
+      obj%ndim_ehub_l_choice = SIZE(ehub_l_choice)
+      obj%ehub_l_choice = ehub_l_choice
+    ELSE
+      obj%ehub_l_choice_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_u) ) THEN
+      obj%ehub_u_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_u(SIZE(ehub_u)) )
+      obj%ndim_ehub_u = SIZE(ehub_u)
+      obj%ehub_u = ehub_u
+    ELSE
+      obj%ehub_u_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_v) ) THEN
+      obj%ehub_v_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_v(SIZE(ehub_v)) )
+      obj%ndim_ehub_v = SIZE(ehub_v)
+      obj%ehub_v = ehub_v
+    ELSE
+      obj%ehub_v_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_na0) ) THEN
+      obj%ehub_na0_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_na0(SIZE(ehub_na0)) )
+      obj%ndim_ehub_na0 = SIZE(ehub_na0)
+      obj%ehub_na0 = ehub_na0
+    ELSE
+      obj%ehub_na0_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_ne0) ) THEN
+      obj%ehub_ne0_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_ne0(SIZE(ehub_ne0)) )
+      obj%ndim_ehub_ne0 = SIZE(ehub_ne0)
+      obj%ehub_ne0 = ehub_ne0
+    ELSE
+      obj%ehub_ne0_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_na0_nc) ) THEN
+      obj%ehub_na0_nc_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_na0_nc(SIZE(ehub_na0_nc)) )
+      obj%ndim_ehub_na0_nc = SIZE(ehub_na0_nc)
+      obj%ehub_na0_nc = ehub_na0_nc
+    ELSE
+      obj%ehub_na0_nc_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(ehub_ne0_nc) ) THEN
+      obj%ehub_ne0_nc_ispresent = .TRUE.
+      ALLOCATE ( obj%ehub_ne0_nc(SIZE(ehub_ne0_nc)) )
+      obj%ndim_ehub_ne0_nc = SIZE(ehub_ne0_nc)
+      obj%ehub_ne0_nc = ehub_ne0_nc
+    ELSE
+      obj%ehub_ne0_nc_ispresent = .FALSE.
+    END IF
+    IF ( PRESENT(U_projection_type) ) THEN
+      obj%U_projection_type_ispresent = .TRUE.
+      obj%U_projection_type = U_projection_type
+    ELSE
+      obj%U_projection_type_ispresent = .FALSE.
+    END IF
+    !
+  END SUBROUTINE qes_init_ehub
+  !
+  !
+  SUBROUTINE qes_init_ehub_l_choice(obj, tagname, ntyp, ehub_l_choice)
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_l_choice_type), INTENT(OUT) :: obj
+    CHARACTER(LEN=*),         INTENT(IN)  :: tagname
+    INTEGER, OPTIONAL,        INTENT(IN)  :: ntyp
+    INTEGER, DIMENSION(6),    INTENT(IN)  :: ehub_l_choice
+    !
+    obj%tagname = TRIM(tagname)
+    obj%lwrite = .TRUE.
+    obj%lread = .TRUE.
+    IF (PRESENT(ntyp)) THEN
+      obj%ntyp_ispresent = .TRUE.
+      obj%ntyp = ntyp
+    ELSE
+      obj%ntyp_ispresent = .FALSE.
+    END IF
+    !
+    obj%ehublchoice = ehub_l_choice
+    !
+  END SUBROUTINE qes_init_ehub_l_choice
+  !
+  !
+  SUBROUTINE qes_init_ehub_u(obj, tagname, order, atom, index, ehub_u)
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_u_type),                INTENT(OUT) :: obj
+    CHARACTER(LEN=*),                 INTENT(IN)  :: tagname
+    CHARACTER(LEN=*), OPTIONAL,       INTENT(IN)  :: order
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: atom
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: index
+    REAL(DP),         DIMENSION(:,:), INTENT(IN)  :: ehub_u
+    INTEGER                                       :: length, i
+    !
+    obj%tagname = TRIM(tagname)
+    obj%lwrite = .TRUE.
+    obj%lread = .TRUE.
+    IF (PRESENT(order)) THEN
+      obj%order_ispresent = .TRUE.
+      obj%order = order
+    ELSE
+      obj%order_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(atom)) THEN
+      obj%atom_ispresent = .TRUE.
+      obj%atom = atom
+    ELSE
+      obj%atom_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(index)) THEN
+      obj%index_ispresent = .TRUE.
+      obj%index = index
+    ELSE
+      obj%index_ispresent = .FALSE.
+    END IF
+    !
+    length = 1
+    obj%rank = SIZE(shape(ehub_u))
+    ALLOCATE ( obj%dims(obj%rank))
+    obj%dims = shape(ehub_u)
+    DO i = 1, obj%rank
+      length = length * obj%dims(i)
+    END DO
+    ALLOCATE(obj%ehubu(length))
+    obj%ehubu(1:length) = reshape(ehub_u, [length])
+    !
+  END SUBROUTINE qes_init_ehub_u
+  !
+  !
+  SUBROUTINE qes_init_ehub_v( obj, tagname, order, atom1, atom2, nnc, index, ehub_v)
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_v_type),                INTENT(OUT) :: obj
+    CHARACTER(LEN=*),                 INTENT(IN)  :: tagname
+    CHARACTER(LEN=*), OPTIONAL,       INTENT(IN)  :: order
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: atom1
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: atom2
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: nnc
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: index
+    REAL(DP),         DIMENSION(:,:), INTENT(IN)  :: ehub_v
+    INTEGER                                       :: length, i
+    !
+    obj%tagname = TRIM(tagname)
+    obj%lwrite = .TRUE.
+    obj%lread = .TRUE.
+    IF (PRESENT(order)) THEN
+      obj%order_ispresent = .TRUE.
+      obj%order = order
+    ELSE
+      obj%order_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(atom1)) THEN
+      obj%atom1_ispresent = .TRUE.
+      obj%atom1 = atom1
+    ELSE
+      obj%atom1_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(atom2)) THEN
+      obj%atom2_ispresent = .TRUE.
+      obj%atom2 = atom2
+    ELSE
+      obj%atom2_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(nnc)) THEN
+      obj%nnc_ispresent = .TRUE.
+      obj%nnc = nnc
+    ELSE
+      obj%nnc_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(index)) THEN
+      obj%index_ispresent = .TRUE.
+      obj%index = index
+    ELSE
+      obj%index_ispresent = .FALSE.
+    END IF
+    !
+    length = 1
+    obj%rank = SIZE(shape(ehub_v))
+    ALLOCATE ( obj%dims(obj%rank))
+    obj%dims = shape(ehub_v)
+    DO i = 1, obj%rank
+      length = length * obj%dims(i)
+    END DO
+    ALLOCATE(obj%ehubv(length))
+    obj%ehubv(1:length) = reshape(ehub_v, [length])
+    !
+  END SUBROUTINE qes_init_ehub_v
+  !
+  !
+  SUBROUTINE qes_init_ehub_na0( obj, tagname, order, atom, spin, index, ehub_na0)
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_na0_type),              INTENT(OUT) :: obj
+    CHARACTER(LEN=*),                 INTENT(IN)  :: tagname
+    CHARACTER(LEN=*), OPTIONAL,       INTENT(IN)  :: order
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: atom
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: spin
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: index
+    REAL(DP),         DIMENSION(:,:), INTENT(IN)  :: ehub_na0
+    INTEGER                                       :: length, i
+    !
+    obj%tagname = TRIM(tagname)
+    obj%lwrite = .TRUE.
+    obj%lread = .TRUE.
+    IF (PRESENT(order)) THEN
+      obj%order_ispresent = .TRUE.
+      obj%order = order
+    ELSE
+      obj%order_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(atom)) THEN
+      obj%atom_ispresent = .TRUE.
+      obj%atom = atom
+    ELSE
+      obj%atom_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(spin)) THEN
+      obj%spin_ispresent = .TRUE.
+      obj%spin = spin
+    ELSE
+      obj%spin_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(index)) THEN
+      obj%index_ispresent = .TRUE.
+      obj%index = index
+    ELSE
+      obj%index_ispresent = .FALSE.
+    END IF
+    !
+    length = 1
+    obj%rank = SIZE(shape(ehub_na0))
+    ALLOCATE ( obj%dims(obj%rank) )
+    obj%dims = shape(ehub_na0)
+    DO i = 1, obj%rank
+       length = length * obj%dims(i)
+    END DO
+    ALLOCATE(obj%ehubna0(length))
+    obj%ehubna0(1:length) = reshape(ehub_na0, [length])
+    !
+  END SUBROUTINE qes_init_ehub_na0
+  !
+  !
+  SUBROUTINE qes_init_ehub_ne0( obj, tagname, order, atom1, atom2, spin, nnc, index, ehub_ne0)
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_ne0_type),              INTENT(OUT) :: obj
+    CHARACTER(LEN=*),                 INTENT(IN)  :: tagname
+    CHARACTER(LEN=*), OPTIONAL,       INTENT(IN)  :: order
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: atom1
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: atom2
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: spin
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: nnc
+    INTEGER,          OPTIONAL,       INTENT(IN)  :: index
+    REAL(DP),         DIMENSION(:,:), INTENT(IN)  :: ehub_ne0
+    INTEGER                                       :: length, i
+    !
+    obj%tagname = TRIM(tagname)
+    obj%lwrite = .TRUE.
+    obj%lread = .TRUE.
+    IF (PRESENT(order)) THEN
+      obj%order_ispresent = .TRUE.
+      obj%order = order
+    ELSE
+      obj%order_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(atom1)) THEN
+      obj%atom1_ispresent = .TRUE.
+      obj%atom1 = atom1
+    ELSE
+      obj%atom1_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(atom2)) THEN
+      obj%atom2_ispresent = .TRUE.
+      obj%atom2 = atom2
+    ELSE
+      obj%atom2_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(spin)) THEN
+      obj%spin_ispresent = .TRUE.
+      obj%spin = spin
+    ELSE
+      obj%spin_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(nnc)) THEN
+      obj%nnc_ispresent = .TRUE.
+      obj%nnc = nnc
+    ELSE
+      obj%nnc_ispresent = .FALSE.
+    END IF
+    IF (PRESENT(index)) THEN
+      obj%index_ispresent = .TRUE.
+      obj%index = index
+    ELSE
+      obj%index_ispresent = .FALSE.
+    END IF
+    !
+    length = 1
+    obj%rank = SIZE(shape(ehub_ne0))
+    ALLOCATE ( obj%dims(obj%rank))
+    obj%dims = shape(ehub_ne0)
+    DO i = 1, obj%rank
+       length = length * obj%dims(i)
+    END DO
+    ALLOCATE(obj%ehubne0(length))
+    obj%ehubne0(1:length) = reshape(ehub_ne0, [length])
+    !
+  END SUBROUTINE qes_init_ehub_ne0
+  ! by LSH WIY
+  !
+  !
+END MODULE qes_init_module
diff --git a/Modules/qes_read_module.f90 b/Modules/qes_read_module.f90
index c66391b61..3a32115f5 100644
--- a/Modules/qes_read_module.f90
+++ b/Modules/qes_read_module.f90
@@ -131,6 +131,14 @@ MODULE qes_read_module
     MODULE PROCEDURE qes_read_scalarQuantity
     MODULE PROCEDURE qes_read_rism3d
     MODULE PROCEDURE qes_read_rismlaue
+    ! by LSH WIY
+    MODULE PROCEDURE qes_read_ehub
+    MODULE PROCEDURE qes_read_ehub_l_choice
+    MODULE PROCEDURE qes_read_ehub_u
+    MODULE PROCEDURE qes_read_ehub_v
+    MODULE PROCEDURE qes_read_ehub_na0
+    MODULE PROCEDURE qes_read_ehub_ne0
+    ! by LSH WIY
   END INTERFACE qes_read
   !
   CONTAINS
@@ -3015,6 +3023,28 @@ MODULE qes_read_module
        obj%dftU_ispresent = .FALSE.
     END IF
     !
+    ! by LSH
+    tmp_node_list => getElementsByTagname(xml_node, "ehub")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    IF ( tmp_node_list_size > 1 ) THEN
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:dftType","ehub: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:dftType","ehub: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size>0 ) THEN
+       obj%ehub_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL qes_read_ehub(tmp_node, obj%ehub, ierr)
+    ELSE
+       obj%ehub_ispresent = .FALSE.
+    END IF
+    ! by LSH
+    !
     tmp_node_list => getElementsByTagname(xml_node, "vdW")
     tmp_node_list_size = getLength(tmp_node_list)
     !
@@ -15119,4 +15149,631 @@ MODULE qes_read_module
   END SUBROUTINE qes_read_rismlaue
   !
   !
+  ! by LSH WIY
+  SUBROUTINE qes_read_ehub(xml_node, obj, ierr )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(Node),                INTENT(IN),   POINTER :: xml_node
+    TYPE(ehub_type),           INTENT(OUT)           :: obj
+    INTEGER,         OPTIONAL, INTENT(INOUT)         :: ierr
+    !
+    TYPE(Node),                              POINTER :: tmp_node
+    TYPE(NodeList),                          POINTER :: tmp_node_list
+    INTEGER                                          :: tmp_node_list_size, index, iostat_
+    !
+    obj%tagname = getTagName(xml_node)
+    !
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "lacbn0")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !  
+    IF ( tmp_node_list_size > 1 ) THEN 
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:ehubType","lacbn0: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:ehubType","lacbn0: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%lacbn0_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL extractDataContent(tmp_node, obj%lacbn0, IOSTAT = iostat_)
+       IF ( iostat_ /= 0 ) THEN
+          IF ( PRESENT(ierr) ) THEN
+             CALL infomsg("qes_read:ehubType","error reading lacbn0")
+             ierr = ierr + 1
+          ELSE
+             CALL errore ("qes_read:ehubType","error reading lacbn0",10)
+          END IF
+       END IF
+    ELSE
+       obj%lacbn0_ispresent = .FALSE.
+    END IF
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "acbn0_type")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    IF ( tmp_node_list_size > 1 ) THEN
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:ehubType","acbn0_type: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:ehubType","acbn0_type: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%acbn0_type_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL extractDataContent(tmp_node, obj%acbn0_type, IOSTAT = iostat_)
+       IF ( iostat_ /= 0 ) THEN
+          IF ( PRESENT(ierr) ) THEN
+             CALL infomsg("qes_read:ehubType","error reading acbn0_type")
+             ierr = ierr + 1
+          ELSE
+             CALL errore ("qes_read:ehubType","error reading acbn0_type",10)
+          END IF
+       END IF
+    ELSE
+       obj%acbn0_type_ispresent = .FALSE.
+    END IF
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_nn_distance")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    IF ( tmp_node_list_size > 1 ) THEN
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:ehubType","ehub_nn_distance: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:ehubType","ehub_nn_distance: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_nn_distance_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL extractDataContent(tmp_node, obj%ehub_nn_distance, IOSTAT = iostat_)
+       IF ( iostat_ /= 0 ) THEN
+          IF ( PRESENT(ierr) ) THEN
+             CALL infomsg("qes_read:ehubType","error reading ehub_nn_distance")
+             ierr = ierr + 1
+          ELSE
+             CALL errore ("qes_read:ehubType","error reading ehub_nn_distance",10)
+          END IF
+       END IF
+    ELSE
+       obj%ehub_nn_distance_ispresent = .FALSE.
+    END IF
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_nnnc")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    IF ( tmp_node_list_size > 1 ) THEN
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:ehubType","ehub_nnnc: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:ehubType","ehub_nnnc: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_nnnc_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL extractDataContent(tmp_node, obj%ehub_nnnc, IOSTAT = iostat_)
+       IF ( iostat_ /= 0 ) THEN
+          IF ( PRESENT(ierr) ) THEN
+             CALL infomsg("qes_read:ehubType","error reading ehub_nnnc")
+             ierr = ierr + 1
+          ELSE
+             CALL errore ("qes_read:ehubType","error reading ehub_nnnc",10)
+          END IF
+       END IF
+    ELSE
+       obj%ehub_nnnc_ispresent = .FALSE.
+    END IF
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_lm_max")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    IF ( tmp_node_list_size > 1 ) THEN
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:ehubType","ehub_lm_max: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:ehubType","ehub_lm_max: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_lm_max_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL extractDataContent(tmp_node, obj%ehub_lm_max, IOSTAT = iostat_)
+       IF ( iostat_ /= 0 ) THEN
+          IF ( PRESENT(ierr) ) THEN
+             CALL infomsg("qes_read:ehubType","error reading ehub_lm_max")
+             ierr = ierr + 1
+          ELSE
+             CALL errore ("qes_read:ehubType","error reading ehub_lm_max",10)
+          END IF
+       END IF
+    ELSE
+       obj%ehub_lm_max_ispresent = .FALSE.
+    END IF
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_l_choice")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_l_choice_ispresent = .TRUE.
+    ELSE
+       obj%ehub_l_choice_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_l_choice = tmp_node_list_size
+    ALLOCATE ( obj%ehub_l_choice(tmp_node_list_size) )
+    DO index = 1, tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_l_choice(tmp_node, obj%ehub_l_choice(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_u")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_u_ispresent = .TRUE.
+    ELSE
+       obj%ehub_u_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_u = tmp_node_list_size
+    ALLOCATE ( obj%ehub_u(tmp_node_list_size) )
+    DO index = 1, tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_u(tmp_node, obj%ehub_u(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_v")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_v_ispresent = .TRUE.
+    ELSE
+       obj%ehub_v_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_v = tmp_node_list_size
+    ALLOCATE ( obj%ehub_v(tmp_node_list_size) )
+    DO index = 1, tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_v(tmp_node, obj%ehub_v(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_na0")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_na0_ispresent = .TRUE.
+    ELSE
+       obj%ehub_na0_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_na0 = tmp_node_list_size
+    ALLOCATE ( obj%ehub_na0(tmp_node_list_size) )
+    DO index = 1 ,tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_na0(tmp_node, obj%ehub_na0(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_ne0")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_ne0_ispresent = .TRUE.
+    ELSE
+       obj%ehub_ne0_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_ne0 = tmp_node_list_size
+    ALLOCATE ( obj%ehub_ne0(tmp_node_list_size) )
+    DO index = 1, tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_ne0(tmp_node, obj%ehub_ne0(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_na0_nc")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_na0_nc_ispresent = .TRUE.
+    ELSE
+       obj%ehub_na0_nc_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_na0_nc = tmp_node_list_size
+    ALLOCATE ( obj%ehub_na0_nc(tmp_node_list_size) )
+    DO index = 1 ,tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_na0(tmp_node, obj%ehub_na0_nc(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "ehub_ne0_nc")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%ehub_ne0_nc_ispresent = .TRUE.
+    ELSE
+       obj%ehub_ne0_nc_ispresent = .FALSE.
+    END IF
+    obj%ndim_ehub_ne0_nc = tmp_node_list_size
+    ALLOCATE ( obj%ehub_ne0_nc(tmp_node_list_size) )
+    DO index = 1, tmp_node_list_size
+       tmp_node => item(tmp_node_list, index-1)
+       CALL qes_read_ehub_ne0(tmp_node, obj%ehub_ne0_nc(index), ierr)
+    END DO
+    !
+    tmp_node_list => getElementsByTagname(xml_node, "U_projection_type")
+    tmp_node_list_size = getLength(tmp_node_list)
+    !
+    IF ( tmp_node_list_size > 1 ) THEN
+       IF ( PRESENT(ierr) ) THEN
+          CALL infomsg("qes_read:ehubType","U_projection_type: too many occurrences")
+          ierr = ierr + 1
+       ELSE
+          CALL errore("qes_read:ehubType","U_projection_type: too many occurrences",10)
+       END IF
+    END IF
+    !
+    IF ( tmp_node_list_size > 0 ) THEN
+       obj%U_projection_type_ispresent = .TRUE.
+       tmp_node => item(tmp_node_list, 0)
+       CALL extractDataContent(tmp_node, obj%U_projection_type , IOSTAT = iostat_)
+       IF ( iostat_ /= 0 ) THEN
+          IF ( PRESENT(ierr) ) THEN
+             CALL infomsg("qes_read:ehubType","error reading U_projection_type")
+             ierr = ierr + 1
+          ELSE
+             CALL errore ("qes_read:ehubType","error reading U_projection_type",10)
+          END IF
+       END IF
+    ELSE
+       obj%U_projection_type_ispresent = .FALSE.
+    END IF
+    !
+    !
+    obj%lwrite = .TRUE.
+    !
+  END SUBROUTINE qes_read_ehub
+  !
+  !
+  SUBROUTINE qes_read_ehub_l_choice(xml_node, obj, ierr )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(Node),                  INTENT(IN),   POINTER :: xml_node
+    TYPE(ehub_l_choice_type),    INTENT(OUT)           :: obj
+    INTEGER,           OPTIONAL, INTENT(INOUT)         :: ierr
+    !
+    TYPE(Node),                                POINTER :: tmp_node
+    TYPE(NodeList),                            POINTER :: tmp_node_list
+    INTEGER                                            :: tmp_node_list_size, index, iostat_
+    !
+    obj%tagname = getTagName(xml_node)
+    !
+    IF ( hasAttribute(xml_node, "ntyp") ) THEN
+       CALL extractDataAttribute(xml_node, "ntyp", obj%ntyp)
+       obj%ntyp_ispresent = .TRUE.
+    ELSE
+       obj%ntyp_ispresent = .FALSE.
+    END IF
+    !
+    !
+    !
+    CALL extractDataContent(xml_node, obj%ehublchoice )
+    !
+    obj%lwrite = .TRUE.
+    !
+  END SUBROUTINE qes_read_ehub_l_choice
+  !
+  !
+  SUBROUTINE qes_read_ehub_u(xml_node, obj, ierr )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(Node),                  INTENT(IN),   POINTER :: xml_node
+    TYPE(ehub_u_type),           INTENT(OUT)           :: obj
+    INTEGER,           OPTIONAL, INTENT(INOUT)         :: ierr
+    !
+    TYPE(Node),                                POINTER :: tmp_node
+    TYPE(NodeList),                            POINTER :: tmp_node_list
+    INTEGER                                            :: tmp_node_list_size, index, iostat_
+    INTEGER                                            :: i, length
+    !
+    obj%tagname = getTagName(xml_node)
+    !
+    IF (hasAttribute(xml_node, "rank"))  THEN
+       CALL extractDataAttribute(xml_node, "rank", obj%rank)
+    ELSE
+       CALL errore ("qes_read: ehub_u_Type",&
+                    "required attribute rank not found, can't read further, stopping", 10)
+    END IF
+    ALLOCATE (obj%dims(obj%rank) )
+    IF (hasAttribute(xml_node, "dims")) THEN
+       CALL extractDataAttribute(xml_node, "dims", obj%dims)
+    ELSE
+       CALL errore ("qes_read: ehub_u_Type",&
+                    "required attribute dims not found, can't read further, stopping", 10)
+    END IF
+    IF (hasAttribute(xml_node, "order")) THEN
+       CALL extractDataAttribute(xml_node, "order", obj%order)
+       obj%order_ispresent = .TRUE.
+    ELSE
+       obj%order_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "atom")) THEN
+       CALL extractDataAttribute(xml_node, "atom", obj%atom)
+       obj%atom_ispresent = .TRUE.
+    ELSE
+       obj%atom_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "index")) THEN
+       CALL extractDataAttribute(xml_node, "index", obj%index)
+       obj%index_ispresent = .TRUE.
+    ELSE
+       obj%index_ispresent = .FALSE.
+    END IF
+    !
+    !
+    !
+    length = 1
+    DO i =1, obj%rank
+       length = length * obj%dims(i)
+    END DO
+    ALLOCATE (obj%ehubu(length) )
+    CALL extractDataContent(xml_node, obj%ehubu )
+    !
+    obj%lwrite = .TRUE.
+    !
+  END SUBROUTINE qes_read_ehub_u
+  !
+  !
+  SUBROUTINE qes_read_ehub_v(xml_node, obj, ierr )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(Node),                  INTENT(IN),   POINTER :: xml_node
+    TYPE(ehub_v_type),           INTENT(OUT)           :: obj
+    INTEGER,           OPTIONAL, INTENT(INOUT)         :: ierr
+    !
+    TYPE(Node),                                POINTER :: tmp_node
+    TYPE(NodeList),                            POINTER :: tmp_node_list
+    INTEGER                                            :: tmp_node_list_size, index, iostat_
+    INTEGER                                            :: i, length
+    !
+    obj%tagname = getTagName(xml_node)
+    !
+    IF (hasAttribute(xml_node, "rank") )  THEN
+       CALL extractDataAttribute(xml_node, "rank", obj%rank)
+    ELSE
+       CALL errore ("qes_read: ehub_v_Type",&
+                    "required attribute rank not found, can't read further, stopping", 10)
+    END IF
+    ALLOCATE (obj%dims(obj%rank) )
+    IF (hasAttribute(xml_node, "dims") ) THEN
+       CALL extractDataAttribute(xml_node, "dims", obj%dims)
+    ELSE
+       CALL errore ("qes_read: ehub_v_Type",&
+                    "required attribute dims not found, can't read further, stopping", 10)
+    END IF
+    IF (hasAttribute(xml_node, "order")) THEN
+       CALL extractDataAttribute(xml_node, "order", obj%order)
+       obj%order_ispresent = .TRUE.
+    ELSE
+       obj%order_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "atom1")) THEN
+       CALL extractDataAttribute(xml_node, "atom1", obj%atom1)
+       obj%atom1_ispresent = .TRUE.
+    ELSE
+       obj%atom1_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "atom2")) THEN
+       CALL extractDataAttribute(xml_node, "atom2", obj%atom2)
+       obj%atom2_ispresent = .TRUE.
+    ELSE
+       obj%atom2_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "nnc")) THEN
+       CALL extractDataAttribute(xml_node, "nnc", obj%nnc)
+       obj%nnc_ispresent = .TRUE.
+    ELSE
+       obj%nnc_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "index")) THEN
+       CALL extractDataAttribute(xml_node, "index", obj%index)
+       obj%index_ispresent = .TRUE.
+    ELSE
+       obj%index_ispresent = .FALSE.
+    END IF
+    !
+    !
+    !
+    length = 1
+    DO i =1, obj%rank
+       length = length * obj%dims(i)
+    END DO
+    ALLOCATE (obj%ehubv(length) )
+    CALL extractDataContent(xml_node, obj%ehubv )
+    !
+    obj%lwrite = .TRUE.
+    !
+  END SUBROUTINE qes_read_ehub_v
+  !
+  !
+  SUBROUTINE qes_read_ehub_na0(xml_node, obj, ierr )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(Node),                    INTENT(IN),   POINTER :: xml_node
+    TYPE(ehub_na0_type),           INTENT(OUT)           :: obj
+    INTEGER,             OPTIONAL, INTENT(INOUT)         :: ierr
+    !
+    TYPE(Node),                                  POINTER :: tmp_node
+    TYPE(NodeList),                              POINTER :: tmp_node_list
+    INTEGER                                              :: tmp_node_list_size, index, iostat_
+    INTEGER                                              :: i, length
+    !
+    obj%tagname = getTagName(xml_node)
+    !
+    IF (hasAttribute(xml_node, "rank"))  THEN
+       CALL extractDataAttribute(xml_node, "rank", obj%rank)
+    ELSE
+       CALL errore ("qes_read: ehub_na0_Type",&
+                    "required attribute rank not found, can't read further, stopping", 10)
+    END IF
+    ALLOCATE (obj%dims(obj%rank))
+    IF (hasAttribute(xml_node, "dims")) THEN
+       CALL extractDataAttribute(xml_node, "dims", obj%dims)
+    ELSE
+       CALL errore ("qes_read: ehub_na0_Type",&
+                    "required attribute dims not found, can't read further, stopping", 10)
+    END IF
+    IF (hasAttribute(xml_node, "order")) THEN
+       CALL extractDataAttribute(xml_node, "order", obj%order)
+       obj%order_ispresent = .TRUE.
+    ELSE
+       obj%order_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "atom")) THEN
+       CALL extractDataAttribute(xml_node, "atom", obj%atom)
+       obj%atom_ispresent = .TRUE.
+    ELSE
+       obj%atom_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "spin")) THEN
+       CALL extractDataAttribute(xml_node, "spin", obj%spin)
+       obj%spin_ispresent = .TRUE.
+    ELSE
+       obj%spin_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "index")) THEN
+       CALL extractDataAttribute(xml_node, "index", obj%index)
+       obj%index_ispresent = .TRUE.
+    ELSE
+       obj%index_ispresent = .FALSE.
+    END IF
+    !
+    !
+    !
+    length = 1
+    DO i =1, obj%rank
+       length = length * obj%dims(i)
+    END DO
+    ALLOCATE (obj%ehubna0(length) )
+    CALL extractDataContent(xml_node, obj%ehubna0)
+    !
+    obj%lwrite = .TRUE.
+    !
+  END SUBROUTINE qes_read_ehub_na0
+  !
+  !
+  SUBROUTINE qes_read_ehub_ne0(xml_node, obj, ierr )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(Node),                    INTENT(IN),   POINTER :: xml_node
+    TYPE(ehub_ne0_type),           INTENT(OUT)           :: obj
+    INTEGER,             OPTIONAL, INTENT(INOUT)         :: ierr
+    !
+    TYPE(Node),                                  POINTER :: tmp_node
+    TYPE(NodeList),                              POINTER :: tmp_node_list
+    INTEGER                                              :: tmp_node_list_size, index, iostat_
+    INTEGER                                              :: i, length
+    !
+    obj%tagname = getTagName(xml_node)
+    !
+    IF ( hasAttribute(xml_node, "rank") )  THEN
+       CALL extractDataAttribute(xml_node, "rank", obj%rank)
+    ELSE
+       CALL errore ("qes_read: ehub_ne0_Type",&
+                    "required attribute rank not found, can't read further, stopping", 10)
+    END IF
+    ALLOCATE ( obj%dims(obj%rank) )
+    IF ( hasAttribute(xml_node, "dims") ) THEN
+       CALL extractDataAttribute(xml_node, "dims", obj%dims)
+    ELSE
+       CALL errore ("qes_read: ehub_ne0_Type",&
+                    "required attribute dims not found, can't read further, stopping", 10)
+    END IF
+    IF (hasAttribute(xml_node, "order")) THEN
+       CALL extractDataAttribute(xml_node, "order", obj%order)
+       obj%order_ispresent = .TRUE.
+    ELSE
+       obj%order_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "atom1")) THEN
+       CALL extractDataAttribute(xml_node, "atom1", obj%atom1)
+       obj%atom1_ispresent = .TRUE.
+    ELSE
+       obj%atom1_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "atom2")) THEN
+       CALL extractDataAttribute(xml_node, "atom2", obj%atom2)
+       obj%atom2_ispresent = .TRUE.
+    ELSE
+       obj%atom2_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "spin")) THEN
+       CALL extractDataAttribute(xml_node, "spin", obj%spin)
+       obj%spin_ispresent = .TRUE.
+    ELSE
+       obj%spin_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "nnc")) THEN
+       CALL extractDataAttribute(xml_node, "nnc", obj%nnc)
+       obj%nnc_ispresent = .TRUE.
+    ELSE
+       obj%nnc_ispresent = .FALSE.
+    END IF
+    !
+    IF (hasAttribute(xml_node, "index")) THEN
+       CALL extractDataAttribute(xml_node, "index", obj%index)
+       obj%index_ispresent = .TRUE.
+    ELSE
+       obj%index_ispresent = .FALSE.
+    END IF
+    !
+    !
+    !
+    length = 1
+    DO i =1, obj%rank
+       length = length * obj%dims(i)
+    END DO
+    ALLOCATE (obj%ehubne0(length) )
+    CALL extractDataContent(xml_node, obj%ehubne0)
+    !
+    obj%lwrite = .TRUE.
+    !
+  END SUBROUTINE qes_read_ehub_ne0
+  ! by LSH WIY
+  !
+  !
 END MODULE qes_read_module
diff --git a/Modules/qes_reset_module.f90 b/Modules/qes_reset_module.f90
index 8bd78cd52..78986fc6b 100644
--- a/Modules/qes_reset_module.f90
+++ b/Modules/qes_reset_module.f90
@@ -128,6 +128,14 @@ MODULE qes_reset_module
     MODULE PROCEDURE qes_reset_scalarQuantity
     MODULE PROCEDURE qes_reset_rism3d
     MODULE PROCEDURE qes_reset_rismlaue
+    ! by LSH WIY
+    MODULE PROCEDURE qes_reset_ehub
+    MODULE PROCEDURE qes_reset_ehub_l_choice
+    MODULE PROCEDURE qes_reset_ehub_u
+    MODULE PROCEDURE qes_reset_ehub_v
+    MODULE PROCEDURE qes_reset_ehub_na0
+    MODULE PROCEDURE qes_reset_ehub_ne0
+    ! by LSH WIY
   END INTERFACE qes_reset
   !
   CONTAINS
@@ -599,6 +607,11 @@ MODULE qes_reset_module
     IF (obj%dftU_ispresent) &
       CALL qes_reset_dftU(obj%dftU)
     obj%dftU_ispresent = .FALSE.
+    ! by LSH
+    IF (obj%ehub_ispresent) &
+      CALL qes_reset_ehub(obj%ehub)
+    obj%ehub_ispresent = .FALSE.
+    ! by LSH
     IF (obj%vdW_ispresent) &
       CALL qes_reset_vdW(obj%vdW)
     obj%vdW_ispresent = .FALSE.
@@ -2380,4 +2393,226 @@ MODULE qes_reset_module
   END SUBROUTINE qes_reset_rismlaue
   !
   !
-END MODULE qes_reset_module
\ No newline at end of file
+  ! by LSH WIY
+  SUBROUTINE qes_reset_ehub( obj )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_type), INTENT(INOUT) :: obj
+    INTEGER                        :: i
+    !
+    obj%tagname = ""
+    obj%lwrite = .FALSE.
+    obj%lread = .FALSE.
+    !
+    obj%lacbn0_ispresent = .FALSE.
+    obj%acbn0_type_ispresent = .FALSE.
+    obj%ehub_nn_distance_ispresent = .FALSE.
+    obj%ehub_nnnc = .FALSE.
+    obj%ehub_lm_max = .FALSE.
+    !
+    IF ( obj%ehub_l_choice_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_l_choice) ) THEN
+        DO i = 1, SIZE(obj%ehub_l_choice)
+          CALL qes_reset_ehub_l_choice(obj%ehub_l_choice(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_l_choice )
+      ENDIF
+      obj%ndim_ehub_l_choice = 0
+      obj%ehub_l_choice_ispresent = .FALSE.
+    ENDIF
+    !
+    IF ( obj%ehub_u_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_u) ) THEN
+        DO i = 1, SIZE(obj%ehub_u)
+          CALL qes_reset_ehub_u(obj%ehub_u(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_u )
+      ENDIF
+      obj%ndim_ehub_u = 0
+      obj%ehub_u_ispresent = .FALSE.
+    ENDIF
+    !
+    IF ( obj%ehub_v_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_v) ) THEN
+        DO i = 1, SIZE(obj%ehub_v)
+          CALL qes_reset_ehub_v(obj%ehub_v(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_v )
+      ENDIF
+      obj%ndim_ehub_v = 0
+      obj%ehub_v_ispresent = .FALSE.
+    ENDIF
+    !
+    IF ( obj%ehub_na0_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_na0) ) THEN
+        DO i = 1, SIZE(obj%ehub_na0)
+          CALL qes_reset_ehub_na0(obj%ehub_na0(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_na0 )
+      ENDIF
+      obj%ndim_ehub_na0 = 0
+      obj%ehub_na0_ispresent = .FALSE.
+    ENDIF
+    !
+    IF ( obj%ehub_ne0_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_ne0) ) THEN
+        DO i = 1, SIZE(obj%ehub_ne0)
+          CALL qes_reset_ehub_ne0(obj%ehub_ne0(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_ne0 )
+      ENDIF
+      obj%ndim_ehub_ne0 = 0
+      obj%ehub_ne0_ispresent = .FALSE.
+    ENDIF
+    !
+    IF ( obj%ehub_na0_nc_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_na0_nc) ) THEN
+        DO i = 1, SIZE(obj%ehub_na0_nc)
+          CALL qes_reset_ehub_na0(obj%ehub_na0_nc(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_na0_nc )
+      ENDIF
+      obj%ndim_ehub_na0_nc = 0
+      obj%ehub_na0_nc_ispresent = .FALSE.
+    ENDIF
+    !
+    IF ( obj%ehub_ne0_nc_ispresent ) THEN
+      IF ( ALLOCATED(obj%ehub_ne0_nc) ) THEN
+        DO i = 1, SIZE(obj%ehub_ne0_nc)
+          CALL qes_reset_ehub_ne0(obj%ehub_ne0_nc(i))
+        ENDDO
+        DEALLOCATE ( obj%ehub_ne0_nc )
+      ENDIF
+      obj%ndim_ehub_ne0_nc = 0
+      obj%ehub_ne0_nc_ispresent = .FALSE.
+    ENDIF
+    !
+    obj%U_projection_type_ispresent = .FALSE.
+    !
+  END SUBROUTINE qes_reset_ehub
+  !
+  !
+  SUBROUTINE qes_reset_ehub_l_choice( obj )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_l_choice_type), INTENT(INOUT) :: obj
+    !
+    obj%tagname = ""
+    obj%lwrite = .FALSE.
+    obj%lread = .FALSE.
+    !
+    obj%ntyp_ispresent = .FALSE.
+    !
+  END SUBROUTINE qes_reset_ehub_l_choice
+  !
+  !
+  SUBROUTINE qes_reset_ehub_u( obj )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_u_type), INTENT(INOUT) :: obj
+    !
+    obj%tagname = ""
+    obj%lwrite = .FALSE.
+    obj%lread = .FALSE.
+    !
+    IF (ALLOCATED(obj%ehubu)) THEN
+      DEALLOCATE(obj%ehubu)
+    ENDIF
+    IF (ALLOCATED(obj%dims)) THEN
+      DEALLOCATE(obj%dims)
+    ENDIF
+    obj%rank = 0
+    obj%order = 'F'
+    obj%order_ispresent = .FALSE.
+    obj%atom_ispresent = .FALSE.
+    obj%index_ispresent = .FALSE.
+    !
+  END SUBROUTINE qes_reset_ehub_u
+  !
+  !
+  SUBROUTINE qes_reset_ehub_v( obj )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_v_type), INTENT(INOUT) :: obj
+    !
+    obj%tagname = ""
+    obj%lwrite = .FALSE.
+    obj%lread = .FALSE.
+    !
+    IF (ALLOCATED(obj%ehubv)) THEN
+      DEALLOCATE(obj%ehubv)
+    ENDIF
+    IF (ALLOCATED(obj%dims)) THEN
+      DEALLOCATE(obj%dims)
+    ENDIF
+    obj%rank = 0
+    obj%order = 'F'
+    obj%order_ispresent = .FALSE.
+    obj%atom1_ispresent = .FALSE.
+    obj%atom2_ispresent = .FALSE.
+    obj%nnc_ispresent = .FALSE.
+    obj%index_ispresent = .FALSE.
+    !
+  END SUBROUTINE qes_reset_ehub_v
+  !
+  !
+  SUBROUTINE qes_reset_ehub_na0( obj )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_na0_type), INTENT(INOUT) :: obj
+    !
+    obj%tagname = ""
+    obj%lwrite = .FALSE.
+    obj%lread = .FALSE.
+    !
+    IF (ALLOCATED(obj%ehubna0)) THEN
+      DEALLOCATE(obj%ehubna0)
+    ENDIF
+    IF (ALLOCATED(obj%dims)) THEN
+      DEALLOCATE(obj%dims)
+    ENDIF
+    obj%rank = 0
+    obj%order = 'F'
+    obj%order_ispresent = .FALSE.
+    obj%atom_ispresent = .FALSE.
+    obj%spin_ispresent = .FALSE.
+    obj%index_ispresent = .FALSE.
+    !
+  END SUBROUTINE qes_reset_ehub_na0
+  !
+  !
+  SUBROUTINE qes_reset_ehub_ne0( obj )
+    !
+    IMPLICIT NONE
+    !
+    TYPE(ehub_ne0_type), INTENT(INOUT) :: obj
+    !
+    obj%tagname = ""
+    obj%lwrite = .FALSE.
+    obj%lread = .FALSE.
+    !
+    IF (ALLOCATED(obj%ehubne0)) THEN
+      DEALLOCATE(obj%ehubne0)
+    ENDIF
+    IF (ALLOCATED(obj%dims)) THEN
+      DEALLOCATE(obj%dims)
+    ENDIF
+    obj%rank = 0
+    obj%order = 'F'
+    obj%order_ispresent = .FALSE.
+    obj%atom1_ispresent = .FALSE.
+    obj%atom2_ispresent = .FALSE.
+    obj%spin_ispresent = .FALSE.
+    obj%nnc_ispresent = .FALSE.
+    obj%index_ispresent = .FALSE.
+    !
+  END SUBROUTINE qes_reset_ehub_ne0
+  ! by LSH WIY
+  !
+  !
+END MODULE qes_reset_module
diff --git a/Modules/qes_types_module.f90 b/Modules/qes_types_module.f90
index 325592bf3..be330f86c 100644
--- a/Modules/qes_types_module.f90
+++ b/Modules/qes_types_module.f90
@@ -235,6 +235,122 @@ MODULE qes_types_module
     !
   END TYPE Hubbard_ns_type
   !
+  TYPE :: backL_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    INTEGER :: l_index
+    LOGICAL :: l_index_ispresent = .FALSE.
+    !
+    INTEGER :: backL
+    !
+  END TYPE backL_type
+  !
+  ! by LSH WIY
+  TYPE :: ehub_l_choice_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    INTEGER :: ntyp
+    LOGICAL :: ntyp_ispresent = .FALSE.
+    !
+    INTEGER, DIMENSION(6) :: ehublchoice
+    !
+  END TYPE ehub_l_choice_type
+  !
+  TYPE :: ehub_u_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    INTEGER :: rank
+    INTEGER, DIMENSION(:), ALLOCATABLE :: dims
+    CHARACTER(len=256) :: order
+    LOGICAL :: order_ispresent = .FALSE.
+    INTEGER :: atom
+    LOGICAL :: atom_ispresent = .FALSE.
+    INTEGER :: index
+    LOGICAL :: index_ispresent = .FALSE.
+    !
+    REAL(DP), DIMENSION(:), ALLOCATABLE :: ehubu
+    !
+  END TYPE ehub_u_type
+  !
+  TYPE :: ehub_v_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    INTEGER :: rank
+    INTEGER, DIMENSION(:), ALLOCATABLE :: dims
+    CHARACTER(len=256) :: order
+    LOGICAL :: order_ispresent = .FALSE.
+    INTEGER :: atom1
+    LOGICAL :: atom1_ispresent = .FALSE.
+    INTEGER :: atom2
+    LOGICAL :: atom2_ispresent = .FALSE.
+    INTEGER :: nnc
+    LOGICAL :: nnc_ispresent = .FALSE.
+    INTEGER :: index
+    LOGICAL :: index_ispresent = .FALSE.
+    !
+    REAL(DP), DIMENSION(:), ALLOCATABLE :: ehubv
+    !
+  END TYPE ehub_v_type
+  !
+  TYPE :: ehub_na0_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    INTEGER :: rank
+    INTEGER, DIMENSION(:), ALLOCATABLE :: dims
+    CHARACTER(len=256) :: order
+    LOGICAL :: order_ispresent = .FALSE.
+    INTEGER :: atom
+    LOGICAL :: atom_ispresent = .FALSE.
+    INTEGER :: spin
+    LOGICAL :: spin_ispresent = .FALSE.
+    INTEGER :: index
+    LOGICAL :: index_ispresent = .FALSE.
+    !
+    REAL(DP), DIMENSION(:), ALLOCATABLE :: ehubna0
+    !
+  END TYPE ehub_na0_type
+  !
+  TYPE :: ehub_ne0_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    INTEGER :: rank
+    INTEGER, DIMENSION(:), ALLOCATABLE :: dims
+    CHARACTER(len=256) :: order
+    LOGICAL :: order_ispresent = .FALSE.
+    INTEGER :: atom1
+    LOGICAL :: atom1_ispresent = .FALSE.
+    INTEGER :: atom2
+    LOGICAL :: atom2_ispresent = .FALSE.
+    INTEGER :: spin
+    LOGICAL :: spin_ispresent = .FALSE.
+    INTEGER :: nnc
+    LOGICAL :: nnc_ispresent = .FALSE.
+    INTEGER :: index
+    LOGICAL :: index_ispresent = .FALSE.
+    !
+    REAL(DP), DIMENSION(:), ALLOCATABLE :: ehubne0
+    !
+  END TYPE ehub_ne0_type
+  ! by LSH WIY
+  !
   TYPE :: smearing_type
     !
     CHARACTER(len=100) :: tagname
@@ -663,6 +779,62 @@ MODULE qes_types_module
     !
   END TYPE HubbardBack_type
   !
+  ! by LSH WIY
+  TYPE :: ehub_type
+    !
+    CHARACTER(len=100) :: tagname
+    LOGICAL  :: lwrite = .FALSE.
+    LOGICAL  :: lread  = .FALSE.
+    !
+    LOGICAL  :: lacbn0_ispresent = .FALSE.
+    LOGICAL  :: lacbn0
+    !
+    LOGICAL  :: acbn0_type_ispresent = .FALSE.
+    INTEGER  :: acbn0_type
+    !
+    LOGICAL  :: ehub_nn_distance_ispresent = .FALSE.
+    REAL(DP) :: ehub_nn_distance
+    !
+    LOGICAL  :: ehub_nnnc_ispresent = .FALSE.
+    INTEGER  :: ehub_nnnc
+    !
+    LOGICAL  :: ehub_lm_max_ispresent = .FALSE.
+    INTEGER  :: ehub_lm_max
+    !
+    LOGICAL  :: ehub_l_choice_ispresent = .FALSE.
+    TYPE(ehub_l_choice_type), DIMENSION(:), ALLOCATABLE :: ehub_l_choice
+    INTEGER  :: ndim_ehub_l_choice
+    !
+    LOGICAL  :: ehub_u_ispresent = .FALSE.
+    TYPE(ehub_u_type), DIMENSION(:), ALLOCATABLE :: ehub_u
+    INTEGER  :: ndim_ehub_u
+    !
+    LOGICAL  :: ehub_v_ispresent = .FALSE.
+    TYPE(ehub_v_type), DIMENSION(:), ALLOCATABLE :: ehub_v
+    INTEGER  :: ndim_ehub_v
+    !
+    LOGICAL  :: ehub_na0_ispresent = .FALSE.
+    TYPE(ehub_na0_type), DIMENSION(:), ALLOCATABLE :: ehub_na0
+    INTEGER  :: ndim_ehub_na0
+    !
+    LOGICAL  :: ehub_ne0_ispresent = .FALSE.
+    TYPE(ehub_ne0_type), DIMENSION(:), ALLOCATABLE :: ehub_ne0
+    INTEGER  :: ndim_ehub_ne0
+    !
+    LOGICAL  :: ehub_na0_nc_ispresent = .FALSE.
+    TYPE(ehub_na0_type), DIMENSION(:), ALLOCATABLE :: ehub_na0_nc
+    INTEGER  :: ndim_ehub_na0_nc
+    !
+    LOGICAL  :: ehub_ne0_nc_ispresent = .FALSE.
+    TYPE(ehub_ne0_type), DIMENSION(:), ALLOCATABLE :: ehub_ne0_nc
+    INTEGER  :: ndim_ehub_ne0_nc
+    !
+    LOGICAL  :: U_projection_type_ispresent = .FALSE.
+    CHARACTER(len=256) :: U_projection_type
+    !
+  END TYPE ehub_type
+  ! by LSH WIY
+  !
   TYPE :: vdW_type
     !
     CHARACTER(len=100) :: tagname
@@ -1874,6 +2046,10 @@ MODULE qes_types_module
     TYPE(hybrid_type) :: hybrid
     LOGICAL  :: dftU_ispresent = .FALSE.
     TYPE(dftU_type) :: dftU
+    ! by LSH
+    LOGICAL  :: ehub_ispresent = .FALSE.
+    TYPE(ehub_type) :: ehub
+    ! by LSH
     LOGICAL  :: vdW_ispresent = .FALSE.
     TYPE(vdW_type) :: vdW
     !
@@ -2026,4 +2202,4 @@ MODULE qes_types_module
   END TYPE espresso_type
   !
   !
-END MODULE qes_types_module
\ No newline at end of file
+END MODULE qes_types_module
diff --git a/Modules/qes_write_module.f90 b/Modules/qes_write_module.f90
index 32b96809c..19db30a6d 100644
--- a/Modules/qes_write_module.f90
+++ b/Modules/qes_write_module.f90
@@ -130,6 +130,14 @@ MODULE qes_write_module
     MODULE PROCEDURE qes_write_scalarQuantity
     MODULE PROCEDURE qes_write_rism3d
     MODULE PROCEDURE qes_write_rismlaue
+    ! by LSH WIY
+    MODULE PROCEDURE qes_write_ehub
+    MODULE PROCEDURE qes_write_ehub_l_choice
+    MODULE PROCEDURE qes_write_ehub_u
+    MODULE PROCEDURE qes_write_ehub_v
+    MODULE PROCEDURE qes_write_ehub_na0
+    MODULE PROCEDURE qes_write_ehub_ne0
+    ! by LSH WIY
   END INTERFACE qes_write
   !
   CONTAINS
@@ -740,6 +748,11 @@ MODULE qes_write_module
      IF (obj%dftU_ispresent) THEN
         CALL qes_write_dftU (xp, obj%dftU)
      END IF
+     ! by LSH
+     IF (obj%ehub_ispresent) THEN
+        CALL qes_write_ehub (xp, obj%ehub)
+     END IF
+     ! by LSH
      IF (obj%vdW_ispresent) THEN
         CALL qes_write_vdW (xp, obj%vdW)
      END IF
@@ -3594,5 +3607,205 @@ MODULE qes_write_module
      CALL xml_EndElement(xp, TRIM(obj%tagname))
    END SUBROUTINE qes_write_rismlaue
 
+   ! by LSH WIY
+   SUBROUTINE qes_write_ehub(xp, obj)
+     !-----------------------------------------------------------------
+     IMPLICIT NONE
+     TYPE(xmlf_t),    INTENT(INOUT) :: xp
+     TYPE(ehub_type), INTENT(IN)    :: obj
+     ! 
+     INTEGER                        :: i
+     ! 
+     IF ( .NOT. obj%lwrite ) RETURN
+     ! 
+     CALL xml_NewElement(xp, TRIM(obj%tagname))
+     IF (obj%lacbn0_ispresent) THEN
+        CALL xml_NewElement(xp, "lacbn0")
+           CALL xml_addCharacters(xp, obj%lacbn0)
+        CALL xml_EndElement(xp, "lacbn0")
+     END IF
+     IF ( obj%acbn0_type_ispresent ) THEN
+        CALL xml_NewElement(xp, "acbn0_type")
+           CALL xml_addCharacters(xp, obj%acbn0_type)
+        CALL xml_EndElement(xp, "acbn0_type")
+     END IF
+     IF ( obj%ehub_nn_distance_ispresent ) THEN
+        CALL xml_NewElement(xp, "ehub_nn_distance")
+           CALL xml_addCharacters(xp, obj%ehub_nn_distance)
+        CALL xml_EndElement(xp, "ehub_nn_distance")
+     END IF
+     IF ( obj%ehub_nnnc_ispresent ) THEN
+        CALL xml_NewElement(xp, "ehub_nnnc")
+           CALL xml_addCharacters(xp, obj%ehub_nnnc)
+        CALL xml_EndElement(xp, "ehub_nnnc")
+     END IF
+     IF ( obj%ehub_lm_max_ispresent ) THEN
+        CALL xml_NewElement(xp, "ehub_lm_max")
+           CALL xml_addCharacters(xp, obj%ehub_lm_max)
+        CALL xml_EndElement(xp, "ehub_lm_max")
+     END IF
+     IF ( obj%ehub_l_choice_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_l_choice
+           CALL qes_write_ehub_l_choice(xp, obj%ehub_l_choice(i))
+        END DO
+     END IF
+     IF ( obj%ehub_u_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_u
+           CALL qes_write_ehub_u(xp, obj%ehub_u(i))
+        END DO
+     END IF
+     IF ( obj%ehub_v_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_v
+           CALL qes_write_ehub_v(xp, obj%ehub_v(i))
+        END DO
+     END IF
+     IF ( obj%ehub_na0_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_na0
+           CALL qes_write_ehub_na0(xp, obj%ehub_na0(i))
+        END DO
+     END IF
+     IF ( obj%ehub_ne0_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_ne0
+           CALL qes_write_ehub_ne0(xp, obj%ehub_ne0(i))
+        END DO
+     END IF
+     IF ( obj%ehub_na0_nc_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_na0_nc
+           CALL qes_write_ehub_na0(xp, obj%ehub_na0_nc(i))
+        END DO
+     END IF
+     IF ( obj%ehub_ne0_nc_ispresent ) THEN
+        DO i = 1, obj%ndim_ehub_ne0_nc
+           CALL qes_write_ehub_ne0(xp, obj%ehub_ne0_nc(i))
+        END DO
+     END IF
+     IF ( obj%U_projection_type_ispresent ) THEN
+        CALL xml_NewElement(xp, "U_projection_type")
+           CALL xml_addCharacters(xp, TRIM(obj%U_projection_type))
+        CALL xml_EndElement(xp, "U_projection_type")
+     END IF
+     CALL xml_EndElement(xp, TRIM(obj%tagname))
+   END SUBROUTINE qes_write_ehub
+
+   SUBROUTINE qes_write_ehub_l_choice(xp, obj)
+     !-----------------------------------------------------------------
+     IMPLICIT NONE
+     TYPE(xmlf_t)             ,INTENT(INOUT) :: xp
+     TYPE(ehub_l_choice_type) ,INTENT(IN)    :: obj
+     ! 
+     INTEGER                                 :: i
+     !
+     IF ( .NOT. obj%lwrite ) RETURN
+     ! 
+     CALL xml_NewElement(xp, TRIM(obj%tagname))
+     IF (obj%ntyp_ispresent) CALL xml_addAttribute(xp, 'ntyp', obj%ntyp )
+        CALL xml_AddCharacters(xp, obj%ehublchoice, fmt='s16')
+     CALL xml_EndElement(xp, TRIM(obj%tagname))
+   END SUBROUTINE qes_write_ehub_l_choice
+
+   SUBROUTINE qes_write_ehub_u(xp, obj)
+     !-----------------------------------------------------------------
+     IMPLICIT NONE
+     TYPE(xmlf_t)      ,INTENT(INOUT) :: xp
+     TYPE(ehub_u_type) ,INTENT(IN)    :: obj
+     ! 
+     INTEGER                          :: i
+     ! 
+     IF ( .NOT. obj%lwrite ) RETURN
+     ! 
+     CALL xml_NewElement(xp, TRIM(obj%tagname))
+     CALL xml_addAttribute(xp, 'rank', obj%rank )
+     CALL xml_addAttribute(xp, 'dims', obj%dims )
+     IF (obj%order_ispresent) CALL xml_addAttribute(xp, 'order', TRIM(obj%order) )
+     IF (obj%atom_ispresent) CALL xml_addAttribute(xp, 'atom', obj%atom)
+     IF (obj%index_ispresent) CALL xml_addAttribute(xp, 'index', obj%index)
+       CALL xml_addNewLine(xp)
+        DO i = 1, obj%dims(2)
+           CALL xml_AddCharacters(xp, obj%ehubu((i-1)*obj%dims(1)+1: i*obj%dims(1)), fmt ='s16')
+           CALL xml_addNewLine(xp)
+        END DO
+     CALL xml_EndElement(xp, TRIM(obj%tagname))
+   END SUBROUTINE qes_write_ehub_u
+
+   SUBROUTINE qes_write_ehub_v( xp, obj )
+     !-----------------------------------------------------------------
+     IMPLICIT NONE
+     TYPE(xmlf_t)      ,INTENT(INOUT) :: xp
+     TYPE(ehub_v_type) ,INTENT(IN)    :: obj
+     ! 
+     INTEGER                          :: i
+     ! 
+     IF ( .NOT. obj%lwrite ) RETURN
+     ! 
+     CALL xml_NewElement(xp, TRIM(obj%tagname))
+     CALL xml_addAttribute(xp, 'rank', obj%rank )
+     CALL xml_addAttribute(xp, 'dims', obj%dims )
+     IF (obj%order_ispresent) CALL xml_addAttribute(xp, 'order', TRIM(obj%order) )
+     IF (obj%atom1_ispresent) CALL xml_addAttribute(xp, 'atom1', obj%atom1 )
+     IF (obj%atom2_ispresent) CALL xml_addAttribute(xp, 'atom2', obj%atom2 )
+     IF (obj%nnc_ispresent) CALL xml_addAttribute(xp, 'nnc', obj%nnc )
+     IF (obj%index_ispresent) CALL xml_addAttribute(xp, 'index', obj%index )
+       CALL xml_addNewLine(xp)
+        DO i = 1, obj%dims(2)
+           CALL xml_AddCharacters(xp, obj%ehubv((i-1)*obj%dims(1)+1: i*obj%dims(1)), fmt ='s16')
+           CALL xml_addNewLine(xp)
+        END DO
+     CALL xml_EndElement(xp, TRIM(obj%tagname))
+   END SUBROUTINE qes_write_ehub_v
+
+   SUBROUTINE qes_write_ehub_na0( xp, obj )
+     !-----------------------------------------------------------------
+     IMPLICIT NONE
+     TYPE(xmlf_t)        ,INTENT(INOUT) :: xp
+     TYPE(ehub_na0_type) ,INTENT(IN)    :: obj
+     ! 
+     INTEGER                            :: i
+     ! 
+     IF ( .NOT. obj%lwrite ) RETURN
+     ! 
+     CALL xml_NewElement(xp, TRIM(obj%tagname))
+     CALL xml_addAttribute(xp, 'rank', obj%rank)
+     CALL xml_addAttribute(xp, 'dims', obj%dims)
+     IF (obj%order_ispresent) CALL xml_addAttribute(xp, 'order', TRIM(obj%order) )
+     IF (obj%atom_ispresent) CALL xml_addAttribute(xp, 'atom', obj%atom )
+     IF (obj%spin_ispresent) CALL xml_addAttribute(xp, 'spin', obj%spin )
+     IF (obj%index_ispresent) CALL xml_addAttribute(xp, 'index', obj%index )
+       CALL xml_addNewLine(xp)
+        DO i = 1, obj%dims(2)
+           CALL xml_AddCharacters(xp, obj%ehubna0((i-1)*obj%dims(1)+1: i*obj%dims(1)), fmt ='s16')
+           CALL xml_addNewLine(xp)
+        END DO
+     CALL xml_EndElement(xp, TRIM(obj%tagname))
+   END SUBROUTINE qes_write_ehub_na0
+
+   SUBROUTINE qes_write_ehub_ne0( xp, obj )
+     !-----------------------------------------------------------------
+     IMPLICIT NONE
+     TYPE(xmlf_t)        ,INTENT(INOUT) :: xp
+     TYPE(ehub_ne0_type) ,INTENT(IN)    :: obj
+     ! 
+     INTEGER                            :: i
+     ! 
+     IF ( .NOT. obj%lwrite ) RETURN
+     ! 
+     CALL xml_NewElement(xp, TRIM(obj%tagname))
+     CALL xml_addAttribute(xp, 'rank', obj%rank)
+     CALL xml_addAttribute(xp, 'dims', obj%dims)
+     IF (obj%order_ispresent) CALL xml_addAttribute(xp, 'order', TRIM(obj%order) )
+     IF (obj%atom1_ispresent) CALL xml_addAttribute(xp, 'atom1', obj%atom1 )
+     IF (obj%atom2_ispresent) CALL xml_addAttribute(xp, 'atom2', obj%atom2 )
+     IF (obj%spin_ispresent) CALL xml_addAttribute(xp, 'spin', obj%spin )
+     IF (obj%nnc_ispresent) CALL xml_addAttribute(xp, 'nnc', obj%nnc )
+     IF (obj%index_ispresent) CALL xml_addAttribute(xp, 'index', obj%index )
+       CALL xml_addNewLine(xp)
+        DO i = 1, obj%dims(2)
+           CALL xml_AddCharacters(xp, obj%ehubne0((i-1)*obj%dims(1)+1:i*obj%dims(1)), fmt ='s16')
+           CALL xml_addNewLine(xp)
+        END DO
+     CALL xml_EndElement(xp, TRIM(obj%tagname))
+   END SUBROUTINE qes_write_ehub_ne0
+
+   ! by LSH WIY
+
   !
-END MODULE qes_write_module
\ No newline at end of file
+END MODULE qes_write_module
diff --git a/Modules/qexsd_copy.f90 b/Modules/qexsd_copy.f90
index 2ffa38240..aa62ea70e 100644
--- a/Modules/qexsd_copy.f90
+++ b/Modules/qexsd_copy.f90
@@ -313,7 +313,11 @@ CONTAINS
        lda_plus_U, lda_plus_U_kind, U_projection, Hubbard_n, Hubbard_l, Hubbard_lmax, Hubbard_occ, &
        Hubbard_n2, Hubbard_l2, Hubbard_n3, Hubbard_l3, backall, Hubbard_lmax_back, Hubbard_alpha_back, &
        Hubbard_U, Hubbard_U2, Hubbard_J0, Hubbard_alpha, Hubbard_beta, Hubbard_J, Hubbard_V, &
-       vdw_corr, dftd3_version, dftd3_3body, scal6, lon_rcut, vdw_isolated )
+       vdw_corr, dftd3_version, dftd3_3body, scal6, lon_rcut, vdw_isolated, &
+       ! by LSH
+       nat, lda_plus_v, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+       ehub_l_choice, ehub_lm_max, ehub_u, ehub_v )
+       ! by LSH
     !-------------------------------------------------------------------
     ! 
     USE qes_types_module, ONLY : dft_type
@@ -342,6 +346,18 @@ CONTAINS
     LOGICAL, INTENT(inout) :: backall(:)
     OPTIONAL    :: Hubbard_U2, Hubbard_n2, Hubbard_l2, Hubbard_lmax_back, Hubbard_alpha_back, &
                    Hubbard_l3
+    ! by LSH
+    INTEGER,  INTENT(in)                 :: nat
+    LOGICAL,  INTENT(out)                :: lda_plus_v, lacbn0
+    REAL(dp), INTENT(inout)              :: ehub_nn_distance
+    INTEGER,  INTENT(inout)              :: acbn0_type
+    INTEGER,  INTENT(inout)              :: ehub_nnnc
+    INTEGER,  INTENT(inout)              :: ehub_l_choice(:,:), ehub_lm_max
+    REAL(dp), ALLOCATABLE, INTENT(inout) :: ehub_u(:,:,:), ehub_v(:,:,:,:,:)
+
+    INTEGER                              :: i, j, k, m1, m2
+    REAL(dp), ALLOCATABLE                :: ehub_temp(:,:,:)
+    ! by LSH
     !
     CHARACTER(LEN=*), INTENT(out) :: vdw_corr
     LOGICAL,INTENT(inout)   :: dftd3_3body 
@@ -550,7 +566,49 @@ CONTAINS
        ! IT: What about Hubbard_l3?
        !  
     END IF
-
+      ! by LSH
+      lda_plus_v = dft_obj%ehub_ispresent
+      !
+      IF ( lda_plus_v ) THEN
+         !
+         lacbn0 = dft_obj%ehub%lacbn0
+         acbn0_type = dft_obj%ehub%acbn0_type
+         ehub_nn_distance = dft_obj%ehub%ehub_nn_distance
+         ehub_nnnc = dft_obj%ehub%ehub_nnnc
+         ehub_lm_max = dft_obj%ehub%ehub_lm_max
+         U_projection = TRIM(dft_obj%ehub%U_projection_type)
+         !
+         IF ( dft_obj%ehub%ehub_l_choice_ispresent ) THEN
+            DO ihub = 1, dft_obj%ehub%ndim_ehub_l_choice
+               ehub_l_choice(ihub,:) = dft_obj%ehub%ehub_l_choice(ihub)%ehublchoice
+            END DO
+         END IF
+         !
+         IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+            IF ( dft_obj%ehub%ehub_u_ispresent ) THEN
+               IF ( .NOT. ALLOCATED(ehub_u) ) ALLOCATE ( ehub_u(nat,ehub_lm_max,ehub_lm_max) )
+               DO ihub = 1, dft_obj%ehub%ndim_ehub_u
+                  ehub_u(ihub,:,:) = RESHAPE(dft_obj%ehub%ehub_u(ihub)%ehubu, [ehub_lm_max,ehub_lm_max])
+               END DO
+            END IF
+         ELSE
+            IF ( dft_obj%ehub%ehub_v_ispresent ) THEN
+               IF ( .NOT. ALLOCATED(ehub_v) ) ALLOCATE ( ehub_v(nat,nat,ehub_lm_max,ehub_lm_max,ehub_nnnc) )
+               ALLOCATE ( ehub_temp(nat*nat*ehub_nnnc,ehub_lm_max,ehub_lm_max) )
+               DO ihub = 1, dft_obj%ehub%ndim_ehub_v
+                  ehub_temp(ihub,:,:) = RESHAPE(dft_obj%ehub%ehub_v(ihub)%ehubv, [ehub_lm_max,ehub_lm_max])
+               END DO
+               DO m1 = 1, ehub_lm_max
+               DO m2 = 1, ehub_lm_max
+                  ehub_v(:,:,m1,m2,:) = RESHAPE(ehub_temp(:,m1,m2), [nat,nat,ehub_nnnc])
+               END DO
+               END DO
+               DEALLOCATE ( ehub_temp )
+            END IF
+         END IF
+         !
+      END IF
+      ! by LSH
       IF ( dft_obj%vdW_ispresent ) THEN 
          vdw_corr = TRIM( dft_obj%vdW%vdw_corr ) 
       ELSE
diff --git a/Modules/qexsd_init.f90 b/Modules/qexsd_init.f90
index c39b3afd9..c97015ef0 100644
--- a/Modules/qexsd_init.f90
+++ b/Modules/qexsd_init.f90
@@ -50,7 +50,10 @@ MODULE qexsd_init
             qexsd_init_dipole_info, qexsd_init_outputElectricField,   &
             qexsd_init_outputPBC, qexsd_init_gate_info, qexsd_init_hybrid, &
             qexsd_init_dftU, qexsd_init_vdw, qexsd_init_berryPhaseOutput, &
-            qexsd_init_rism3d, qexsd_init_rismlaue
+            ! by LSH
+            qexsd_init_rism3d, qexsd_init_rismlaue, &
+            qexsd_init_ehub
+            ! by LSH
   !
 CONTAINS
   !
@@ -367,15 +370,22 @@ CONTAINS
     END SUBROUTINE qexsd_init_basis_set
     !
     !
-    SUBROUTINE  qexsd_init_dft (obj, functional, hybrid_, vdW_, dftU_) 
+    ! by LSH
+    SUBROUTINE  qexsd_init_dft (obj, functional, hybrid_, vdW_, dftU_, ehub_) 
+    ! by LSH
        IMPLICIT NONE 
        TYPE (dft_type),INTENT(INOUT)           :: obj 
        CHARACTER(LEN=*),INTENT(IN)             :: functional
        TYPE(hybrid_type),OPTIONAL,INTENT(IN)   :: hybrid_ 
        TYPE(vdW_type),OPTIONAL,INTENT(IN)      :: vdW_
        TYPE(dftU_type),OPTIONAL,INTENT(IN)     :: dftU_ 
+       ! by LSH
+       TYPE(ehub_type),OPTIONAL,INTENT(IN)     :: ehub_
+       ! by LSH
        ! 
-       CALL qes_init(obj, 'dft', functional, hybrid_, dftU_, vdW_)
+       ! by LSH
+       CALL qes_init(obj, 'dft', functional, hybrid_, dftU_, ehub_, vdW_)
+       ! by LSH
     END SUBROUTINE qexsd_init_dft 
 
     !------------------------------------------------------------------------
@@ -859,7 +869,301 @@ CONTAINS
          !
              
       END SUBROUTINE qexsd_init_dftU 
-         ! 
+      !
+      ! by LSH WIY
+      SUBROUTINE qexsd_init_ehub(obj, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+                                 ehub_l_choice, ehub_lm_max, U_projection_type, ehub_u, ehub_v, &
+                                 ehub_na0, ehub_ne0, ehub_na0_nc, ehub_ne0_nc )
+         IMPLICIT NONE
+         TYPE(ehub_type),INTENT(INOUT)    :: obj
+         LOGICAL,INTENT(IN)               :: lacbn0
+         INTEGER,INTENT(IN)               :: acbn0_type
+         CHARACTER(LEN=*),INTENT(IN)      :: U_projection_type
+         REAL(DP),INTENT(IN)              :: ehub_nn_distance
+         INTEGER,INTENT(IN)               :: ehub_nnnc
+         INTEGER,INTENT(IN)               :: ehub_lm_max
+         INTEGER,OPTIONAL,INTENT(IN)      :: ehub_l_choice(:,:)
+         REAL(DP),OPTIONAL,INTENT(IN)     :: ehub_u(:,:,:), ehub_v(:,:,:,:,:)
+         REAL(DP),OPTIONAL,INTENT(IN)     :: ehub_na0(:,:,:,:), ehub_ne0(:,:,:,:,:,:)
+         COMPLEX(DP),OPTIONAL,INTENT(IN)  :: ehub_na0_nc(:,:,:,:), ehub_ne0_nc(:,:,:,:,:,:)
+         !
+         TYPE(ehub_l_choice_type), ALLOCATABLE :: ehub_l_choice_(:)
+         TYPE(ehub_u_type),        ALLOCATABLE :: ehub_u_(:)
+         TYPE(ehub_v_type),        ALLOCATABLE :: ehub_v_(:)
+         TYPE(ehub_na0_type),      ALLOCATABLE :: ehub_na0_(:), ehub_na0_nc_(:)
+         TYPE(ehub_ne0_type),      ALLOCATABLE :: ehub_ne0_(:), ehub_ne0_nc_(:)
+         !
+         IF ( PRESENT(ehub_l_choice) ) CALL init_ehub_l_choice(ehub_l_choice_)
+         IF ( PRESENT(ehub_u)        ) CALL init_ehub_u(ehub_u_)
+         IF ( PRESENT(ehub_v)        ) CALL init_ehub_v(ehub_v_)
+         IF ( PRESENT(ehub_na0)      ) THEN
+                                       CALL init_ehub_na0(ehub_na0_)
+         ELSE IF ( PRESENT(ehub_na0_nc)   ) THEN
+                                       CALL init_ehub_na0(ehub_na0_nc_)
+         END IF
+         IF ( PRESENT(ehub_ne0)      ) THEN
+                                       CALL init_ehub_ne0(ehub_ne0_)
+         ELSE IF ( PRESENT(ehub_ne0_nc)   ) THEN
+                                       CALL init_ehub_ne0(ehub_ne0_nc_)
+         END IF
+         !
+         CALL qes_init (obj, "ehub", lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+                        ehub_l_choice_, ehub_lm_max, U_projection_type, ehub_u_, ehub_v_, &
+                        ehub_na0_, ehub_ne0_, ehub_na0_nc_, ehub_ne0_nc_)
+         !
+         CALL reset_ehub_l_choice(ehub_l_choice_)
+         CALL reset_ehub_u(ehub_u_)
+         CALL reset_ehub_v(ehub_v_)
+         CALL reset_ehub_na0(ehub_na0_)
+         CALL reset_ehub_ne0(ehub_ne0_)
+         CALL reset_ehub_na0(ehub_na0_nc_)
+         CALL reset_ehub_ne0(ehub_ne0_nc_)
+      CONTAINS
+         !
+         SUBROUTINE init_ehub_l_choice(objs)
+            !
+            IMPLICIT NONE
+            !
+            TYPE(ehub_l_choice_type),ALLOCATABLE :: objs(:)
+            !
+            INTEGER                               :: i
+            INTEGER                               :: ntyp
+            !
+            ntyp = SIZE(ehub_l_choice,1)
+            !
+            ALLOCATE(objs(ntyp))
+            !
+            DO i = 1, ntyp
+               CALL qes_init(objs(i), "ehub_l_choice", ntyp, &
+                             ehub_l_choice = ehub_l_choice(i,1:6))
+            END DO ! i
+            !
+            RETURN
+            !
+         END SUBROUTINE init_ehub_l_choice
+         !
+         SUBROUTINE reset_ehub_l_choice(objs)
+            IMPLICIT NONE
+            ! 
+            TYPE(ehub_l_choice_type),ALLOCATABLE :: objs(:)
+            INTEGER                              :: i_
+
+            IF (.NOT. ALLOCATED(objs)) RETURN
+            DO i_ = 1, SIZE(objs)
+               CALL qes_reset(objs(i_))
+            END DO
+            DEALLOCATE (objs)
+         END SUBROUTINE reset_ehub_l_choice
+         !
+         SUBROUTINE init_ehub_u( objs )
+            !
+            IMPLICIT NONE
+            !
+            TYPE(ehub_u_type),ALLOCATABLE  :: objs(:)
+            !
+            INTEGER                        :: i 
+            INTEGER                        :: nat
+            !
+            nat   = SIZE(ehub_u,1)
+            !
+            ALLOCATE(objs(nat))
+            !
+            DO i = 1, nat
+               CALL qes_init(objs(i), TAGNAME = "ehub_u", ATOM = i, &
+                    ORDER = 'F', INDEX = i, ehub_u = ehub_u(i,:,:))
+            END DO ! i
+            !
+            RETURN
+            !
+         END SUBROUTINE init_ehub_u
+         !
+         SUBROUTINE reset_ehub_u( objs )
+            IMPLICIT NONE
+            ! 
+            TYPE(ehub_u_type),OPTIONAL :: objs(:)
+            INTEGER                    :: i_
+
+            IF ( .NOT. PRESENT (objs)) RETURN
+            DO i_ = 1, SIZE(objs)
+               CALL qes_reset(objs(i_))
+            END DO
+         END SUBROUTINE reset_ehub_u
+         !
+         SUBROUTINE init_ehub_v( objs )
+            !
+            IMPLICIT NONE
+            !
+            TYPE(ehub_v_type), ALLOCATABLE :: objs(:)
+            !
+            INTEGER                        :: n, i, j
+            INTEGER                        :: indx, nat, nnc
+            !
+            nat   = SIZE(ehub_v,1)
+            nnc   = SIZE(ehub_v,5)
+            !
+            ALLOCATE( objs(nat*nat*nnc) )
+            !
+            indx = 0
+            !
+            DO n = 1, nnc
+               DO i = 1, nat
+               DO j = 1, nat
+                  indx = indx + 1
+                  CALL qes_init(objs(indx), "ehub_v", ATOM1 = i, ATOM2 = j, NNC = n, &
+                       ORDER = 'F', INDEX = indx, ehub_v = ehub_v(i,j,:,:,n))
+               END DO ! j
+               END DO ! i
+            END DO ! n
+            !
+            RETURN
+            !
+         END SUBROUTINE init_ehub_v
+         !
+         SUBROUTINE reset_ehub_v( objs )
+            IMPLICIT NONE
+            ! 
+            TYPE(ehub_v_type),OPTIONAL :: objs(:)
+            INTEGER                    :: i_
+
+            IF ( .NOT. PRESENT (objs)) RETURN
+            DO i_ = 1, SIZE(objs)
+               CALL qes_reset(objs(i_))
+            END DO
+         END SUBROUTINE reset_ehub_v
+         !
+         SUBROUTINE init_ehub_na0( objs )
+            !
+            IMPLICIT NONE
+            !
+            TYPE(ehub_na0_type), ALLOCATABLE :: objs(:)
+            !
+            REAL(DP),            ALLOCATABLE :: Hubb_occ_aux(:,:)
+            INTEGER                          :: i, is, m1, m2
+            INTEGER                          :: indx, nat, nspin, lm_max
+            ! 
+            IF (PRESENT(ehub_na0_nc)) THEN
+               nat = SIZE(ehub_na0_nc,4) 
+               ALLOCATE (objs(nat))
+               lm_max = SIZE(ehub_na0_nc,1)
+               ALLOCATE (Hubb_occ_aux(2*lm_max, 2*lm_max))
+               DO i = 1, nat
+                  Hubb_occ_aux = 0.0_DP
+                  DO m1 = 1, lm_max
+                  DO m2 = 1, lm_max
+                     Hubb_occ_aux(m1,m2)=SQRT(DCONJG(ehub_na0_nc(m1,m2,1,i))*ehub_na0_nc(m1,m2,1,i))
+                     Hubb_occ_aux(m1,lm_max+m2)=SQRT(DCONJG(ehub_na0_nc(m1,m2,2,i))*ehub_na0_nc(m1,m2,2,i))
+                     Hubb_occ_aux(lm_max+m1,m2)=SQRT(DCONJG(ehub_na0_nc(m1,m2,3,i))*ehub_na0_nc(m1,m2,3,i))
+                     Hubb_occ_aux(lm_max+m1,lm_max+m2)=SQRT(DCONJG(ehub_na0_nc(m1,m2,4,i))*ehub_na0_nc(m1,m2,4,i))
+                  END DO
+                  END DO
+                  CALL qes_init(objs(indx), "ehub_na0_mod", ATOM = i, SPIN = 1, &
+                       ORDER = 'F', INDEX = i, ehub_na0 = Hubb_occ_aux)
+               END DO
+               DEALLOCATE (Hubb_occ_aux)
+               RETURN
+            ELSE IF (PRESENT(ehub_na0)) THEN
+               nspin = SIZE(ehub_na0,3)
+               nat   = SIZE(ehub_na0,4)
+               ALLOCATE( objs(nspin*nat) )
+               indx = 0
+               DO i = 1, nat
+                  DO is = 1, nspin
+                     indx = indx + 1
+                     CALL qes_init(objs(indx), "ehub_na0", ATOM = i, SPIN = is, &
+                        ORDER = 'F', INDEX = indx, ehub_na0 = ehub_na0(:,:,is,i))
+                  END DO
+               END DO
+            END IF
+            RETURN
+            !
+         END SUBROUTINE init_ehub_na0
+         !
+         SUBROUTINE reset_ehub_na0( objs )
+            IMPLICIT NONE
+            ! 
+            TYPE(ehub_na0_type),OPTIONAL :: objs(:)
+            INTEGER                      :: i_
+
+            IF ( .NOT. PRESENT (objs)) RETURN
+            DO i_ = 1, SIZE(objs)
+               CALL qes_reset(objs(i_))
+            END DO
+         END SUBROUTINE reset_ehub_na0
+         !
+         SUBROUTINE init_ehub_ne0( objs )
+            !
+            IMPLICIT NONE
+            !
+            TYPE(ehub_ne0_type), ALLOCATABLE :: objs(:)
+            !
+            REAL(DP),            ALLOCATABLE :: Hubb_occ_aux(:,:)
+            INTEGER                          :: n, i, j, is, m1, m2
+            INTEGER                          :: indx, nat, nspin, nnc, lm_max
+            !
+            IF (PRESENT(ehub_ne0_nc)) THEN
+               nat = SIZE(ehub_ne0_nc,4)
+               nnc = SIZE(ehub_ne0_nc,6)
+               ALLOCATE (objs(nat*nat*nnc))
+               indx = 0
+               lm_max = SIZE(ehub_ne0_nc,1)
+               ALLOCATE (Hubb_occ_aux(2*lm_max, 2*lm_max))
+               DO n = 1, nnc
+                  DO i = 1, nat
+                  DO j = 1, nat
+                     Hubb_occ_aux = 0.0_DP
+                     indx = indx + 1
+                     DO m1 = 1, lm_max
+                     DO m2 = 1, lm_max
+                        Hubb_occ_aux(m1,m2)=SQRT(DCONJG(ehub_ne0_nc(m1,m2,1,i,j,n))*ehub_ne0_nc(m1,m2,1,i,j,n))
+                        Hubb_occ_aux(m1,lm_max+m2)=SQRT(DCONJG(ehub_ne0_nc(m1,m2,2,i,j,n))*ehub_ne0_nc(m1,m2,2,i,j,n))
+                        Hubb_occ_aux(lm_max+m1,m2)=SQRT(DCONJG(ehub_ne0_nc(m1,m2,3,i,j,n))*ehub_ne0_nc(m1,m2,3,i,j,n))
+                        Hubb_occ_aux(lm_max+m1,lm_max+m2)=SQRT(DCONJG(ehub_ne0_nc(m1,m2,4,i,j,n))*ehub_ne0_nc(m1,m2,4,i,j,n))
+                     END DO
+                     END DO
+                     CALL qes_init(objs(indx), "ehub_ne0_mod", ATOM1 = i, ATOM2 = j, NNC = n, SPIN = 1, &
+                          ORDER = 'F', INDEX = indx, ehub_ne0 = Hubb_occ_aux)
+                  END DO
+                  END DO
+               END DO
+               DEALLOCATE (Hubb_occ_aux)
+               RETURN
+            ELSE IF (PRESENT(ehub_na0)) THEN
+               nspin = SIZE(ehub_ne0,3)
+               nat   = SIZE(ehub_ne0,4)
+               nnc   = SIZE(ehub_ne0,6)
+               ALLOCATE (objs(nspin*nat*nat*nnc))
+               indx = 0
+               DO n = 1, nnc
+                  DO i = 1, nat
+                  DO j = 1, nat
+                     DO is = 1, nspin
+                        indx = indx + 1
+                        CALL qes_init(objs(indx), "ehub_ne0", ATOM1 = i, ATOM2 = j, NNC = n, SPIN = is, &
+                             ORDER = 'F', INDEX = indx, ehub_ne0 = ehub_ne0(:,:,is,i,j,n))
+                     END DO ! is
+                  END DO ! j
+                  END DO ! i
+               END DO ! n
+            END IF
+            RETURN
+            !
+         END SUBROUTINE init_ehub_ne0
+         !
+         SUBROUTINE reset_ehub_ne0( objs )
+            IMPLICIT NONE
+            ! 
+            TYPE(ehub_ne0_type),OPTIONAL :: objs(:)
+            INTEGER                      :: i_
+
+            IF ( .NOT. PRESENT (objs) ) RETURN
+            DO i_ = 1, SIZE(objs)
+               CALL qes_reset(objs(i_))
+            END DO
+         END SUBROUTINE reset_ehub_ne0
+         !
+
+      END SUBROUTINE qexsd_init_ehub
+      ! by LSH WIY
          !
          SUBROUTINE qexsd_init_vdw(obj, non_local_term, vdw_corr, vdw_term, ts_thr, ts_isol,& 
                                    london_s6, london_c6, london_rcut, species, xdm_a1, xdm_a2,&
diff --git a/Modules/read_namelists.f90 b/Modules/read_namelists.f90
index cf33e1c76..68a556b28 100644
--- a/Modules/read_namelists.f90
+++ b/Modules/read_namelists.f90
@@ -235,6 +235,26 @@ MODULE read_namelists_module
        alpha_pen=0.0_DP
        dmft = .FALSE.
        dmft_prefix = prefix
+       ! by LSH
+       !
+       ! .. DFT + U + V
+       !
+       lda_plus_v = .FALSE.
+       lacbn0 = .FALSE.
+       ehub_u = 0.0_DP
+       ehub_v = 0.0_DP
+       ehub_nn_distance = 3.0_DP
+       ehub_l_choice = 0
+       remove_ehub_u = 1
+       remove_ehub_v = 1
+       ehub_conv_thr = 1.0D-8
+       ehub_mixing = 0.7_DP
+       acbn0_type = 1
+       read_ehub_ns_file = .FALSE.
+       read_ehub_uv_file = .FALSE.
+       ehub_pot_fix = .FALSE.
+       stop_acbn0 = .FALSE.
+       ! by LSH
        !
        ! ... EXX
        !
@@ -1021,6 +1041,23 @@ MODULE read_namelists_module
        CALL mp_bcast( eopreg,                 ionode_id, intra_image_comm )
        CALL mp_bcast( eamp,                   ionode_id, intra_image_comm )
        CALL mp_bcast( la2F,                   ionode_id, intra_image_comm )
+       ! by LSH
+       CALL mp_bcast( lda_plus_v,             ionode_id, intra_image_comm )
+       CALL mp_bcast( lacbn0,                 ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_u,                 ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_v,                 ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_nn_distance,       ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_l_choice,          ionode_id, intra_image_comm )
+       CALL mp_bcast( remove_ehub_u,          ionode_id, intra_image_comm )
+       CALL mp_bcast( remove_ehub_v,          ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_conv_thr,          ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_mixing,            ionode_id, intra_image_comm )
+       CALL mp_bcast( acbn0_type,             ionode_id, intra_image_comm )
+       CALL mp_bcast( read_ehub_ns_file,      ionode_id, intra_image_comm )
+       CALL mp_bcast( read_ehub_uv_file,      ionode_id, intra_image_comm )
+       CALL mp_bcast( ehub_pot_fix,           ionode_id, intra_image_comm )
+       CALL mp_bcast( stop_acbn0,             ionode_id, intra_image_comm )
+       ! by LSH
        !
        ! ... non collinear broadcast
        !
diff --git a/PP/src/pw2bgw.f90 b/PP/src/pw2bgw.f90
index b97a479b8..b5f001ad6 100644
--- a/PP/src/pw2bgw.f90
+++ b/PP/src/pw2bgw.f90
@@ -1672,6 +1672,9 @@ SUBROUTINE write_rhog ( output_file_name, real_or_complex, symm_type, &
   IF ( rhog_nvmin .NE. 0 .AND. rhog_nvmax .NE. 0 ) &
     CALL calc_rhog ( rhog_nvmin, rhog_nvmax )
     !
+    ! by LSH
+    !IF ( nspin==2 ) CALL rhoz_or_updw(rho, 'r_and_g', '->rhoz')
+    ! by LSH
     IF ( nspin==2 ) CALL rhoz_or_updw(rho, 'only_g', '->updw')
     !
   ALLOCATE ( g_g ( nd, ng_g ) )
diff --git a/PW/src/Makefile b/PW/src/Makefile
index b153b136d..19736fdaa 100644
--- a/PW/src/Makefile
+++ b/PW/src/Makefile
@@ -47,12 +47,14 @@ commutator_Vhubx_psi.o \
 compute_becsum.o \
 compute_deff.o \
 compute_dip.o \
+compute_eri.o \
 compute_rho.o \
 compute_qdipol.o \
 compute_qdipol_so.o \
 compute_ux.o \
 coset.o \
 Coul_cut_2D.o \
+crys.o \
 d_matrix.o \
 data_structure.o \
 divide_class.o \
@@ -93,6 +95,7 @@ force_cc.o \
 force_corr.o \
 force_ew.o \
 force_hub.o \
+force_hub_v.o \
 force_lc.o \
 force_us.o \
 forces.o \
@@ -116,7 +119,9 @@ h_psi_meta.o \
 hinit0.o \
 hinit1.o \
 hubbard.o \
+hubbard_nns.o \
 init_ns.o \
+init_ns_v.o \
 init_q_aeps.o \
 init_run.o \
 init_us_2.o \
@@ -132,6 +137,7 @@ start_k.o \
 kpoint_grid.o \
 lchk_tauxk.o \
 ldaU.o \
+ldaV.o \
 make_pointlists.o \
 manypw.o \
 martyna_tuckerman.o \
@@ -141,15 +147,19 @@ move_ions.o \
 multable.o \
 n_plane_waves.o \
 new_ns.o \
+new_ns_v.o \
 new_nsb.o \
 new_nsg.o \
 new_occ.o \
 ns_adj.o \
 non_scf.o \
 offset_atom_wfc.o \
+offset_atom_wfc_v.o \
 openfil.o \
 orthoatwfc.o \
+orthoatwfc_v.o \
 output_tau.o \
+pao_3g.o \
 para.o \
 paw_exx.o \
 paw_init.o \
@@ -171,6 +181,7 @@ plugin_ext_forces.o \
 plugin_int_forces.o \
 plugin_read_input.o \
 plus_u_full.o \
+plus_v_nc_v.o \
 potinit.o \
 print_clock_pw.o \
 print_ks_energies.o \
@@ -218,6 +229,7 @@ stres_ewa.o \
 stres_gradcorr.o \
 stres_har.o \
 stres_hub.o \
+stres_hub_v.o \
 stres_knl.o \
 stres_loc.o \
 stres_us.o \
@@ -241,9 +253,11 @@ update_pot.o \
 us_exx.o \
 usnldiag.o \
 v_of_rho.o \
+v_hubbard_v.o \
 vcsmd.o \
 vcsubs.o \
 vhpsi.o \
+vhpsi_v.o \
 vloc_psi.o \
 utils.o \
 xdm_dispersion.o \
diff --git a/PW/src/allocate_wfc.f90 b/PW/src/allocate_wfc.f90
index 4a50b8bc4..13440cd60 100644
--- a/PW/src/allocate_wfc.f90
+++ b/PW/src/allocate_wfc.f90
@@ -18,6 +18,9 @@ SUBROUTINE allocate_wfc()
   USE basis,               ONLY : natomwfc, swfcatom
   USE fixed_occ,           ONLY : one_atom_occupations
   USE ldaU,                ONLY : wfcU, nwfcU, lda_plus_u, Hubbard_projectors
+  ! by LSH
+  USE ldaV,                ONLY : wfcv, nwfcv, lda_plus_v
+  ! by LSH
   USE noncollin_module,    ONLY : npol
   USE wavefunctions,       ONLY : evc
   USE wannier_new,         ONLY : use_wannier
@@ -33,6 +36,10 @@ SUBROUTINE allocate_wfc()
      ALLOCATE( swfcatom(npwx*npol,natomwfc) )
   IF ( lda_plus_u .AND. (Hubbard_projectors.NE.'pseudo') ) &
        ALLOCATE( wfcU(npwx*npol,nwfcU) )
+  ! by LSH
+  IF ( lda_plus_v .AND. (Hubbard_projectors.NE.'pseudo') ) &
+     ALLOCATE ( wfcv(npwx*npol,nwfcv) )
+  ! by LSH
   !
   RETURN
   !
diff --git a/PW/src/c_bands.f90 b/PW/src/c_bands.f90
index ed497c941..6f43d243d 100644
--- a/PW/src/c_bands.f90
+++ b/PW/src/c_bands.f90
@@ -16,7 +16,10 @@ SUBROUTINE c_bands( iter )
   !
   USE kinds,                ONLY : DP
   USE io_global,            ONLY : stdout
-  USE io_files,             ONLY : iunhub, iunwfc, nwordwfc, nwordwfcU
+  ! by LSH
+  USE io_files,             ONLY : iunhub, iunhubv, iunwfc, &
+                                   nwordwfc, nwordwfcU, nwordwfcv
+  ! by LSH
   USE buffers,              ONLY : get_buffer, save_buffer, close_buffer
   USE klist,                ONLY : nkstot, nks, ngk, igk_k, igk_k_d, xk
   USE uspp,                 ONLY : vkb, nkb
@@ -24,6 +27,9 @@ SUBROUTINE c_bands( iter )
   USE wvfct,                ONLY : et, nbnd, npwx, current_k
   USE control_flags,        ONLY : ethr, isolve, restart, use_gpu, iverbosity
   USE ldaU,                 ONLY : lda_plus_u, lda_plus_u_kind, Hubbard_projectors, wfcU
+  ! by LSH
+  USE ldaV,                 ONLY : lda_plus_v, wfcv
+  ! by LSH
   USE lsda_mod,             ONLY : current_spin, lsda, isk
   USE wavefunctions,        ONLY : evc
   USE bp,                   ONLY : lelfield
@@ -124,6 +130,13 @@ SUBROUTINE c_bands( iter )
      !
      IF ( nks > 1 .AND. lda_plus_u .AND. (Hubbard_projectors .NE. 'pseudo') ) &
           CALL get_buffer ( wfcU, nwordwfcU, iunhub, ik )
+     ! by LSH
+     !
+     ! ... Needed for DFT+U+V
+     !
+     IF ( nks > 1 .AND. lda_plus_v .AND. (Hubbard_projectors .NE. 'pseudo') ) &
+          CALL get_buffer ( wfcv, nwordwfcv, iunhubv, ik )
+     ! by LSH
      !
      ! ... diagonalization of bands for k-point ik
      ! ... (skip only in charge self-consistent DFT+DMFT calculations)
@@ -1175,7 +1188,10 @@ SUBROUTINE c_bands_nscf( )
   !
   USE kinds,                ONLY : DP
   USE io_global,            ONLY : stdout
-  USE io_files,             ONLY : iunhub, iunwfc, nwordwfc, nwordwfcU
+  ! by LSH
+  USE io_files,             ONLY : iunhub, iunhubv, iunwfc, &
+                                   nwordwfc, nwordwfcU, nwordwfcv
+  ! by LSH
   USE buffers,              ONLY : get_buffer, save_buffer, close_buffer
   USE basis,                ONLY : starting_wfc
   USE klist,                ONLY : nkstot, nks, xk, ngk, igk_k, igk_k_d
@@ -1184,6 +1200,9 @@ SUBROUTINE c_bands_nscf( )
   USE wvfct,                ONLY : et, nbnd, npwx, current_k
   USE control_flags,        ONLY : ethr, restart, isolve, io_level, iverbosity, use_gpu
   USE ldaU,                 ONLY : lda_plus_u, lda_plus_u_kind, Hubbard_projectors, wfcU
+  ! by LSH
+  USE ldaV,                 ONLY : lda_plus_v, wfcv
+  ! by LSH
   USE lsda_mod,             ONLY : current_spin, lsda, isk
   USE wavefunctions,        ONLY : evc
   USE mp_pools,             ONLY : npool, kunit, inter_pool_comm
@@ -1257,6 +1276,13 @@ SUBROUTINE c_bands_nscf( )
      !
      IF ( nks > 1 .AND. lda_plus_u .AND. (Hubbard_projectors .NE. 'pseudo') ) &
           CALL get_buffer( wfcU, nwordwfcU, iunhub, ik )
+     ! by LSH
+     !
+     ! ... Needed for DFT+U+V
+     !
+     IF ( nks > 1 .AND. lda_plus_v .AND. (Hubbard_projectors .NE. 'pseudo') ) &
+          CALL get_buffer( wfcv, nwordwfcv, iunhubv, ik )
+     ! by LSH
      !
      ! ... calculate starting  wavefunctions
      !
diff --git a/PW/src/clean_pw.f90 b/PW/src/clean_pw.f90
index 9730f30a0..5dc882645 100644
--- a/PW/src/clean_pw.f90
+++ b/PW/src/clean_pw.f90
@@ -42,6 +42,9 @@ SUBROUTINE clean_pw( lflag )
   USE uspp_param,           ONLY : upf
   USE m_gth,                ONLY : deallocate_gth
   USE ldaU,                 ONLY : deallocate_hubbard
+  ! by LSH
+  USE ldaV,                 ONLY : deallocate_ldaV
+  ! by LSH
   USE extfield,             ONLY : forcefield, forcegate
   USE fft_base,             ONLY : dfftp, dffts  
   USE fft_base,             ONLY : pstickdealloc
@@ -124,6 +127,10 @@ SUBROUTINE clean_pw( lflag )
   !
   CALL deallocate_hubbard( lflag )
   !
+  ! by LSH
+  CALL deallocate_ldaV( lflag )
+  ! by LSH
+  !
   IF ( ALLOCATED( f_inp ) .AND. lflag )  DEALLOCATE( f_inp )
   !
   ! ... arrays in gvect module
diff --git a/PW/src/close_files.f90 b/PW/src/close_files.f90
index 8f39c5c3a..c4458c370 100644
--- a/PW/src/close_files.f90
+++ b/PW/src/close_files.f90
@@ -11,11 +11,16 @@ SUBROUTINE close_files( lflag )
   !! Close all files and synchronize processes for a new scf calculation.
   !
   USE ldaU,          ONLY: lda_plus_u, Hubbard_projectors
+  ! by LSH
+  USE ldaV,          ONLY: lda_plus_v
+  ! by LSH
   USE control_flags, ONLY: io_level
   USE fixed_occ,     ONLY: one_atom_occupations
+  ! by LSH
   USE io_files,      ONLY: prefix, iunwfc, iunsat, &
                            iunhub, iunefield, iunefieldm, iunefieldp, &
-                           iunwfc_exx
+                           iunwfc_exx, iunhubv
+  ! by LSH
   USE buffers,       ONLY: close_buffer
   USE mp_images,     ONLY: intra_image_comm
   USE mp,            ONLY: mp_barrier
@@ -63,6 +68,14 @@ SUBROUTINE close_files( lflag )
   IF ( use_wannier .OR. one_atom_occupations ) THEN
      CALL close_buffer( iunsat, close_option )
   END IF
+  ! by LSH WIY
+  !
+  ! ... iunhubv only for wavefcts having an associated Hubbard U & V
+  !
+  IF ( lda_plus_v .AND. (Hubbard_projectors /= 'pseudo') ) THEN
+     CALL close_buffer( iunhubv, close_option )
+  END IF
+  ! by LSH WIY
   !
   ! ... close unit for electric field if needed
   !
diff --git a/PW/src/compute_eri.f90 b/PW/src/compute_eri.f90
new file mode 100644
index 000000000..ff84316f2
--- /dev/null
+++ b/PW/src/compute_eri.f90
@@ -0,0 +1,230 @@
+      MODULE ERI
+
+      USE ISO_C_BINDING, ONLY : C_INT, C_DOUBLE
+
+      INTERFACE
+         REAL(C_DOUBLE) FUNCTION coulomb_repulsion               &
+                                (xa,ya,za,norma,la,ma,na,alphaa, &
+                                 xb,yb,zb,normb,lb,mb,nb,alphab, &
+                                 xc,yc,zc,normc,lc,mc,nc,alphac, &
+                                 xd,yd,zd,normd,ld,md,nd,alphad) &
+                                 BIND(C, name="coulomb_repulsion")
+
+            IMPORT
+
+            IMPLICIT NONE
+
+            REAL(C_DOUBLE), VALUE :: xa, ya, za, norma, alphaa
+            REAL(C_DOUBLE), VALUE :: xb, yb, zb, normb, alphab
+            REAL(C_DOUBLE), VALUE :: xc, yc, zc, normc, alphac
+            REAL(C_DOUBLE), VALUE :: xd, yd, zd, normd, alphad
+            INTEGER(C_INT), VALUE :: la, ma, na
+            INTEGER(C_INT), VALUE :: lb, mb, nb
+            INTEGER(C_INT), VALUE :: lc, mc, nc
+            INTEGER(C_INT), VALUE :: ld, md, nd
+
+         END FUNCTION coulomb_repulsion
+      END INTERFACE
+
+      END MODULE ERI
+
+      FUNCTION compute_ERI(lm1, lm2, lm3, lm4, x1, x2, x3, x4, c1, c2, c3, c4)
+
+      USE ERI
+
+      IMPLICIT NONE
+
+      INTEGER,  PARAMETER  :: DP = selected_real_kind(14,200)
+
+      REAL(DP), INTENT(IN) :: x1(3), x2(3), x3(3), x4(3)
+      REAL(DP), INTENT(IN) :: c1(6), c2(6), c3(6), c4(6)
+
+      INTEGER,  INTENT(IN) :: lm1, lm2, lm3, lm4
+
+      REAL(DP)             :: compute_ERI
+
+      REAL(DP)             :: norm1, norm2, norm3, norm4
+      REAL(DP)             :: norm1_tmp, norm2_tmp, &
+                              norm3_tmp, norm4_tmp
+
+      INTEGER              :: l1(3), l2(3), l3(3), l4(3)
+      INTEGER              :: m1(3), m2(3), m3(3), m4(3)
+      INTEGER              :: n1(3), n2(3), n3(3), n4(3)
+
+      INTEGER              :: ia1, ia2, ia3, ia4
+      INTEGER              :: ilmn1, ilmn2, ilmn3, ilmn4
+
+      compute_ERI = 0.0_DP
+      CALL exponents_and_normalization_constants(lm1, l1, m1, n1, norm1_tmp)
+      CALL exponents_and_normalization_constants(lm2, l2, m2, n2, norm2_tmp)
+      CALL exponents_and_normalization_constants(lm3, l3, m3, n3, norm3_tmp)
+      CALL exponents_and_normalization_constants(lm4, l4, m4, n4, norm4_tmp)
+
+      DO ia1 = 1, 3
+      DO ilmn1 = 1, 3
+
+         ! normalization constant of phi_1
+         IF (lm1 /= 5 .AND. lm1 /= 8) THEN
+            IF (ilmn1 > 1) CYCLE
+            norm1 = norm1_tmp * c1(ia1)
+         ELSEIF (lm1 == 5) THEN
+            IF (ilmn1 == 1) THEN
+               norm1 = norm1_tmp * c1(ia1) *  2.0_DP
+            ELSE
+               norm1 = norm1_tmp * c1(ia1) * -1.0_DP
+            ENDIF
+         ELSEIF (lm1 == 8) THEN
+            IF (ilmn1 == 1) THEN
+               norm1 = norm1_tmp * c1(ia1) *  1.0_DP
+            ELSEIF (ilmn1 == 2) THEN
+               norm1 = norm1_tmp * c1(ia1) * -1.0_DP
+            ELSE
+               CYCLE
+            ENDIF
+         ENDIF
+
+         DO ia2 = 1, 3
+         DO ilmn2 = 1, 3
+
+            ! normalization constant of phi_2
+            IF (lm2 /= 5 .AND. lm2 /= 8) THEN
+               IF (ilmn2 > 1) CYCLE
+               norm2 = norm2_tmp * c2(ia2)
+            ELSEIF (lm2 == 5) THEN
+               IF (ilmn2 == 1) THEN
+                  norm2 = norm2_tmp * c2(ia2) *  2.0_DP
+               ELSE
+                  norm2 = norm2_tmp * c2(ia2) * -1.0_DP
+               ENDIF
+            ELSEIF (lm2 == 8) THEN
+               IF (ilmn2 == 1) THEN
+                  norm2 = norm2_tmp * c2(ia2) *  1.0_DP
+               ELSEIF (ilmn2 == 2) THEN
+                  norm2 = norm2_tmp * c2(ia2) * -1.0_DP
+               ELSE
+                  CYCLE
+               ENDIF
+            ENDIF
+
+            ! normalization constant of phi_3
+            DO ia3 = 1, 3
+            DO ilmn3 = 1, 3
+
+               IF (lm3 /= 5 .AND. lm3 /= 8) THEN
+                  IF (ilmn3 > 1) CYCLE
+                  norm3 = norm3_tmp * c3(ia3)
+               ELSEIF (lm3 == 5) THEN
+                  IF (ilmn3 == 1) THEN
+                     norm3 = norm3_tmp * c3(ia3) *  2.0_DP
+                  ELSE
+                     norm3 = norm3_tmp * c3(ia3) * -1.0_DP
+                  ENDIF
+               ELSEIF (lm3 == 8) THEN
+                  IF (ilmn3 == 1) THEN
+                     norm3 = norm3_tmp * c3(ia3) *  1.0_DP
+                  ELSEIF (ilmn3 == 2) THEN
+                     norm3 = norm3_tmp * c3(ia3) * -1.0_DP
+                  ELSE
+                     CYCLE
+                  ENDIF
+               ENDIF
+
+               ! normalization constant of phi_4
+               DO ia4 = 1, 3
+               DO ilmn4 = 1, 3
+
+                  IF (lm4 /= 5 .AND. lm4 /= 8) THEN
+                     IF (ilmn4 > 1) CYCLE
+                     norm4 = norm4_tmp * c4(ia4)
+                  ELSEIF (lm4 == 5) THEN
+                     IF (ilmn4 == 1) THEN
+                        norm4 = norm4_tmp * c4(ia4) *  2.0_DP
+                     ELSE
+                        norm4 = norm4_tmp * c4(ia4) * -1.0_DP
+                     ENDIF
+                  ELSEIF (lm4 == 8) THEN
+                     IF (ilmn4 == 1) THEN
+                        norm4 = norm4_tmp * c4(ia4) *  1.0_DP
+                     ELSEIF (ilmn4 == 2) THEN
+                        norm4 = norm4_tmp * c4(ia4) * -1.0_DP
+                     ELSE
+                        CYCLE
+                     ENDIF
+                  ENDIF
+
+                  compute_ERI = compute_ERI + coulomb_repulsion(            &
+                                x1(1), x1(2), x1(3), norm1,                 &
+                                l1(ilmn1), m1(ilmn1), n1(ilmn1), c1(ia1+3), &
+                                x2(1), x2(2), x2(3), norm2,                 &
+                                l2(ilmn2), m2(ilmn2), n2(ilmn2), c2(ia2+3), &
+                                x3(1), x3(2), x3(3), norm3,                 &
+                                l3(ilmn3), m3(ilmn3), n3(ilmn3), c3(ia3+3), &
+                                x4(1), x4(2), x4(3), norm4,                 &
+                                l4(ilmn4), m4(ilmn4), n4(ilmn4), c4(ia4+3))
+
+               ENDDO
+               ENDDO
+            ENDDO
+            ENDDO
+         ENDDO
+         ENDDO
+      ENDDO
+      ENDDO
+
+      ! Hartree to Rydberg
+      compute_ERI = 2.0_DP * compute_ERI
+
+      RETURN
+
+      END FUNCTION compute_ERI
+
+      SUBROUTINE exponents_and_normalization_constants(lm, l, m, n, norm)
+
+      IMPLICIT NONE
+
+      INTEGER,  PARAMETER  :: DP = selected_real_kind(14,200)
+
+      REAL(DP), PARAMETER  :: PI = 3.14159265358979323846_DP
+
+      INTEGER, INTENT(IN)  :: lm
+      INTEGER, INTENT(OUT) :: l(3), m(3), n(3)
+      REAL(DP),INTENT(OUT) :: norm
+
+
+      l(:) = 0 ; m(:) = 0 ; n(:) = 0
+
+      ! NOTE: (2*0+1)!! = 1, (2*1+1)!! = 3, (2*2+1)!! = 15
+      SELECT CASE(lm)
+         CASE(1)
+            l(1) = 0 ; m(1) = 0 ; n(1) = 0 ! 1
+            norm  = 0.25_DP * sqrt( 1.0_DP/(PI*0.25_DP))
+         CASE(2)
+            l(1) = 0 ; m(1) = 0 ; n(1) = 1 ! z
+            norm  = 0.25_DP * sqrt( 3.0_DP/(PI*0.25_DP))
+         CASE(3)
+            l(1) = 1 ; m(1) = 0 ; n(1) = 0 ! x
+            norm  = 0.25_DP * sqrt( 3.0_DP/(PI*0.25_DP))
+         CASE(4)
+            l(1) = 0 ; m(1) = 1 ; n(1) = 0 ! y
+            norm  = 0.25_DP * sqrt( 3.0_DP/(PI*0.25_DP))
+         CASE(5)
+            l(1) = 0 ; m(1) = 0 ; n(1) = 2 ! 2z^2 - x^2 - y^2
+            l(2) = 2 ; m(2) = 0 ; n(2) = 0 ! 2z^2 - x^2 - y^2
+            l(3) = 0 ; m(3) = 2 ; n(3) = 0 ! 2z^2 - x^2 - y^2
+            norm  = 0.25_DP * sqrt(15.0_DP/(PI*3.00_DP))
+         CASE(6)
+            l(1) = 1 ; m(1) = 0 ; n(1) = 1 ! xz
+            norm  = 0.25_DP * sqrt(15.0_DP/(PI*0.25_DP))
+         CASE(7)
+            l(1) = 0 ; m(1) = 1 ; n(1) = 1 ! yz
+            norm  = 0.25_DP * sqrt(15.0_DP/(PI*0.25_DP))
+         CASE(8)
+            l(1) = 2 ; m(1) = 0 ; n(1) = 0 ! x^2 - y^2
+            l(2) = 0 ; m(2) = 2 ; n(2) = 0 ! x^2 - y^2
+            norm  = 0.25_DP * sqrt(15.0_DP/(PI*1.00_DP))
+         CASE(9)
+            l(1) = 1 ; m(1) = 1 ; n(1) = 0 ! xy
+            norm  = 0.25_DP * sqrt(15.0_DP/(PI*0.25_DP))
+      END SELECT
+
+      END SUBROUTINE exponents_and_normalization_constants
diff --git a/PW/src/crys.c b/PW/src/crys.c
new file mode 100644
index 000000000..159ec5f00
--- /dev/null
+++ b/PW/src/crys.c
@@ -0,0 +1,1549 @@
+/* crys.c Implementation of Rys quadrature routines in C
+ *
+ * Two electron integral evaluation using Rys polynomials.
+ *
+ * References:
+ * ABD: Augspurger, Bernholdt, and Dykstra. 'Concise, Open-Ended
+ *      Implementation of Rys Polynomial Evaluation of Two-Electron
+ *      Integrals.' J. Comp. Chem. 11 (8), 972-977 (1990).
+ *
+ * Special thanks to Cliff Dykstra for providing a working version of his
+ *  Fortran code for this problem.
+ *
+ * Most of this taken from ABD but polynomial stuff still from GAMESS.
+ *
+ This program is part of the PyQuante quantum chemistry program suite.
+
+ Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 
+
+ PyQuante version 1.2 and later is covered by the modified BSD
+ license. Please see the file LICENSE that is part of this
+ distribution. 
+ *
+ */
+
+#include "crys.h"
+#include <math.h>
+#include <stdio.h>
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+static double contr_coulomb(int lena,double *aexps,double *acoefs,double *anorms,
+		     double xa,double ya,double za,int la,int ma,int na,
+		     int lenb,double *bexps,double *bcoefs,double *bnorms,
+		     double xb,double yb,double zb,int lb,int mb,int nb,
+		     int lenc,double *cexps,double *ccoefs,double *cnorms,
+		     double xc,double yc,double zc,int lc,int mc,int nc,
+		     int lend,double *dexps,double *dcoefs,double *dnorms,
+		     double xd,double yd,double zd,int ld,int md,int nd){
+  double val = 0.;
+  int i,j,k,l;
+  for (i=0; i<lena; i++)
+    for (j=0; j<lenb; j++)
+      for (k=0; k<lenc; k++)
+	for (l=0; l<lend; l++)
+	  val += acoefs[i]*bcoefs[j]*ccoefs[k]*dcoefs[l]
+	    *coulomb_repulsion(xa,ya,za,anorms[i],la,ma,na,aexps[i],
+			       xb,yb,zb,bnorms[j],lb,mb,nb,bexps[j],
+			       xc,yc,zc,cnorms[k],lc,mc,nc,cexps[k],
+			       xd,yd,zd,dnorms[l],ld,md,nd,dexps[l]);
+  return val;
+}
+    
+double coulomb_repulsion(double xa,double ya,double za,double norma,
+			 int la,int ma,int na,double alphaa,
+			 double xb,double yb,double zb,double normb,
+			 int lb,int mb,int nb,double alphab,
+			 double xc,double yc,double zc,double normc,
+			 int lc,int mc,int nc,double alphac,
+			 double xd,double yd,double zd,double normd,
+			 int ld,int md,int nd,double alphad){
+
+  int norder,i;
+  double A,B,xp,yp,zp,xq,yq,zq,rpq2,X,rho,sum,t,Ix,Iy,Iz;
+  
+  norder = (la+ma+na+lb+nb+mb+lc+mc+nc+ld+md+nd)/2 + 1;
+  A = alphaa+alphab; 
+  B = alphac+alphad;
+  rho = A*B/(A+B);
+
+  xp = product_center_1D(alphaa,xa,alphab,xb);
+  yp = product_center_1D(alphaa,ya,alphab,yb);
+  zp = product_center_1D(alphaa,za,alphab,zb);
+  xq = product_center_1D(alphac,xc,alphad,xd);
+  yq = product_center_1D(alphac,yc,alphad,yd);
+  zq = product_center_1D(alphac,zc,alphad,zd);
+  rpq2 = dist2(xp,yp,zp,xq,yq,zq);
+
+  X = rpq2*rho;
+
+  Roots(norder,X); /* Puts currect roots/weights in "common" */
+
+  sum = 0.;
+  for (i=0; i<norder; i++){
+    t = roots[i];
+    Ix = Int1d(t,la,lb,lc,ld,xa,xb,xc,xd,
+	       alphaa,alphab,alphac,alphad);
+    Iy = Int1d(t,ma,mb,mc,md,ya,yb,yc,yd,
+	       alphaa,alphab,alphac,alphad);
+    Iz = Int1d(t,na,nb,nc,nd,za,zb,zc,zd,
+	       alphaa,alphab,alphac,alphad);
+    sum = sum + Ix*Iy*Iz*weights[i]; /* ABD eq 5 & 9 */
+  }
+  return 2*sqrt(rho/M_PI)*norma*normb*normc*normd*sum; /* ABD eq 5 & 9 */
+}
+
+static void Roots(int n, double X){
+  if (n <= 3)
+    Root123(n,X);
+  else if (n==4) 
+    Root4(X);
+  else if (n==5)
+    Root5(X);
+  else
+    Root6(n,X);
+  return;
+}
+
+
+static void Root123(int n, double X){
+
+  double R12, PIE4, R22, W22, R13, R23, W23, R33, W33;
+  double RT1=0,RT2=0,RT3=0,WW1=0,WW2=0,WW3=0;
+  double F1,F2,E,T1,T2,T3,A1,A2,Y;
+
+  R12 = 2.75255128608411E-01;
+  PIE4 = 7.85398163397448E-01;
+  R22 =  2.72474487139158E+00;
+  W22 = 9.17517095361369E-02;
+  R13 = 1.90163509193487E-01;
+  R23 = 1.78449274854325E+00;
+  W23 = 1.77231492083829E-01;
+  R33 = 5.52534374226326E+00;
+  W33 = 5.11156880411248E-03;
+    
+  if (X < 3.e-7){
+    if (n == 1){
+      RT1 = 0.5E+00 -X/5.0E+00;
+      WW1 = 1.0E+00 -X/3.0E+00;
+    } else if (n == 2) {
+      RT1 = 1.30693606237085E-01 -2.90430236082028E-02 *X;
+      RT2 = 2.86930639376291E+00 -6.37623643058102E-01 *X;
+      WW1 = 6.52145154862545E-01 -1.22713621927067E-01 *X;
+      WW2 = 3.47854845137453E-01 -2.10619711404725E-01 *X;
+    } else if (n == 3) {
+      RT1 = 6.03769246832797E-02 -9.28875764357368E-03 *X;
+      RT2 = 7.76823355931043E-01 -1.19511285527878E-01 *X;
+      RT3 = 6.66279971938567E+00 -1.02504611068957E+00 *X;
+      WW1 = 4.67913934572691E-01 -5.64876917232519E-02 *X;
+      WW2 = 3.60761573048137E-01 -1.49077186455208E-01 *X;
+      WW3 = 1.71324492379169E-01 -1.27768455150979E-01 *X;
+    }
+  } else if (X < 1.) {
+    if (n == 1){
+      F1 = ((((((((-8.36313918003957E-08*X+1.21222603512827E-06 )*X-
+		  1.15662609053481E-05 )*X+9.25197374512647E-05 )*X-
+		6.40994113129432E-04 )*X+3.78787044215009E-03 )*X-
+	      1.85185172458485E-02 )*X+7.14285713298222E-02 )*X-
+	    1.99999999997023E-01 )*X+3.33333333333318E-01;
+      WW1 = (X+X)*F1+exp(-X);
+      RT1 = F1/(WW1-F1);
+    } else if (n == 2) {
+      F1 = ((((((((-8.36313918003957E-08*X+1.21222603512827E-06 )*X-
+		  1.15662609053481E-05 )*X+9.25197374512647E-05 )*X-
+		6.40994113129432E-04 )*X+3.78787044215009E-03 )*X-
+	      1.85185172458485E-02 )*X+7.14285713298222E-02 )*X-
+	    1.99999999997023E-01 )*X+3.33333333333318E-01;
+      WW1 = (X+X)*F1+exp(-X);
+      RT1 = (((((((-2.35234358048491E-09*X+2.49173650389842E-08)*X-
+		  4.558315364581E-08)*X-2.447252174587E-06)*X+
+		4.743292959463E-05)*X-5.33184749432408E-04 )*X+
+	      4.44654947116579E-03 )*X-2.90430236084697E-02 )*X+\
+	1.30693606237085E-01;
+      RT2 = (((((((-2.47404902329170E-08*X+2.36809910635906E-07)*X+
+		  1.835367736310E-06)*X-2.066168802076E-05)*X-
+		1.345693393936E-04)*X-5.88154362858038E-05 )*X+
+	      5.32735082098139E-02 )*X-6.37623643056745E-01 )*X+\
+	2.86930639376289E+00;
+      WW2 = ((F1-WW1)*RT1+F1)*(1.0E+00+RT2)/(RT2-RT1);
+      WW1 = WW1-WW2;
+    } else if (n==3){
+      RT1 = ((((((-5.10186691538870E-10*X+2.40134415703450E-08)*X-
+                 5.01081057744427E-07 )*X+7.58291285499256E-06 )*X-
+               9.55085533670919E-05 )*X+1.02893039315878E-03 )*X-
+             9.28875764374337E-03 )*X+6.03769246832810E-02;
+      RT2 = ((((((-1.29646524960555E-08*X+7.74602292865683E-08)*X+
+		 1.56022811158727E-06 )*X-1.58051990661661E-05 )*X-
+	       3.30447806384059E-04 )*X+9.74266885190267E-03 )*X-
+	     1.19511285526388E-01 )*X+7.76823355931033E-01;
+      RT3 = ((((((-9.28536484109606E-09*X-3.02786290067014E-07)*X-
+		 2.50734477064200E-06 )*X-7.32728109752881E-06 )*X+
+	       2.44217481700129E-04 )*X+4.94758452357327E-02 )*X-
+	     1.02504611065774E+00 )*X+6.66279971938553E+00;
+      F2 = ((((((((-7.60911486098850E-08*X+1.09552870123182E-06 )*X-
+		  1.03463270693454E-05 )*X+8.16324851790106E-05 )*X-
+		5.55526624875562E-04 )*X+3.20512054753924E-03 )*X-
+	      1.51515139838540E-02 )*X+5.55555554649585E-02 )*X-
+	    1.42857142854412E-01 )*X+1.99999999999986E-01;
+      E = exp(-X);
+      F1 = ((X+X)*F2+E)/3.0E+00;
+      WW1 = (X+X)*F1+E;
+      T1 = RT1/(RT1+1.0E+00);
+      T2 = RT2/(RT2+1.0E+00);
+      T3 = RT3/(RT3+1.0E+00);
+      A2 = F2-T1*F1;
+      A1 = F1-T1*WW1;
+      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1));
+      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1));
+      WW1 = WW1-WW2-WW3;
+    }
+  } else if (X < 3.) {
+    Y = X-2.0E+00;
+    if (n == 1) {
+      F1 = ((((((((((-1.61702782425558E-10*Y+1.96215250865776E-09 )*Y-
+		    2.14234468198419E-08 )*Y+2.17216556336318E-07 )*Y-
+		  1.98850171329371E-06 )*Y+1.62429321438911E-05 )*Y-
+		1.16740298039895E-04 )*Y+7.24888732052332E-04 )*Y-
+	      3.79490003707156E-03 )*Y+1.61723488664661E-02 )*Y-
+	    5.29428148329736E-02 )*Y+1.15702180856167E-01;
+      WW1 = (X+X)*F1+exp(-X);
+      RT1 = F1/(WW1-F1);
+    } else if (n == 2) {
+      F1 = ((((((((((-1.61702782425558E-10*Y+1.96215250865776E-09 )*Y-
+		    2.14234468198419E-08 )*Y+2.17216556336318E-07 )*Y-
+		  1.98850171329371E-06 )*Y+1.62429321438911E-05 )*Y-
+		1.16740298039895E-04 )*Y+7.24888732052332E-04 )*Y-
+	      3.79490003707156E-03 )*Y+1.61723488664661E-02 )*Y-
+	    5.29428148329736E-02 )*Y+1.15702180856167E-01;
+      WW1 = (X+X)*F1+exp(-X);
+      RT1 = (((((((((-6.36859636616415E-12*Y+8.47417064776270E-11)*Y-
+		    5.152207846962E-10)*Y-3.846389873308E-10)*Y+
+		  8.472253388380E-08)*Y-1.85306035634293E-06 )*Y+
+		2.47191693238413E-05 )*Y-2.49018321709815E-04 )*Y+
+	      2.19173220020161E-03 )*Y-1.63329339286794E-02 )*Y+\
+	8.68085688285261E-02;
+      RT2 = ((((((((( 1.45331350488343E-10*Y+2.07111465297976E-09)*Y-
+		    1.878920917404E-08)*Y-1.725838516261E-07)*Y+
+		  2.247389642339E-06)*Y+9.76783813082564E-06 )*Y-
+		1.93160765581969E-04 )*Y-1.58064140671893E-03 )*Y+
+	      4.85928174507904E-02 )*Y-4.30761584997596E-01 )*Y+\
+	1.80400974537950E+00;
+      WW2 = ((F1-WW1)*RT1+F1)*(1.0E+00+RT2)/(RT2-RT1);
+      WW1 = WW1-WW2;
+    } else if (n == 3) {
+      RT1 = (((((((( 1.44687969563318E-12*Y+4.85300143926755E-12)*Y-
+		   6.55098264095516E-10 )*Y+1.56592951656828E-08 )*Y-
+		 2.60122498274734E-07 )*Y+3.86118485517386E-06 )*Y-
+	       5.13430986707889E-05 )*Y+6.03194524398109E-04 )*Y-
+	     6.11219349825090E-03 )*Y+4.52578254679079E-02;
+      RT2 = ((((((( 6.95964248788138E-10*Y-5.35281831445517E-09)*Y-
+		  6.745205954533E-08)*Y+1.502366784525E-06)*Y+
+		9.923326947376E-07)*Y-3.89147469249594E-04 )*Y+
+	      7.51549330892401E-03 )*Y-8.48778120363400E-02 )*Y+\
+	5.73928229597613E-01;
+      RT3 = ((((((((-2.81496588401439E-10*Y+3.61058041895031E-09)*Y+
+		   4.53631789436255E-08 )*Y-1.40971837780847E-07 )*Y-
+		 6.05865557561067E-06 )*Y-5.15964042227127E-05 )*Y+
+	       3.34761560498171E-05 )*Y+5.04871005319119E-02 )*Y-
+	     8.24708946991557E-01 )*Y+4.81234667357205E+00;
+      F2 = ((((((((((-1.48044231072140E-10*Y+1.78157031325097E-09 )*Y-
+		    1.92514145088973E-08 )*Y+1.92804632038796E-07 )*Y-
+		  1.73806555021045E-06 )*Y+1.39195169625425E-05 )*Y-
+		9.74574633246452E-05 )*Y+5.83701488646511E-04 )*Y-
+	      2.89955494844975E-03 )*Y+1.13847001113810E-02 )*Y-
+	    3.23446977320647E-02 )*Y+5.29428148329709E-02;
+      E = exp(-X);
+      F1 = ((X+X)*F2+E)/3.0E+00;
+      WW1 = (X+X)*F1+E;
+      T1 = RT1/(RT1+1.0E+00);
+      T2 = RT2/(RT2+1.0E+00);
+      T3 = RT3/(RT3+1.0E+00);
+      A2 = F2-T1*F1;
+      A1 = F1-T1*WW1;
+      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1));
+      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1));
+      WW1 = WW1-WW2-WW3;
+    }
+  } else if (X < 5.){
+    Y = X-4.0E+00;
+    if (n == 1){
+      F1 = ((((((((((-2.62453564772299E-11*Y+3.24031041623823E-10 )*Y-
+		    3.614965656163E-09)*Y+3.760256799971E-08)*Y-
+		  3.553558319675E-07)*Y+3.022556449731E-06)*Y-
+		2.290098979647E-05)*Y+1.526537461148E-04)*Y-
+	      8.81947375894379E-04 )*Y+4.33207949514611E-03 )*Y-
+	    1.75257821619926E-02 )*Y+5.28406320615584E-02;
+      WW1 = (X+X)*F1+exp(-X);
+      RT1 = F1/(WW1-F1);
+    } else if (n == 2) {
+      F1 = ((((((((((-2.62453564772299E-11*Y+3.24031041623823E-10 )*Y-
+		    3.614965656163E-09)*Y+3.760256799971E-08)*Y-
+		  3.553558319675E-07)*Y+3.022556449731E-06)*Y-
+		2.290098979647E-05)*Y+1.526537461148E-04)*Y-
+	      8.81947375894379E-04 )*Y+4.33207949514611E-03 )*Y-
+	    1.75257821619926E-02 )*Y+5.28406320615584E-02;
+      WW1 = (X+X)*F1+exp(-X);
+      RT1 = ((((((((-4.11560117487296E-12*Y+7.10910223886747E-11)*Y-
+		   1.73508862390291E-09 )*Y+5.93066856324744E-08 )*Y-
+		 9.76085576741771E-07 )*Y+1.08484384385679E-05 )*Y-
+	       1.12608004981982E-04 )*Y+1.16210907653515E-03 )*Y-
+	     9.89572595720351E-03 )*Y+6.12589701086408E-02;
+      RT2 = (((((((((-1.80555625241001E-10*Y+5.44072475994123E-10)*Y+
+		    1.603498045240E-08)*Y-1.497986283037E-07)*Y-
+		  7.017002532106E-07)*Y+1.85882653064034E-05 )*Y-
+		2.04685420150802E-05 )*Y-2.49327728643089E-03 )*Y+
+	      3.56550690684281E-02 )*Y-2.60417417692375E-01 )*Y+\
+	1.12155283108289E+00;
+      WW2 = ((F1-WW1)*RT1+F1)*(1.0E+00+RT2)/(RT2-RT1);
+      WW1 = WW1-WW2;
+    } else if (n == 3) {
+      RT1 = ((((((( 1.44265709189601E-11*Y-4.66622033006074E-10)*Y+
+		  7.649155832025E-09)*Y-1.229940017368E-07)*Y+
+		2.026002142457E-06)*Y-2.87048671521677E-05 )*Y+
+	      3.70326938096287E-04 )*Y-4.21006346373634E-03 )*Y+\
+	3.50898470729044E-02;
+      RT2 = ((((((((-2.65526039155651E-11*Y+1.97549041402552E-10)*Y+
+		   2.15971131403034E-09 )*Y-7.95045680685193E-08 )*Y+
+		 5.15021914287057E-07 )*Y+1.11788717230514E-05 )*Y-
+	       3.33739312603632E-04 )*Y+5.30601428208358E-03 )*Y-
+	     5.93483267268959E-02 )*Y+4.31180523260239E-01;
+      RT3 = ((((((((-3.92833750584041E-10*Y-4.16423229782280E-09)*Y+
+		   4.42413039572867E-08 )*Y+6.40574545989551E-07 )*Y-
+		 3.05512456576552E-06 )*Y-1.05296443527943E-04 )*Y-
+	       6.14120969315617E-04 )*Y+4.89665802767005E-02 )*Y-
+	     6.24498381002855E-01 )*Y+3.36412312243724E+00;
+      F2 = ((((((((((-2.36788772599074E-11*Y+2.89147476459092E-10 )*Y-
+		    3.18111322308846E-09 )*Y+3.25336816562485E-08 )*Y-
+		  3.00873821471489E-07 )*Y+2.48749160874431E-06 )*Y-
+		1.81353179793672E-05 )*Y+1.14504948737066E-04 )*Y-
+	      6.10614987696677E-04 )*Y+2.64584212770942E-03 )*Y-
+	    8.66415899015349E-03 )*Y+1.75257821619922E-02;
+      E = exp(-X);
+      F1 = ((X+X)*F2+E)/3.0E+00;
+      WW1 = (X+X)*F1+E;
+      T1 = RT1/(RT1+1.0E+00);
+      T2 = RT2/(RT2+1.0E+00);
+      T3 = RT3/(RT3+1.0E+00);
+      A2 = F2-T1*F1;
+      A1 = F1-T1*WW1;
+      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1));
+      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1));
+      WW1 = WW1-WW2-WW3;
+    }
+  } else if (X < 10) {
+    E = exp(-X);
+    WW1 = (((((( 4.6897511375022E-01/X-6.9955602298985E-01)/X +
+	       5.3689283271887E-01)/X-3.2883030418398E-01)/X +
+	     2.4645596956002E-01)/X-4.9984072848436E-01)/X -
+	   3.1501078774085E-06)*E + sqrt(PIE4/X);
+    F1 = (WW1-E)/(X+X);
+    if (n == 1)
+      RT1 = F1/(WW1-F1);
+    else if (n == 2){
+      Y = X-7.5E+00;
+      RT1 = (((((((((((((-1.43632730148572E-16*Y+2.38198922570405E-16)*
+			Y+1.358319618800E-14)*Y-7.064522786879E-14)*Y-
+		      7.719300212748E-13)*Y+7.802544789997E-12)*Y+
+		    6.628721099436E-11)*Y-1.775564159743E-09)*Y+
+		  1.713828823990E-08)*Y-1.497500187053E-07)*Y+
+		2.283485114279E-06)*Y-3.76953869614706E-05 )*Y+
+	      4.74791204651451E-04 )*Y-4.60448960876139E-03 )*Y+\
+	3.72458587837249E-02;
+      RT2 = (((((((((((( 2.48791622798900E-14*Y-1.36113510175724E-13)*Y-
+		       2.224334349799E-12)*Y+4.190559455515E-11)*Y-
+		     2.222722579924E-10)*Y-2.624183464275E-09)*Y+
+		   6.128153450169E-08)*Y-4.383376014528E-07)*Y-
+		 2.49952200232910E-06 )*Y+1.03236647888320E-04 )*Y-
+	       1.44614664924989E-03 )*Y+1.35094294917224E-02 )*Y-
+	     9.53478510453887E-02 )*Y+5.44765245686790E-01;
+      WW2 = ((F1-WW1)*RT1+F1)*(1.0E+00+RT2)/(RT2-RT1);
+      WW1 = WW1-WW2;
+    } else if (n == 3) {
+      F2 = (F1+F1+F1-E)/(X+X);
+      Y = X-7.5E+00;
+      RT1 = ((((((((((( 5.74429401360115E-16*Y+7.11884203790984E-16)*Y-
+		      6.736701449826E-14)*Y-6.264613873998E-13)*Y+
+		    1.315418927040E-11)*Y-4.23879635610964E-11 )*Y+
+		  1.39032379769474E-09 )*Y-4.65449552856856E-08 )*Y+
+		7.34609900170759E-07 )*Y-1.08656008854077E-05 )*Y+
+	      1.77930381549953E-04 )*Y-2.39864911618015E-03 )*Y+\
+	2.39112249488821E-02;
+      RT2 = ((((((((((( 1.13464096209120E-14*Y+6.99375313934242E-15)*Y-
+		      8.595618132088E-13)*Y-5.293620408757E-12)*Y-
+		    2.492175211635E-11)*Y+2.73681574882729E-09 )*Y-
+		  1.06656985608482E-08 )*Y-4.40252529648056E-07 )*Y+
+		9.68100917793911E-06 )*Y-1.68211091755327E-04 )*Y+
+	      2.69443611274173E-03 )*Y-3.23845035189063E-02 )*Y+\
+	2.75969447451882E-01;
+      RT3 = (((((((((((( 6.66339416996191E-15*Y+1.84955640200794E-13)*Y-
+		       1.985141104444E-12)*Y-2.309293727603E-11)*Y+
+		     3.917984522103E-10)*Y+1.663165279876E-09)*Y-
+		   6.205591993923E-08)*Y+8.769581622041E-09)*Y+
+		 8.97224398620038E-06 )*Y-3.14232666170796E-05 )*Y-
+	       1.83917335649633E-03 )*Y+3.51246831672571E-02 )*Y-
+	     3.22335051270860E-01 )*Y+1.73582831755430E+00;
+      T1 = RT1/(RT1+1.0E+00);
+      T2 = RT2/(RT2+1.0E+00);
+      T3 = RT3/(RT3+1.0E+00);
+      A2 = F2-T1*F1;
+      A1 = F1-T1*WW1;
+      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1));
+      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1));
+      WW1 = WW1-WW2-WW3;
+    }
+  } else if (X < 15) {
+    E = exp(-X);
+    WW1 = (((-1.8784686463512E-01/X+2.2991849164985E-01)/X -
+	    4.9893752514047E-01)/X-2.1916512131607E-05)*E \
+      + sqrt(PIE4/X);
+    F1 = (WW1-E)/(X+X);
+    if (n == 1)
+      RT1 = F1/(WW1-F1);
+    else if (n == 2) {
+      RT1 = ((((-1.01041157064226E-05*X+1.19483054115173E-03)*X -
+	       6.73760231824074E-02)*X+1.25705571069895E+00)*X +
+	     (((-8.57609422987199E+03/X+5.91005939591842E+03)/X -
+	       1.70807677109425E+03)/X+2.64536689959503E+02)/X -
+	     2.38570496490846E+01)*E + R12/(X-R12);
+      RT2 = ((( 3.39024225137123E-04*X-9.34976436343509E-02)*X -
+	      4.22216483306320E+00)*X +
+	     (((-2.08457050986847E+03/X -
+		1.04999071905664E+03)/X+3.39891508992661E+02)/X -
+	      1.56184800325063E+02)/X+8.00839033297501E+00)*E + R22/(X-R22);
+      WW2 = ((F1-WW1)*RT1+F1)*(1.0E+00+RT2)/(RT2-RT1);
+      WW1 = WW1-WW2;
+    } else if (n == 3) {
+      F2 = (F1+F1+F1-E)/(X+X);
+      Y = X-12.5E+00;
+      RT1 = ((((((((((( 4.42133001283090E-16*Y-2.77189767070441E-15)*Y-
+		      4.084026087887E-14)*Y+5.379885121517E-13)*Y+
+		    1.882093066702E-12)*Y-8.67286219861085E-11 )*Y+
+		  7.11372337079797E-10 )*Y-3.55578027040563E-09 )*Y+
+		1.29454702851936E-07 )*Y-4.14222202791434E-06 )*Y+
+	      8.04427643593792E-05 )*Y-1.18587782909876E-03 )*Y+\
+	1.53435577063174E-02;
+      RT2 = ((((((((((( 6.85146742119357E-15*Y-1.08257654410279E-14)*Y-
+		      8.579165965128E-13)*Y+6.642452485783E-12)*Y+
+		    4.798806828724E-11)*Y-1.13413908163831E-09 )*Y+
+		  7.08558457182751E-09 )*Y-5.59678576054633E-08 )*Y+
+		2.51020389884249E-06 )*Y-6.63678914608681E-05 )*Y+
+	      1.11888323089714E-03 )*Y-1.45361636398178E-02 )*Y+\
+	1.65077877454402E-01;
+      RT3 = (((((((((((( 3.20622388697743E-15*Y-2.73458804864628E-14)*Y-
+		       3.157134329361E-13)*Y+8.654129268056E-12)*Y-
+		     5.625235879301E-11)*Y-7.718080513708E-10)*Y+
+		   2.064664199164E-08)*Y-1.567725007761E-07)*Y-
+		 1.57938204115055E-06 )*Y+6.27436306915967E-05 )*Y-
+	       1.01308723606946E-03 )*Y+1.13901881430697E-02 )*Y-
+	     1.01449652899450E-01 )*Y+7.77203937334739E-01;
+      T1 = RT1/(RT1+1.0E+00);
+      T2 = RT2/(RT2+1.0E+00);
+      T3 = RT3/(RT3+1.0E+00);
+      A2 = F2-T1*F1;
+      A1 = F1-T1*WW1;
+      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1));
+      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1));
+      WW1 = WW1-WW2-WW3;
+    }
+  } else if (X < 33) {
+    E = exp(-X);
+    WW1 = (( 1.9623264149430E-01/X-4.9695241464490E-01)/X -
+	   6.0156581186481E-05)*E + sqrt(PIE4/X);
+    F1 = (WW1-E)/(X+X);
+    if (n == 1)
+      RT1 = F1/(WW1-F1);
+    else if (n == 2){
+      RT1 = ((((-1.14906395546354E-06*X+1.76003409708332E-04)*X -
+	       1.71984023644904E-02)*X-1.37292644149838E-01)*X +
+	     (-4.75742064274859E+01/X+9.21005186542857E+00)/X -
+	     2.31080873898939E-02)*E + R12/(X-R12);
+      RT2 = ((( 3.64921633404158E-04*X-9.71850973831558E-02)*X -
+	      4.02886174850252E+00)*X +
+	     (-1.35831002139173E+02/X -
+	      8.66891724287962E+01)/X+2.98011277766958E+00)*E + R22/(X-R22);
+      WW2 = ((F1-WW1)*RT1+F1)*(1.0E+00+RT2)/(RT2-RT1);
+      WW1 = WW1-WW2;
+    } else if (n == 3) {
+      F2 = (F1+F1+F1-E)/(X+X);
+      if (X < 20) {
+	RT1 = ((((((-2.43270989903742E-06*X+3.57901398988359E-04)*X -
+		   2.34112415981143E-02)*X+7.81425144913975E-01)*X -
+		 1.73209218219175E+01)*X+2.43517435690398E+02)*X +
+	       (-1.97611541576986E+04/X+9.82441363463929E+03)/X -
+	       2.07970687843258E+03)*E + R13/(X-R13);
+	RT2 = (((((-2.62627010965435E-04*X+3.49187925428138E-02)*X -
+		  3.09337618731880E+00)*X+1.07037141010778E+02)*X -
+		2.36659637247087E+03)*X +
+	       ((-2.91669113681020E+06/X +
+		 1.41129505262758E+06)/X-2.91532335433779E+05)/X +
+	       3.35202872835409E+04)*E + R23/(X-R23);
+	RT3 = ((((( 9.31856404738601E-05*X-2.87029400759565E-02)*X -
+		  7.83503697918455E-01)*X-1.84338896480695E+01)*X +
+		4.04996712650414E+02)*X +
+	       (-1.89829509315154E+05/X +
+		5.11498390849158E+04)/X-6.88145821789955E+03)*E \
+	  + R33/(X-R33);
+      } else {
+	RT1 = ((((-4.97561537069643E-04*X-5.00929599665316E-02)*X +
+		 1.31099142238996E+00)*X-1.88336409225481E+01)*X -
+	       6.60344754467191E+02 /X+1.64931462413877E+02)*E \
+	  + R13/(X-R13);
+	RT2 = ((((-4.48218898474906E-03*X-5.17373211334924E-01)*X +
+		 1.13691058739678E+01)*X-1.65426392885291E+02)*X -
+	       6.30909125686731E+03 /X+1.52231757709236E+03)*E \
+	  + R23/(X-R23);
+	RT3 = ((((-1.38368602394293E-02*X-1.77293428863008E+00)*X +
+		 1.73639054044562E+01)*X-3.57615122086961E+02)*X -
+	       1.45734701095912E+04 /X+2.69831813951849E+03)*E \
+	  + R33/(X-R33);
+      }
+      T1 = RT1/(RT1+1.0E+00);
+      T2 = RT2/(RT2+1.0E+00);
+      T3 = RT3/(RT3+1.0E+00);
+      A2 = F2-T1*F1;
+      A1 = F1-T1*WW1;
+      WW3 = (A2-T2*A1)/((T3-T2)*(T3-T1));
+      WW2 = (T3*A1-A2)/((T3-T2)*(T2-T1));
+      WW1 = WW1-WW2-WW3; 
+    }
+  } else {
+    WW1 = sqrt(PIE4/X);
+    if (n == 1)
+      RT1 = 0.5E+00/(X-0.5E+00);
+    else if (n == 2) {
+      if (X < 40) {
+	E = exp(-X);
+	RT1 = (-8.78947307498880E-01*X+1.09243702330261E+01)*E \
+	  + R12/(X-R12);
+	RT2 = (-9.28903924275977E+00*X+8.10642367843811E+01)*E \
+	  + R22/(X-R22);
+	WW2 = ( 4.46857389308400E+00*X-7.79250653461045E+01)*E + W22*WW1;
+	WW1 = WW1-WW2;
+      } else {
+	RT1 = R12/(X-R12);
+	RT2 = R22/(X-R22);
+	WW2 = W22*WW1;
+	WW1 = WW1-WW2;
+      }
+    } else if (n == 3) {
+      if (X < 47) {
+	E = exp(-X);
+	RT1 = ((-7.39058467995275E+00*X+3.21318352526305E+02)*X -
+	       3.99433696473658E+03)*E + R13/(X-R13);
+	RT2 = ((-7.38726243906513E+01*X+3.13569966333873E+03)*X -
+	       3.86862867311321E+04)*E + R23/(X-R23);
+	RT3 = ((-2.63750565461336E+02*X+1.04412168692352E+04)*X -
+	       1.28094577915394E+05)*E + R33/(X-R33);
+	WW3 = ((( 1.52258947224714E-01*X-8.30661900042651E+00)*X +
+		1.92977367967984E+02)*X-1.67787926005344E+03)*E \
+	  + W33*WW1;
+	WW2 = (( 6.15072615497811E+01*X-2.91980647450269E+03)*X +
+	       3.80794303087338E+04)*E + W23*WW1;
+	WW1 = WW1-WW2-WW3;
+      } else {
+	RT1 = R13/(X-R13);
+	RT2 = R23/(X-R23);
+	RT3 = R33/(X-R33);
+	WW2 = W23*WW1;
+	WW3 = W33*WW1;
+	WW1 = WW1-WW2-WW3;
+      }
+    }
+  }
+  roots[0] = RT1;
+  weights[0] = WW1;
+  if (n > 1){
+    roots[1] = RT2;
+    weights[1] = WW2;
+  }
+  if (n > 2) {
+    roots[2] = RT3;
+    weights[2] = WW3;
+  }
+  return;
+}
+
+static void Root4(double X){
+  double R14,PIE4,R24,W24,R34,W34,R44,W44;
+  double RT1=0,RT2=0,RT3=0,RT4=0,WW1=0,WW2=0,WW3=0,WW4=0;
+  double Y,E;
+  
+  R14 = 1.45303521503316E-01;
+  PIE4 = 7.85398163397448E-01;
+  R24 = 1.33909728812636E+00;
+  W24 = 2.34479815323517E-01;
+  R34 = 3.92696350135829E+00;
+  W34 = 1.92704402415764E-02;
+  R44 = 8.58863568901199E+00;
+  W44 = 2.25229076750736E-04;
+
+  if (X <= 3.0E-7) {
+    RT1 = 3.48198973061471E-02 -4.09645850660395E-03 *X;
+    RT2 = 3.81567185080042E-01 -4.48902570656719E-02 *X;
+    RT3 = 1.73730726945891E+00 -2.04389090547327E-01 *X;
+    RT4 = 1.18463056481549E+01 -1.39368301742312E+00 *X;
+    WW1 = 3.62683783378362E-01 -3.13844305713928E-02 *X;
+    WW2 = 3.13706645877886E-01 -8.98046242557724E-02 *X;
+    WW3 = 2.22381034453372E-01 -1.29314370958973E-01 *X;
+    WW4 = 1.01228536290376E-01 -8.28299075414321E-02 *X;
+  } else if (X <= 1.0) {
+    RT1 = ((((((-1.95309614628539E-10*X+5.19765728707592E-09)*X-
+	       1.01756452250573E-07 )*X+1.72365935872131E-06 )*X-
+	     2.61203523522184E-05 )*X+3.52921308769880E-04 )*X-
+	   4.09645850658433E-03 )*X+3.48198973061469E-02;
+    RT2 = (((((-1.89554881382342E-08*X+3.07583114342365E-07)*X+
+	      1.270981734393E-06)*X-1.417298563884E-04)*X+
+	    3.226979163176E-03)*X-4.48902570678178E-02 )*X+\
+      3.81567185080039E-01;
+    RT3 = (((((( 1.77280535300416E-09*X+3.36524958870615E-08)*X-
+	       2.58341529013893E-07 )*X-1.13644895662320E-05 )*X-
+	     7.91549618884063E-05 )*X+1.03825827346828E-02 )*X-
+	   2.04389090525137E-01 )*X+1.73730726945889E+00;
+    RT4 = (((((-5.61188882415248E-08*X-2.49480733072460E-07)*X+
+	      3.428685057114E-06)*X+1.679007454539E-04)*X+
+	    4.722855585715E-02)*X-1.39368301737828E+00 )*X+\
+      1.18463056481543E+01;
+    WW1 = ((((((-1.14649303201279E-08*X+1.88015570196787E-07)*X-
+	       2.33305875372323E-06 )*X+2.68880044371597E-05 )*X-
+	     2.94268428977387E-04 )*X+3.06548909776613E-03 )*X-
+	   3.13844305680096E-02 )*X+3.62683783378335E-01;
+    WW2 = ((((((((-4.11720483772634E-09*X+6.54963481852134E-08)*X-
+		 7.20045285129626E-07 )*X+6.93779646721723E-06 )*X-
+	       6.05367572016373E-05 )*X+4.74241566251899E-04 )*X-
+	     3.26956188125316E-03 )*X+1.91883866626681E-02 )*X-
+	   8.98046242565811E-02 )*X+3.13706645877886E-01;
+    WW3 = ((((((((-3.41688436990215E-08*X+5.07238960340773E-07)*X-
+		 5.01675628408220E-06 )*X+4.20363420922845E-05 )*X-
+	       3.08040221166823E-04 )*X+1.94431864731239E-03 )*X-
+	     1.02477820460278E-02 )*X+4.28670143840073E-02 )*X-
+	   1.29314370962569E-01 )*X+2.22381034453369E-01;
+    WW4 = ((((((((( 4.99660550769508E-09*X-7.94585963310120E-08)*X+
+		  8.359072409485E-07)*X-7.422369210610E-06)*X+
+		5.763374308160E-05)*X-3.86645606718233E-04 )*X+
+	      2.18417516259781E-03 )*X-9.99791027771119E-03 )*X+
+	    3.48791097377370E-02 )*X-8.28299075413889E-02 )*X+\
+      1.01228536290376E-01;
+  } else if (X <= 5) {
+    Y = X-3.0E+00;
+    RT1 = (((((((((-1.48570633747284E-15*Y-1.33273068108777E-13)*Y+
+		  4.068543696670E-12)*Y-9.163164161821E-11)*Y+
+		2.046819017845E-09)*Y-4.03076426299031E-08 )*Y+
+	      7.29407420660149E-07 )*Y-1.23118059980833E-05 )*Y+
+	    1.88796581246938E-04 )*Y-2.53262912046853E-03 )*Y+\
+      2.51198234505021E-02;
+    RT2 = ((((((((( 1.35830583483312E-13*Y-2.29772605964836E-12)*Y-
+		  3.821500128045E-12)*Y+6.844424214735E-10)*Y-
+		1.048063352259E-08)*Y+1.50083186233363E-08 )*Y+
+	      3.48848942324454E-06 )*Y-1.08694174399193E-04 )*Y+
+	    2.08048885251999E-03 )*Y-2.91205805373793E-02 )*Y+\
+      2.72276489515713E-01;
+    RT3 = ((((((((( 5.02799392850289E-13*Y+1.07461812944084E-11)*Y-
+		  1.482277886411E-10)*Y-2.153585661215E-09)*Y+
+		3.654087802817E-08)*Y+5.15929575830120E-07 )*Y-
+	      9.52388379435709E-06 )*Y-2.16552440036426E-04 )*Y+
+	    9.03551469568320E-03 )*Y-1.45505469175613E-01 )*Y+\
+      1.21449092319186E+00;
+    RT4 = (((((((((-1.08510370291979E-12*Y+6.41492397277798E-11)*Y+
+		  7.542387436125E-10)*Y-2.213111836647E-09)*Y-
+		1.448228963549E-07)*Y-1.95670833237101E-06 )*Y-
+	      1.07481314670844E-05 )*Y+1.49335941252765E-04 )*Y+
+	    4.87791531990593E-02 )*Y-1.10559909038653E+00 )*Y+\
+      8.09502028611780E+00;
+    WW1 = ((((((((((-4.65801912689961E-14*Y+7.58669507106800E-13)*Y-
+		   1.186387548048E-11)*Y+1.862334710665E-10)*Y-
+		 2.799399389539E-09)*Y+4.148972684255E-08)*Y-
+	       5.933568079600E-07)*Y+8.168349266115E-06)*Y-
+	     1.08989176177409E-04 )*Y+1.41357961729531E-03 )*Y-
+	   1.87588361833659E-02 )*Y+2.89898651436026E-01;
+    WW2 = ((((((((((((-1.46345073267549E-14*Y+2.25644205432182E-13)*Y-
+		     3.116258693847E-12)*Y+4.321908756610E-11)*Y-
+		   5.673270062669E-10)*Y+7.006295962960E-09)*Y-
+		 8.120186517000E-08)*Y+8.775294645770E-07)*Y-
+	       8.77829235749024E-06 )*Y+8.04372147732379E-05 )*Y-
+	     6.64149238804153E-04 )*Y+4.81181506827225E-03 )*Y-
+	   2.88982669486183E-02 )*Y+1.56247249979288E-01;
+    WW3 = ((((((((((((( 9.06812118895365E-15*Y-1.40541322766087E-13)*
+		      Y+1.919270015269E-12)*Y-2.605135739010E-11)*Y+
+		    3.299685839012E-10)*Y-3.86354139348735E-09 )*Y+
+		  4.16265847927498E-08 )*Y-4.09462835471470E-07 )*Y+
+		3.64018881086111E-06 )*Y-2.88665153269386E-05 )*Y+
+	      2.00515819789028E-04 )*Y-1.18791896897934E-03 )*Y+
+	    5.75223633388589E-03 )*Y-2.09400418772687E-02 )*Y+\
+      4.85368861938873E-02;
+    WW4 = ((((((((((((((-9.74835552342257E-16*Y+1.57857099317175E-14)*
+		       Y-2.249993780112E-13)*Y+3.173422008953E-12)*Y-
+		     4.161159459680E-11)*Y+5.021343560166E-10)*Y-
+		   5.545047534808E-09)*Y+5.554146993491E-08)*Y-
+		 4.99048696190133E-07 )*Y+3.96650392371311E-06 )*Y-
+	       2.73816413291214E-05 )*Y+1.60106988333186E-04 )*Y-
+	     7.64560567879592E-04 )*Y+2.81330044426892E-03 )*Y-
+	   7.16227030134947E-03 )*Y+9.66077262223353E-03;
+  } else if (X <= 10.0) {
+    Y = X-7.5E+00;
+    RT1 = ((((((((( 4.64217329776215E-15*Y-6.27892383644164E-15)*Y+
+		  3.462236347446E-13)*Y-2.927229355350E-11)*Y+
+		5.090355371676E-10)*Y-9.97272656345253E-09 )*Y+
+	      2.37835295639281E-07 )*Y-4.60301761310921E-06 )*Y+
+	    8.42824204233222E-05 )*Y-1.37983082233081E-03 )*Y+\
+      1.66630865869375E-02;
+    RT2 = ((((((((( 2.93981127919047E-14*Y+8.47635639065744E-13)*Y-
+		  1.446314544774E-11)*Y-6.149155555753E-12)*Y+
+		8.484275604612E-10)*Y-6.10898827887652E-08 )*Y+
+	      2.39156093611106E-06 )*Y-5.35837089462592E-05 )*Y+
+	    1.00967602595557E-03 )*Y-1.57769317127372E-02 )*Y+\
+      1.74853819464285E-01;
+    RT3 = (((((((((( 2.93523563363000E-14*Y-6.40041776667020E-14)*Y-
+		   2.695740446312E-12)*Y+1.027082960169E-10)*Y-
+		 5.822038656780E-10)*Y-3.159991002539E-08)*Y+
+	       4.327249251331E-07)*Y+4.856768455119E-06)*Y-
+	     2.54617989427762E-04 )*Y+5.54843378106589E-03 )*Y-
+	   7.95013029486684E-02 )*Y+7.20206142703162E-01;
+    RT4 = (((((((((((-1.62212382394553E-14*Y+7.68943641360593E-13)*Y+
+		    5.764015756615E-12)*Y-1.380635298784E-10)*Y-
+		  1.476849808675E-09)*Y+1.84347052385605E-08 )*Y+
+		3.34382940759405E-07 )*Y-1.39428366421645E-06 )*Y-
+	      7.50249313713996E-05 )*Y-6.26495899187507E-04 )*Y+
+	    4.69716410901162E-02 )*Y-6.66871297428209E-01 )*Y+\
+      4.11207530217806E+00;
+    WW1 = ((((((((((-1.65995045235997E-15*Y+6.91838935879598E-14)*Y-
+		   9.131223418888E-13)*Y+1.403341829454E-11)*Y-
+		 3.672235069444E-10)*Y+6.366962546990E-09)*Y-
+	       1.039220021671E-07)*Y+1.959098751715E-06)*Y-
+	     3.33474893152939E-05 )*Y+5.72164211151013E-04 )*Y-
+	   1.05583210553392E-02 )*Y+2.26696066029591E-01;
+    WW2 = ((((((((((((-3.57248951192047E-16*Y+6.25708409149331E-15)*Y-
+		     9.657033089714E-14)*Y+1.507864898748E-12)*Y-
+		   2.332522256110E-11)*Y+3.428545616603E-10)*Y-
+		 4.698730937661E-09)*Y+6.219977635130E-08)*Y-
+	       7.83008889613661E-07 )*Y+9.08621687041567E-06 )*Y-
+	     9.86368311253873E-05 )*Y+9.69632496710088E-04 )*Y-
+	   8.14594214284187E-03 )*Y+8.50218447733457E-02;
+    WW3 = ((((((((((((( 1.64742458534277E-16*Y-2.68512265928410E-15)*
+		      Y+3.788890667676E-14)*Y-5.508918529823E-13)*Y+
+		    7.555896810069E-12)*Y-9.69039768312637E-11 )*Y+
+		  1.16034263529672E-09 )*Y-1.28771698573873E-08 )*Y+
+		1.31949431805798E-07 )*Y-1.23673915616005E-06 )*Y+
+	      1.04189803544936E-05 )*Y-7.79566003744742E-05 )*Y+
+	    5.03162624754434E-04 )*Y-2.55138844587555E-03 )*Y+\
+      1.13250730954014E-02;
+    WW4 = ((((((((((((((-1.55714130075679E-17*Y+2.57193722698891E-16)*
+		       Y-3.626606654097E-15)*Y+5.234734676175E-14)*Y-
+		     7.067105402134E-13)*Y+8.793512664890E-12)*Y-
+		   1.006088923498E-10)*Y+1.050565098393E-09)*Y-
+		 9.91517881772662E-09 )*Y+8.35835975882941E-08 )*Y-
+	       6.19785782240693E-07 )*Y+3.95841149373135E-06 )*Y-
+	     2.11366761402403E-05 )*Y+9.00474771229507E-05 )*Y-
+	   2.78777909813289E-04 )*Y+5.26543779837487E-04;
+  } else if (X <= 15) {
+    Y = X-12.5E+00;
+    RT1 = ((((((((((( 4.94869622744119E-17*Y+8.03568805739160E-16)*Y-
+		    5.599125915431E-15)*Y-1.378685560217E-13)*Y+
+		  7.006511663249E-13)*Y+1.30391406991118E-11 )*Y+
+		8.06987313467541E-11 )*Y-5.20644072732933E-09 )*Y+
+	      7.72794187755457E-08 )*Y-1.61512612564194E-06 )*Y+
+	    4.15083811185831E-05 )*Y-7.87855975560199E-04 )*Y+\
+      1.14189319050009E-02;
+    RT2 = ((((((((((( 4.89224285522336E-16*Y+1.06390248099712E-14)*Y-
+		    5.446260182933E-14)*Y-1.613630106295E-12)*Y+
+		  3.910179118937E-12)*Y+1.90712434258806E-10 )*Y+
+		8.78470199094761E-10 )*Y-5.97332993206797E-08 )*Y+
+	      9.25750831481589E-07 )*Y-2.02362185197088E-05 )*Y+
+	    4.92341968336776E-04 )*Y-8.68438439874703E-03 )*Y+\
+      1.15825965127958E-01;
+    RT3 = (((((((((( 6.12419396208408E-14*Y+1.12328861406073E-13)*Y-
+		   9.051094103059E-12)*Y-4.781797525341E-11)*Y+
+		 1.660828868694E-09)*Y+4.499058798868E-10)*Y-
+	       2.519549641933E-07)*Y+4.977444040180E-06)*Y-
+	     1.25858350034589E-04 )*Y+2.70279176970044E-03 )*Y-
+	   3.99327850801083E-02 )*Y+4.33467200855434E-01;
+    RT4 = ((((((((((( 4.63414725924048E-14*Y-4.72757262693062E-14)*Y-
+		    1.001926833832E-11)*Y+6.074107718414E-11)*Y+
+		  1.576976911942E-09)*Y-2.01186401974027E-08 )*Y-
+		1.84530195217118E-07 )*Y+5.02333087806827E-06 )*Y+
+	      9.66961790843006E-06 )*Y-1.58522208889528E-03 )*Y+
+	    2.80539673938339E-02 )*Y-2.78953904330072E-01 )*Y+\
+      1.82835655238235E+00;
+    WW4 = ((((((((((((( 2.90401781000996E-18*Y-4.63389683098251E-17)*
+		      Y+6.274018198326E-16)*Y-8.936002188168E-15)*Y+
+		    1.194719074934E-13)*Y-1.45501321259466E-12 )*Y+
+		  1.64090830181013E-11 )*Y-1.71987745310181E-10 )*Y+
+		1.63738403295718E-09 )*Y-1.39237504892842E-08 )*Y+
+	      1.06527318142151E-07 )*Y-7.27634957230524E-07 )*Y+
+	    4.12159381310339E-06 )*Y-1.74648169719173E-05 )*Y+\
+      8.50290130067818E-05;
+    WW3 = ((((((((((((-4.19569145459480E-17*Y+5.94344180261644E-16)*Y-
+		     1.148797566469E-14)*Y+1.881303962576E-13)*Y-
+		   2.413554618391E-12)*Y+3.372127423047E-11)*Y-
+		 4.933988617784E-10)*Y+6.116545396281E-09)*Y-
+	       6.69965691739299E-08 )*Y+7.52380085447161E-07 )*Y-
+	     8.08708393262321E-06 )*Y+6.88603417296672E-05 )*Y-
+	   4.67067112993427E-04 )*Y+5.42313365864597E-03;
+    WW2 = ((((((((((-6.22272689880615E-15*Y+1.04126809657554E-13)*Y-
+		   6.842418230913E-13)*Y+1.576841731919E-11)*Y-
+		 4.203948834175E-10)*Y+6.287255934781E-09)*Y-
+	       8.307159819228E-08)*Y+1.356478091922E-06)*Y-
+	     2.08065576105639E-05 )*Y+2.52396730332340E-04 )*Y-
+	   2.94484050194539E-03 )*Y+6.01396183129168E-02;
+    WW1 = (((-1.8784686463512E-01/X+2.2991849164985E-01)/X -
+	    4.9893752514047E-01)/X-2.1916512131607E-05)*exp(-X) +\
+      sqrt(PIE4/X)-WW4-WW3-WW2;
+  } else if (X <= 20) {
+    WW1 = sqrt(PIE4/X);
+    Y = X-17.5E+00;
+    RT1 = ((((((((((( 4.36701759531398E-17*Y-1.12860600219889E-16)*Y-
+		    6.149849164164E-15)*Y+5.820231579541E-14)*Y+
+		  4.396602872143E-13)*Y-1.24330365320172E-11 )*Y+
+		6.71083474044549E-11 )*Y+2.43865205376067E-10 )*Y+
+	      1.67559587099969E-08 )*Y-9.32738632357572E-07 )*Y+
+	    2.39030487004977E-05 )*Y-4.68648206591515E-04 )*Y+\
+      8.34977776583956E-03;
+    RT2 = ((((((((((( 4.98913142288158E-16*Y-2.60732537093612E-16)*Y-
+		    7.775156445127E-14)*Y+5.766105220086E-13)*Y+
+		  6.432696729600E-12)*Y-1.39571683725792E-10 )*Y+
+		5.95451479522191E-10 )*Y+2.42471442836205E-09 )*Y+
+	      2.47485710143120E-07 )*Y-1.14710398652091E-05 )*Y+
+	    2.71252453754519E-04 )*Y-4.96812745851408E-03 )*Y+\
+      8.26020602026780E-02;
+    RT3 = ((((((((((( 1.91498302509009E-15*Y+1.48840394311115E-14)*Y-
+		    4.316925145767E-13)*Y+1.186495793471E-12)*Y+
+		  4.615806713055E-11)*Y-5.54336148667141E-10 )*Y+
+		3.48789978951367E-10 )*Y-2.79188977451042E-09 )*Y+
+	      2.09563208958551E-06 )*Y-6.76512715080324E-05 )*Y+
+	    1.32129867629062E-03 )*Y-2.05062147771513E-02 )*Y+\
+      2.88068671894324E-01;
+    RT4 = (((((((((((-5.43697691672942E-15*Y-1.12483395714468E-13)*Y+
+		    2.826607936174E-12)*Y-1.266734493280E-11)*Y-
+		  4.258722866437E-10)*Y+9.45486578503261E-09 )*Y-
+		5.86635622821309E-08 )*Y-1.28835028104639E-06 )*Y+
+	      4.41413815691885E-05 )*Y-7.61738385590776E-04 )*Y+
+	    9.66090902985550E-03 )*Y-1.01410568057649E-01 )*Y+\
+      9.54714798156712E-01;
+    WW4 = ((((((((((((-7.56882223582704E-19*Y+7.53541779268175E-18)*Y-
+		     1.157318032236E-16)*Y+2.411195002314E-15)*Y-
+		   3.601794386996E-14)*Y+4.082150659615E-13)*Y-
+		 4.289542980767E-12)*Y+5.086829642731E-11)*Y-
+	       6.35435561050807E-10 )*Y+6.82309323251123E-09 )*Y-
+	     5.63374555753167E-08 )*Y+3.57005361100431E-07 )*Y-
+	   2.40050045173721E-06 )*Y+4.94171300536397E-05;
+    WW3 = (((((((((((-5.54451040921657E-17*Y+2.68748367250999E-16)*Y+
+		    1.349020069254E-14)*Y-2.507452792892E-13)*Y+
+		  1.944339743818E-12)*Y-1.29816917658823E-11 )*Y+
+		3.49977768819641E-10 )*Y-8.67270669346398E-09 )*Y+
+	      1.31381116840118E-07 )*Y-1.36790720600822E-06 )*Y+
+	    1.19210697673160E-05 )*Y-1.42181943986587E-04 )*Y+\
+      4.12615396191829E-03;
+    WW2 = (((((((((((-1.86506057729700E-16*Y+1.16661114435809E-15)*Y+
+		    2.563712856363E-14)*Y-4.498350984631E-13)*Y+
+		  1.765194089338E-12)*Y+9.04483676345625E-12 )*Y+
+		4.98930345609785E-10 )*Y-2.11964170928181E-08 )*Y+
+	      3.98295476005614E-07 )*Y-5.49390160829409E-06 )*Y+
+	    7.74065155353262E-05 )*Y-1.48201933009105E-03 )*Y+\
+      4.97836392625268E-02;
+    WW1 = (( 1.9623264149430E-01/X-4.9695241464490E-01)/X -
+	   6.0156581186481E-05)*exp(-X)+WW1-WW2-WW3-WW4;
+  } else if (X <= 35) {
+    WW1 = sqrt(PIE4/X);
+    E = exp(-X);
+    RT1 = ((((((-4.45711399441838E-05*X+1.27267770241379E-03)*X -
+	       2.36954961381262E-01)*X+1.54330657903756E+01)*X -
+	     5.22799159267808E+02)*X+1.05951216669313E+04)*X +
+	   (-2.51177235556236E+06/X+8.72975373557709E+05)/X -
+	   1.29194382386499E+05)*E + R14/(X-R14);
+    RT2 = (((((-7.85617372254488E-02*X+6.35653573484868E+00)*X -
+	      3.38296938763990E+02)*X+1.25120495802096E+04)*X -
+	    3.16847570511637E+05)*X +
+	   ((-1.02427466127427E+09/X +
+	     3.70104713293016E+08)/X-5.87119005093822E+07)/X +
+	   5.38614211391604E+06)*E + R24/(X-R24);
+    RT3 = (((((-2.37900485051067E-01*X+1.84122184400896E+01)*X -
+	      1.00200731304146E+03)*X+3.75151841595736E+04)*X -
+	    9.50626663390130E+05)*X +
+	   ((-2.88139014651985E+09/X +
+	     1.06625915044526E+09)/X-1.72465289687396E+08)/X +
+	   1.60419390230055E+07)*E + R34/(X-R34);
+    RT4 = ((((((-6.00691586407385E-04*X-3.64479545338439E-01)*X +
+	       1.57496131755179E+01)*X-6.54944248734901E+02)*X +
+	     1.70830039597097E+04)*X-2.90517939780207E+05)*X +
+	   (3.49059698304732E+07/X-1.64944522586065E+07)/X +
+	   2.96817940164703E+06)*E + R44/(X-R44);
+    if (X <= 25) 
+      WW4 = ((((((( 2.33766206773151E-07*X-
+		    3.81542906607063E-05)*X +3.51416601267000E-03)*X-
+		 1.66538571864728E-01)*X +4.80006136831847E+00)*X-
+	       8.73165934223603E+01)*X +9.77683627474638E+02)*X +
+	     1.66000945117640E+04/X -6.14479071209961E+03)*E + W44*WW1;
+    else
+      WW4 = (((((( 5.74245945342286E-06*X-
+		   7.58735928102351E-05)*X +2.35072857922892E-04)*X-
+		3.78812134013125E-03)*X +3.09871652785805E-01)*X-
+	      7.11108633061306E+00)*X +5.55297573149528E+01)*E + W44*WW1;
+    WW3 = (((((( 2.36392855180768E-04*X-9.16785337967013E-03)*X +
+	       4.62186525041313E-01)*X-1.96943786006540E+01)*X +
+	     4.99169195295559E+02)*X-6.21419845845090E+03)*X +
+	   ((+5.21445053212414E+07/X-1.34113464389309E+07)/X +
+	    1.13673298305631E+06)/X-2.81501182042707E+03)*E + W34*WW1;
+    WW2 = (((((( 7.29841848989391E-04*X-3.53899555749875E-02)*X +
+	       2.07797425718513E+00)*X-1.00464709786287E+02)*X +
+	     3.15206108877819E+03)*X-6.27054715090012E+04)*X +
+	   (+1.54721246264919E+07/X-5.26074391316381E+06)/X +
+	   7.67135400969617E+05)*E + W24*WW1;
+    WW1 = (( 1.9623264149430E-01/X-4.9695241464490E-01)/X -
+	   6.0156581186481E-05)*E + WW1-WW2-WW3-WW4;
+  } else if (X <= 53) {
+    WW1 = sqrt(PIE4/X);
+    E = exp(-X)*pow(X,4);
+    RT4 = ((-2.19135070169653E-03*X-1.19108256987623E-01)*X -
+	   7.50238795695573E-01)*E + R44/(X-R44);
+    RT3 = ((-9.65842534508637E-04*X-4.49822013469279E-02)*X +
+	   6.08784033347757E-01)*E + R34/(X-R34);
+    RT2 = ((-3.62569791162153E-04*X-9.09231717268466E-03)*X +
+	   1.84336760556262E-01)*E + R24/(X-R24);
+    RT1 = ((-4.07557525914600E-05*X-6.88846864931685E-04)*X +
+	   1.74725309199384E-02)*E + R14/(X-R14);
+    WW4 = (( 5.76631982000990E-06*X-7.89187283804890E-05)*X +
+	   3.28297971853126E-04)*E + W44*WW1;
+    WW3 = (( 2.08294969857230E-04*X-3.77489954837361E-03)*X +
+	   2.09857151617436E-02)*E + W34*WW1;
+    WW2 = (( 6.16374517326469E-04*X-1.26711744680092E-02)*X +
+	   8.14504890732155E-02)*E + W24*WW1;
+    WW1 = WW1-WW2-WW3-WW4;
+  } else {
+    WW1 = sqrt(PIE4/X);
+    RT1 = R14/(X-R14);
+    RT2 = R24/(X-R24);
+    RT3 = R34/(X-R34);
+    RT4 = R44/(X-R44);
+    WW4 = W44*WW1;
+    WW3 = W34*WW1;
+    WW2 = W24*WW1;
+    WW1 = WW1-WW2-WW3-WW4;
+  }
+  roots[0] = RT1;
+  weights[0] = WW1;
+  roots[1] = RT2;
+  weights[1] = WW2;
+  roots[2] = RT3;
+  weights[2] = WW3;
+  roots[3] = RT4;
+  weights[3] = WW4;
+  return;
+}
+
+static void Root5(double X){
+  double R15,PIE4,R25,W25,R35,W35,R45,W45,R55,W55;
+  double RT1=0,RT2=0,RT3=0,RT4=0,RT5=0,
+    WW1=0,WW2=0,WW3=0,WW4=0,WW5=0;
+  double Y,E=0,XXX;
+
+  R15 = 1.17581320211778E-01;
+  PIE4 = 7.85398163397448E-01;
+  R25 = 1.07456201243690E+00;
+  W25 = 2.70967405960535E-01;
+  R35 = 3.08593744371754E+00;
+  W35 = 3.82231610015404E-02;
+  R45 = 6.41472973366203E+00;
+  W45 = 1.51614186862443E-03;
+  R55 = 1.18071894899717E+01;
+  W55 = 8.62130526143657E-06;
+
+  if (X < 3.e-7){
+    RT1 = 2.26659266316985E-02 -2.15865967920897E-03 *X;
+    RT2 = 2.31271692140903E-01 -2.20258754389745E-02 *X;
+    RT3 = 8.57346024118836E-01 -8.16520023025515E-02 *X;
+    RT4 = 2.97353038120346E+00 -2.83193369647137E-01 *X;
+    RT5 = 1.84151859759051E+01 -1.75382723579439E+00 *X;
+    WW1 = 2.95524224714752E-01 -1.96867576909777E-02 *X;
+    WW2 = 2.69266719309995E-01 -5.61737590184721E-02 *X;
+    WW3 = 2.19086362515981E-01 -9.71152726793658E-02 *X;
+    WW4 = 1.49451349150580E-01 -1.02979262193565E-01 *X;
+    WW5 = 6.66713443086877E-02 -5.73782817488315E-02 *X;
+  } else if (X < 1.0){
+    RT1 = ((((((-4.46679165328413E-11*X+1.21879111988031E-09)*X-
+	       2.62975022612104E-08 )*X+5.15106194905897E-07 )*X-
+	     9.27933625824749E-06 )*X+1.51794097682482E-04 )*X-
+	   2.15865967920301E-03 )*X+2.26659266316985E-02;
+    RT2 = (((((( 1.93117331714174E-10*X-4.57267589660699E-09)*X+
+	       2.48339908218932E-08 )*X+1.50716729438474E-06 )*X-
+	     6.07268757707381E-05 )*X+1.37506939145643E-03 )*X-
+	   2.20258754419939E-02 )*X+2.31271692140905E-01;
+    RT3 = ((((( 4.84989776180094E-09*X+1.31538893944284E-07)*X-
+	      2.766753852879E-06)*X-7.651163510626E-05)*X+
+	    4.033058545972E-03)*X-8.16520022916145E-02 )*X+\
+      8.57346024118779E-01;
+    RT4 = ((((-2.48581772214623E-07*X-4.34482635782585E-06)*X-
+	     7.46018257987630E-07 )*X+1.01210776517279E-02 )*X-
+	   2.83193369640005E-01 )*X+2.97353038120345E+00;
+    RT5 = (((((-8.92432153868554E-09*X+1.77288899268988E-08)*X+
+	      3.040754680666E-06)*X+1.058229325071E-04)*X+
+	    4.596379534985E-02)*X-1.75382723579114E+00 )*X+\
+      1.84151859759049E+01;
+    WW1 = ((((((-2.03822632771791E-09*X+3.89110229133810E-08)*X-
+	       5.84914787904823E-07 )*X+8.30316168666696E-06 )*X-
+	     1.13218402310546E-04 )*X+1.49128888586790E-03 )*X-
+	   1.96867576904816E-02 )*X+2.95524224714749E-01;
+    WW2 = ((((((( 8.62848118397570E-09*X-1.38975551148989E-07)*X+
+		1.602894068228E-06)*X-1.646364300836E-05)*X+
+	      1.538445806778E-04)*X-1.28848868034502E-03 )*X+
+	    9.38866933338584E-03 )*X-5.61737590178812E-02 )*X+\
+      2.69266719309991E-01;
+    WW3 = ((((((((-9.41953204205665E-09*X+1.47452251067755E-07)*X-
+		 1.57456991199322E-06 )*X+1.45098401798393E-05 )*X-
+	       1.18858834181513E-04 )*X+8.53697675984210E-04 )*X-
+	     5.22877807397165E-03 )*X+2.60854524809786E-02 )*X-
+	   9.71152726809059E-02 )*X+2.19086362515979E-01;
+    WW4 = ((((((((-3.84961617022042E-08*X+5.66595396544470E-07)*X-
+		 5.52351805403748E-06 )*X+4.53160377546073E-05 )*X-
+	       3.22542784865557E-04 )*X+1.95682017370967E-03 )*X-
+	     9.77232537679229E-03 )*X+3.79455945268632E-02 )*X-
+	   1.02979262192227E-01 )*X+1.49451349150573E-01;
+    WW5 = ((((((((( 4.09594812521430E-09*X-6.47097874264417E-08)*X+
+		  6.743541482689E-07)*X-5.917993920224E-06)*X+
+		4.531969237381E-05)*X-2.99102856679638E-04 )*X+
+	      1.65695765202643E-03 )*X-7.40671222520653E-03 )*X+
+	    2.50889946832192E-02 )*X-5.73782817487958E-02 )*X+\
+      6.66713443086877E-02;
+  } else if (X < 5.0) {
+    Y = X-3.0E+00;
+    RT1 = ((((((((-2.58163897135138E-14*Y+8.14127461488273E-13)*Y-
+		 2.11414838976129E-11 )*Y+5.09822003260014E-10 )*Y-
+	       1.16002134438663E-08 )*Y+2.46810694414540E-07 )*Y-
+	     4.92556826124502E-06 )*Y+9.02580687971053E-05 )*Y-
+	   1.45190025120726E-03 )*Y+1.73416786387475E-02;
+    RT2 = ((((((((( 1.04525287289788E-14*Y+5.44611782010773E-14)*Y-
+		  4.831059411392E-12)*Y+1.136643908832E-10)*Y-
+		1.104373076913E-09)*Y-2.35346740649916E-08 )*Y+
+	      1.43772622028764E-06 )*Y-4.23405023015273E-05 )*Y+
+	    9.12034574793379E-04 )*Y-1.52479441718739E-02 )*Y+\
+      1.76055265928744E-01;
+    RT3 = (((((((((-6.89693150857911E-14*Y+5.92064260918861E-13)*Y+
+		  1.847170956043E-11)*Y-3.390752744265E-10)*Y-
+		2.995532064116E-09)*Y+1.57456141058535E-07 )*Y-
+	      3.95859409711346E-07 )*Y-9.58924580919747E-05 )*Y+
+	    3.23551502557785E-03 )*Y-5.97587007636479E-02 )*Y+\
+      6.46432853383057E-01;
+    RT4 = ((((((((-3.61293809667763E-12*Y-2.70803518291085E-11)*Y+
+		 8.83758848468769E-10 )*Y+1.59166632851267E-08 )*Y-
+	       1.32581997983422E-07 )*Y-7.60223407443995E-06 )*Y-
+	     7.41019244900952E-05 )*Y+9.81432631743423E-03 )*Y-
+	   2.23055570487771E-01 )*Y+2.21460798080643E+00;
+    RT5 = ((((((((( 7.12332088345321E-13*Y+3.16578501501894E-12)*Y-
+		  8.776668218053E-11)*Y-2.342817613343E-09)*Y-
+		3.496962018025E-08)*Y-3.03172870136802E-07 )*Y+
+	      1.50511293969805E-06 )*Y+1.37704919387696E-04 )*Y+
+	    4.70723869619745E-02 )*Y-1.47486623003693E+00 )*Y+\
+      1.35704792175847E+01;
+    WW1 = ((((((((( 1.04348658616398E-13*Y-1.94147461891055E-12)*Y+
+		  3.485512360993E-11)*Y-6.277497362235E-10)*Y+
+		1.100758247388E-08)*Y-1.88329804969573E-07 )*Y+
+	      3.12338120839468E-06 )*Y-5.04404167403568E-05 )*Y+
+	    8.00338056610995E-04 )*Y-1.30892406559521E-02 )*Y+\
+      2.47383140241103E-01;
+    WW2 = ((((((((((( 3.23496149760478E-14*Y-5.24314473469311E-13)*Y+
+		    7.743219385056E-12)*Y-1.146022750992E-10)*Y+
+		  1.615238462197E-09)*Y-2.15479017572233E-08 )*Y+
+		2.70933462557631E-07 )*Y-3.18750295288531E-06 )*Y+
+	      3.47425221210099E-05 )*Y-3.45558237388223E-04 )*Y+
+	    3.05779768191621E-03 )*Y-2.29118251223003E-02 )*Y+\
+      1.59834227924213E-01;
+    WW3 = ((((((((((((-3.42790561802876E-14*Y+5.26475736681542E-13)*Y-
+		     7.184330797139E-12)*Y+9.763932908544E-11)*Y-
+		   1.244014559219E-09)*Y+1.472744068942E-08)*Y-
+		 1.611749975234E-07)*Y+1.616487851917E-06)*Y-
+	       1.46852359124154E-05 )*Y+1.18900349101069E-04 )*Y-
+	     8.37562373221756E-04 )*Y+4.93752683045845E-03 )*Y-
+	   2.25514728915673E-02 )*Y+6.95211812453929E-02;
+    WW4 = ((((((((((((( 1.04072340345039E-14*Y-1.60808044529211E-13)*
+		      Y+2.183534866798E-12)*Y-2.939403008391E-11)*Y+
+		    3.679254029085E-10)*Y-4.23775673047899E-09 )*Y+
+		  4.46559231067006E-08 )*Y-4.26488836563267E-07 )*Y+
+		3.64721335274973E-06 )*Y-2.74868382777722E-05 )*Y+
+	      1.78586118867488E-04 )*Y-9.68428981886534E-04 )*Y+
+	    4.16002324339929E-03 )*Y-1.28290192663141E-02 )*Y+\
+      2.22353727685016E-02;
+    WW5 = ((((((((((((((-8.16770412525963E-16*Y+1.31376515047977E-14)*
+		       Y-1.856950818865E-13)*Y+2.596836515749E-12)*Y-
+		     3.372639523006E-11)*Y+4.025371849467E-10)*Y-
+		   4.389453269417E-09)*Y+4.332753856271E-08)*Y-
+		 3.82673275931962E-07 )*Y+2.98006900751543E-06 )*Y-
+	       2.00718990300052E-05 )*Y+1.13876001386361E-04 )*Y-
+	     5.23627942443563E-04 )*Y+1.83524565118203E-03 )*Y-
+	   4.37785737450783E-03 )*Y+5.36963805223095E-03;
+  } else if (X < 10.0) {
+    Y = X-7.5E+00;
+    RT1 = ((((((((-1.13825201010775E-14*Y+1.89737681670375E-13)*Y-
+		 4.81561201185876E-12 )*Y+1.56666512163407E-10 )*Y-
+	       3.73782213255083E-09 )*Y+9.15858355075147E-08 )*Y-
+	     2.13775073585629E-06 )*Y+4.56547356365536E-05 )*Y-
+	   8.68003909323740E-04 )*Y+1.22703754069176E-02;
+    RT2 = (((((((((-3.67160504428358E-15*Y+1.27876280158297E-14)*Y-
+		  1.296476623788E-12)*Y+1.477175434354E-11)*Y+
+		5.464102147892E-10)*Y-2.42538340602723E-08 )*Y+
+	      8.20460740637617E-07 )*Y-2.20379304598661E-05 )*Y+
+	    4.90295372978785E-04 )*Y-9.14294111576119E-03 )*Y+\
+      1.22590403403690E-01;
+    RT3 = ((((((((( 1.39017367502123E-14*Y-6.96391385426890E-13)*Y+
+		  1.176946020731E-12)*Y+1.725627235645E-10)*Y-
+		3.686383856300E-09)*Y+2.87495324207095E-08 )*Y+
+	      1.71307311000282E-06 )*Y-7.94273603184629E-05 )*Y+
+	    2.00938064965897E-03 )*Y-3.63329491677178E-02 )*Y+\
+      4.34393683888443E-01;
+    RT4 = ((((((((((-1.27815158195209E-14*Y+1.99910415869821E-14)*Y+
+		   3.753542914426E-12)*Y-2.708018219579E-11)*Y-
+		 1.190574776587E-09)*Y+1.106696436509E-08)*Y+
+	       3.954955671326E-07)*Y-4.398596059588E-06)*Y-
+	     2.01087998907735E-04 )*Y+7.89092425542937E-03 )*Y-
+	   1.42056749162695E-01 )*Y+1.39964149420683E+00;
+    RT5 = ((((((((((-1.19442341030461E-13*Y-2.34074833275956E-12)*Y+
+		   6.861649627426E-12)*Y+6.082671496226E-10)*Y+
+		 5.381160105420E-09)*Y-6.253297138700E-08)*Y-
+	       2.135966835050E-06)*Y-2.373394341886E-05)*Y+
+	     2.88711171412814E-06 )*Y+4.85221195290753E-02 )*Y-
+	   1.04346091985269E+00 )*Y+7.89901551676692E+00;
+    WW1 = ((((((((( 7.95526040108997E-15*Y-2.48593096128045E-13)*Y+
+		  4.761246208720E-12)*Y-9.535763686605E-11)*Y+
+		2.225273630974E-09)*Y-4.49796778054865E-08 )*Y+
+	      9.17812870287386E-07 )*Y-1.86764236490502E-05 )*Y+
+	    3.76807779068053E-04 )*Y-8.10456360143408E-03 )*Y+\
+      2.01097936411496E-01;
+    WW2 = ((((((((((( 1.25678686624734E-15*Y-2.34266248891173E-14)*Y+
+		    3.973252415832E-13)*Y-6.830539401049E-12)*Y+
+		  1.140771033372E-10)*Y-1.82546185762009E-09 )*Y+
+		2.77209637550134E-08 )*Y-4.01726946190383E-07 )*Y+
+	      5.48227244014763E-06 )*Y-6.95676245982121E-05 )*Y+
+	    8.05193921815776E-04 )*Y-8.15528438784469E-03 )*Y+\
+      9.71769901268114E-02;
+    WW3 = ((((((((((((-8.20929494859896E-16*Y+1.37356038393016E-14)*Y-
+		     2.022863065220E-13)*Y+3.058055403795E-12)*Y-
+		   4.387890955243E-11)*Y+5.923946274445E-10)*Y-
+		 7.503659964159E-09)*Y+8.851599803902E-08)*Y-
+	       9.65561998415038E-07 )*Y+9.60884622778092E-06 )*Y-
+	     8.56551787594404E-05 )*Y+6.66057194311179E-04 )*Y-
+	   4.17753183902198E-03 )*Y+2.25443826852447E-02;
+    WW4 = ((((((((((((((-1.08764612488790E-17*Y+1.85299909689937E-16)*
+		       Y-2.730195628655E-15)*Y+4.127368817265E-14)*Y-
+		     5.881379088074E-13)*Y+7.805245193391E-12)*Y-
+		   9.632707991704E-11)*Y+1.099047050624E-09)*Y-
+		 1.15042731790748E-08 )*Y+1.09415155268932E-07 )*Y-
+	       9.33687124875935E-07 )*Y+7.02338477986218E-06 )*Y-
+	     4.53759748787756E-05 )*Y+2.41722511389146E-04 )*Y-
+	   9.75935943447037E-04 )*Y+2.57520532789644E-03;
+    WW5 = ((((((((((((((( 7.28996979748849E-19*Y-1.26518146195173E-17)
+			*Y+1.886145834486E-16)*Y-2.876728287383E-15)*Y+
+		      4.114588668138E-14)*Y-5.44436631413933E-13 )*Y+
+		    6.64976446790959E-12 )*Y-7.44560069974940E-11 )*Y+
+		  7.57553198166848E-10 )*Y-6.92956101109829E-09 )*Y+
+		5.62222859033624E-08 )*Y-3.97500114084351E-07 )*Y+
+	      2.39039126138140E-06 )*Y-1.18023950002105E-05 )*Y+
+	    4.52254031046244E-05 )*Y-1.21113782150370E-04 )*Y+\
+      1.75013126731224E-04;
+  } else if (X < 15.0) {
+    Y = X-12.5E+00;
+    RT1 = ((((((((((-4.16387977337393E-17*Y+7.20872997373860E-16)*Y+
+		   1.395993802064E-14)*Y+3.660484641252E-14)*Y-
+		 4.154857548139E-12)*Y+2.301379846544E-11)*Y-
+	       1.033307012866E-09)*Y+3.997777641049E-08)*Y-
+	     9.35118186333939E-07 )*Y+2.38589932752937E-05 )*Y-
+	   5.35185183652937E-04 )*Y+8.85218988709735E-03;
+    RT2 = ((((((((((-4.56279214732217E-16*Y+6.24941647247927E-15)*Y+
+		   1.737896339191E-13)*Y+8.964205979517E-14)*Y-
+		 3.538906780633E-11)*Y+9.561341254948E-11)*Y-
+	       9.772831891310E-09)*Y+4.240340194620E-07)*Y-
+	     1.02384302866534E-05 )*Y+2.57987709704822E-04 )*Y-
+	   5.54735977651677E-03 )*Y+8.68245143991948E-02;
+    RT3 = ((((((((((-2.52879337929239E-15*Y+2.13925810087833E-14)*Y+
+		   7.884307667104E-13)*Y-9.023398159510E-13)*Y-
+		 5.814101544957E-11)*Y-1.333480437968E-09)*Y-
+	       2.217064940373E-08)*Y+1.643290788086E-06)*Y-
+	     4.39602147345028E-05 )*Y+1.08648982748911E-03 )*Y-
+	   2.13014521653498E-02 )*Y+2.94150684465425E-01;
+    RT4 = ((((((((((-6.42391438038888E-15*Y+5.37848223438815E-15)*Y+
+		   8.960828117859E-13)*Y+5.214153461337E-11)*Y-
+		 1.106601744067E-10)*Y-2.007890743962E-08)*Y+
+	       1.543764346501E-07)*Y+4.520749076914E-06)*Y-
+	     1.88893338587047E-04 )*Y+4.73264487389288E-03 )*Y-
+	   7.91197893350253E-02 )*Y+8.60057928514554E-01;
+    RT5 = (((((((((((-2.24366166957225E-14*Y+4.87224967526081E-14)*Y+
+		    5.587369053655E-12)*Y-3.045253104617E-12)*Y-
+		  1.223983883080E-09)*Y-2.05603889396319E-09 )*Y+
+		2.58604071603561E-07 )*Y+1.34240904266268E-06 )*Y-
+	      5.72877569731162E-05 )*Y-9.56275105032191E-04 )*Y+
+	    4.23367010370921E-02 )*Y-5.76800927133412E-01 )*Y+\
+      3.87328263873381E+00;
+    WW1 = ((((((((( 8.98007931950169E-15*Y+7.25673623859497E-14)*Y+
+		  5.851494250405E-14)*Y-4.234204823846E-11)*Y+
+		3.911507312679E-10)*Y-9.65094802088511E-09 )*Y+
+	      3.42197444235714E-07 )*Y-7.51821178144509E-06 )*Y+
+	    1.94218051498662E-04 )*Y-5.38533819142287E-03 )*Y+\
+      1.68122596736809E-01;
+    WW2 = ((((((((((-1.05490525395105E-15*Y+1.96855386549388E-14)*Y-
+		   5.500330153548E-13)*Y+1.003849567976E-11)*Y-
+		 1.720997242621E-10)*Y+3.533277061402E-09)*Y-
+	       6.389171736029E-08)*Y+1.046236652393E-06)*Y-
+	     1.73148206795827E-05 )*Y+2.57820531617185E-04 )*Y-
+	   3.46188265338350E-03 )*Y+7.03302497508176E-02;
+    WW3 = ((((((((((( 3.60020423754545E-16*Y-6.24245825017148E-15)*Y+
+		    9.945311467434E-14)*Y-1.749051512721E-12)*Y+
+		  2.768503957853E-11)*Y-4.08688551136506E-10 )*Y+
+		6.04189063303610E-09 )*Y-8.23540111024147E-08 )*Y+
+	      1.01503783870262E-06 )*Y-1.20490761741576E-05 )*Y+
+	    1.26928442448148E-04 )*Y-1.05539461930597E-03 )*Y+\
+      1.15543698537013E-02;
+    WW4 = ((((((((((((( 2.51163533058925E-18*Y-4.31723745510697E-17)*
+		      Y+6.557620865832E-16)*Y-1.016528519495E-14)*Y+
+		    1.491302084832E-13)*Y-2.06638666222265E-12 )*Y+
+		  2.67958697789258E-11 )*Y-3.23322654638336E-10 )*Y+
+		3.63722952167779E-09 )*Y-3.75484943783021E-08 )*Y+
+	      3.49164261987184E-07 )*Y-2.92658670674908E-06 )*Y+
+	    2.12937256719543E-05 )*Y-1.19434130620929E-04 )*Y+\
+      6.45524336158384E-04;
+    WW5 = ((((((((((((((-1.29043630202811E-19*Y+2.16234952241296E-18)*
+		       Y-3.107631557965E-17)*Y+4.570804313173E-16)*Y-
+		     6.301348858104E-15)*Y+8.031304476153E-14)*Y-
+		   9.446196472547E-13)*Y+1.018245804339E-11)*Y-
+		 9.96995451348129E-11 )*Y+8.77489010276305E-10 )*Y-
+	       6.84655877575364E-09 )*Y+4.64460857084983E-08 )*Y-
+	     2.66924538268397E-07 )*Y+1.24621276265907E-06 )*Y-
+	   4.30868944351523E-06 )*Y+9.94307982432868E-06;
+  } else if (X < 20.0){
+    Y = X-17.5E+00;
+    RT1 = (((((((((( 1.91875764545740E-16*Y+7.8357401095707E-16)*Y-
+		   3.260875931644E-14)*Y-1.186752035569E-13)*Y+
+		 4.275180095653E-12)*Y+3.357056136731E-11)*Y-
+	       1.123776903884E-09)*Y+1.231203269887E-08)*Y-
+	     3.99851421361031E-07 )*Y+1.45418822817771E-05 )*Y-
+	   3.49912254976317E-04 )*Y+6.67768703938812E-03;
+    RT2 = (((((((((( 2.02778478673555E-15*Y+1.01640716785099E-14)*Y-
+		   3.385363492036E-13)*Y-1.615655871159E-12)*Y+
+		 4.527419140333E-11)*Y+3.853670706486E-10)*Y-
+	       1.184607130107E-08)*Y+1.347873288827E-07)*Y-
+	     4.47788241748377E-06 )*Y+1.54942754358273E-04 )*Y-
+	   3.55524254280266E-03 )*Y+6.44912219301603E-02;
+    RT3 = (((((((((( 7.79850771456444E-15*Y+6.00464406395001E-14)*Y-
+		   1.249779730869E-12)*Y-1.020720636353E-11)*Y+
+		 1.814709816693E-10)*Y+1.766397336977E-09)*Y-
+	       4.603559449010E-08)*Y+5.863956443581E-07)*Y-
+	     2.03797212506691E-05 )*Y+6.31405161185185E-04 )*Y-
+	   1.30102750145071E-02 )*Y+2.10244289044705E-01;
+    RT4 = (((((((((((-2.92397030777912E-15*Y+1.94152129078465E-14)*Y+
+		    4.859447665850E-13)*Y-3.217227223463E-12)*Y-
+		  7.484522135512E-11)*Y+7.19101516047753E-10 )*Y+
+		6.88409355245582E-09 )*Y-1.44374545515769E-07 )*Y+
+	      2.74941013315834E-06 )*Y-1.02790452049013E-04 )*Y+
+	    2.59924221372643E-03 )*Y-4.35712368303551E-02 )*Y+\
+      5.62170709585029E-01;
+    RT5 = ((((((((((( 1.17976126840060E-14*Y+1.24156229350669E-13)*Y-
+		    3.892741622280E-12)*Y-7.755793199043E-12)*Y+
+		  9.492190032313E-10)*Y-4.98680128123353E-09 )*Y-
+		1.81502268782664E-07 )*Y+2.69463269394888E-06 )*Y+
+	      2.50032154421640E-05 )*Y-1.33684303917681E-03 )*Y+
+	    2.29121951862538E-02 )*Y-2.45653725061323E-01 )*Y+\
+      1.89999883453047E+00;
+    WW1 = (((((((((( 1.74841995087592E-15*Y-6.95671892641256E-16)*Y-
+		   3.000659497257E-13)*Y+2.021279817961E-13)*Y+
+		 3.853596935400E-11)*Y+1.461418533652E-10)*Y-
+	       1.014517563435E-08)*Y+1.132736008979E-07)*Y-
+	     2.86605475073259E-06 )*Y+1.21958354908768E-04 )*Y-
+	   3.86293751153466E-03 )*Y+1.45298342081522E-01;
+    WW2 = ((((((((((-1.11199320525573E-15*Y+1.85007587796671E-15)*Y+
+		   1.220613939709E-13)*Y+1.275068098526E-12)*Y-
+		 5.341838883262E-11)*Y+6.161037256669E-10)*Y-
+	       1.009147879750E-08)*Y+2.907862965346E-07)*Y-
+	     6.12300038720919E-06 )*Y+1.00104454489518E-04 )*Y-
+	   1.80677298502757E-03 )*Y+5.78009914536630E-02;
+    WW3 = ((((((((((-9.49816486853687E-16*Y+6.67922080354234E-15)*Y+
+		   2.606163540537E-15)*Y+1.983799950150E-12)*Y-
+		 5.400548574357E-11)*Y+6.638043374114E-10)*Y-
+	       8.799518866802E-09)*Y+1.791418482685E-07)*Y-
+	     2.96075397351101E-06 )*Y+3.38028206156144E-05 )*Y-
+	   3.58426847857878E-04 )*Y+8.39213709428516E-03;
+    WW4 = ((((((((((( 1.33829971060180E-17*Y-3.44841877844140E-16)*Y+
+		    4.745009557656E-15)*Y-6.033814209875E-14)*Y+
+		  1.049256040808E-12)*Y-1.70859789556117E-11 )*Y+
+		2.15219425727959E-10 )*Y-2.52746574206884E-09 )*Y+
+	      3.27761714422960E-08 )*Y-3.90387662925193E-07 )*Y+
+	    3.46340204593870E-06 )*Y-2.43236345136782E-05 )*Y+\
+      3.54846978585226E-04;
+    WW5 = ((((((((((((( 2.69412277020887E-20*Y-4.24837886165685E-19)*
+		      Y+6.030500065438E-18)*Y-9.069722758289E-17)*Y+
+		    1.246599177672E-15)*Y-1.56872999797549E-14 )*Y+
+		  1.87305099552692E-13 )*Y-2.09498886675861E-12 )*Y+
+		2.11630022068394E-11 )*Y-1.92566242323525E-10 )*Y+
+	      1.62012436344069E-09 )*Y-1.23621614171556E-08 )*Y+
+	    7.72165684563049E-08 )*Y-3.59858901591047E-07 )*Y+\
+      2.43682618601000E-06;
+  } else if (X < 25.0) {
+    Y = X-22.5E+00;
+    RT1 = (((((((((-1.13927848238726E-15*Y+7.39404133595713E-15)*Y+
+		  1.445982921243E-13)*Y-2.676703245252E-12)*Y+
+		5.823521627177E-12)*Y+2.17264723874381E-10 )*Y+
+	      3.56242145897468E-09 )*Y-3.03763737404491E-07 )*Y+
+	    9.46859114120901E-06 )*Y-2.30896753853196E-04 )*Y+\
+      5.24663913001114E-03;
+    RT2 = (((((((((( 2.89872355524581E-16*Y-1.22296292045864E-14)*Y+
+		   6.184065097200E-14)*Y+1.649846591230E-12)*Y-
+		 2.729713905266E-11)*Y+3.709913790650E-11)*Y+
+	       2.216486288382E-09)*Y+4.616160236414E-08)*Y-
+	     3.32380270861364E-06 )*Y+9.84635072633776E-05 )*Y-
+	   2.30092118015697E-03 )*Y+5.00845183695073E-02;
+    RT3 = (((((((((( 1.97068646590923E-15*Y-4.89419270626800E-14)*Y+
+		   1.136466605916E-13)*Y+7.546203883874E-12)*Y-
+		 9.635646767455E-11)*Y-8.295965491209E-11)*Y+
+	       7.534109114453E-09)*Y+2.699970652707E-07)*Y-
+	     1.42982334217081E-05 )*Y+3.78290946669264E-04 )*Y-
+	   8.03133015084373E-03 )*Y+1.58689469640791E-01;
+    RT4 = (((((((((( 1.33642069941389E-14*Y-1.55850612605745E-13)*Y-
+		   7.522712577474E-13)*Y+3.209520801187E-11)*Y-
+		 2.075594313618E-10)*Y-2.070575894402E-09)*Y+
+	       7.323046997451E-09)*Y+1.851491550417E-06)*Y-
+	     6.37524802411383E-05 )*Y+1.36795464918785E-03 )*Y-
+	   2.42051126993146E-02 )*Y+3.97847167557815E-01;
+    RT5 = ((((((((((-6.07053986130526E-14*Y+1.04447493138843E-12)*Y-
+		   4.286617818951E-13)*Y-2.632066100073E-10)*Y+
+		 4.804518986559E-09)*Y-1.835675889421E-08)*Y-
+	       1.068175391334E-06)*Y+3.292234974141E-05)*Y-
+	     5.94805357558251E-04 )*Y+8.29382168612791E-03 )*Y-
+	   9.93122509049447E-02 )*Y+1.09857804755042E+00;
+    WW1 = (((((((((-9.10338640266542E-15*Y+1.00438927627833E-13)*Y+
+		  7.817349237071E-13)*Y-2.547619474232E-11)*Y+
+		1.479321506529E-10)*Y+1.52314028857627E-09 )*Y+
+	      9.20072040917242E-09 )*Y-2.19427111221848E-06 )*Y+
+	    8.65797782880311E-05 )*Y-2.82718629312875E-03 )*Y+\
+      1.28718310443295E-01;
+    WW2 = ((((((((( 5.52380927618760E-15*Y-6.43424400204124E-14)*Y-
+		  2.358734508092E-13)*Y+8.261326648131E-12)*Y+
+		9.229645304956E-11)*Y-5.68108973828949E-09 )*Y+
+	      1.22477891136278E-07 )*Y-2.11919643127927E-06 )*Y+
+	    4.23605032368922E-05 )*Y-1.14423444576221E-03 )*Y+\
+      5.06607252890186E-02;
+    WW3 = ((((((((( 3.99457454087556E-15*Y-5.11826702824182E-14)*Y-
+		  4.157593182747E-14)*Y+4.214670817758E-12)*Y+
+		6.705582751532E-11)*Y-3.36086411698418E-09 )*Y+
+	      6.07453633298986E-08 )*Y-7.40736211041247E-07 )*Y+
+	    8.84176371665149E-06 )*Y-1.72559275066834E-04 )*Y+\
+      7.16639814253567E-03;
+    WW4 = (((((((((((-2.14649508112234E-18*Y-2.45525846412281E-18)*Y+
+		    6.126212599772E-16)*Y-8.526651626939E-15)*Y+
+		  4.826636065733E-14)*Y-3.39554163649740E-13 )*Y+
+		1.67070784862985E-11 )*Y-4.42671979311163E-10 )*Y+
+	      6.77368055908400E-09 )*Y-7.03520999708859E-08 )*Y+
+	    6.04993294708874E-07 )*Y-7.80555094280483E-06 )*Y+\
+      2.85954806605017E-04;
+    WW5 = ((((((((((((-5.63938733073804E-21*Y+6.92182516324628E-20)*Y-
+		     1.586937691507E-18)*Y+3.357639744582E-17)*Y-
+		   4.810285046442E-16)*Y+5.386312669975E-15)*Y-
+		 6.117895297439E-14)*Y+8.441808227634E-13)*Y-
+	       1.18527596836592E-11 )*Y+1.36296870441445E-10 )*Y-
+	     1.17842611094141E-09 )*Y+7.80430641995926E-09 )*Y-
+	   5.97767417400540E-08 )*Y+1.65186146094969E-06;
+  } else if (X < 40) {
+    WW1 = sqrt(PIE4/X);
+    E = exp(-X);
+    RT1 = ((((((((-1.73363958895356E-06*X+1.19921331441483E-04)*X -
+		 1.59437614121125E-02)*X+1.13467897349442E+00)*X -
+	       4.47216460864586E+01)*X+1.06251216612604E+03)*X -
+	     1.52073917378512E+04)*X+1.20662887111273E+05)*X -
+	   4.07186366852475E+05)*E + R15/(X-R15);
+    RT2 = ((((((((-1.60102542621710E-05*X+1.10331262112395E-03)*X -
+		 1.50043662589017E-01)*X+1.05563640866077E+01)*X -
+	       4.10468817024806E+02)*X+9.62604416506819E+03)*X -
+	     1.35888069838270E+05)*X+1.06107577038340E+06)*X -
+	   3.51190792816119E+06)*E + R25/(X-R25);
+    RT3 = ((((((((-4.48880032128422E-05*X+2.69025112122177E-03)*X -
+		 4.01048115525954E-01)*X+2.78360021977405E+01)*X -
+	       1.04891729356965E+03)*X+2.36985942687423E+04)*X -
+	     3.19504627257548E+05)*X+2.34879693563358E+06)*X -
+	   7.16341568174085E+06)*E + R35/(X-R35);
+    RT4 = ((((((((-6.38526371092582E-05*X-2.29263585792626E-03)*X -
+		 7.65735935499627E-02)*X+9.12692349152792E+00)*X -
+	       2.32077034386717E+02)*X+2.81839578728845E+02)*X +
+	     9.59529683876419E+04)*X-1.77638956809518E+06)*X +
+	   1.02489759645410E+07)*E + R45/(X-R45);
+    RT5 = ((((((((-3.59049364231569E-05*X-2.25963977930044E-02)*X +
+		 1.12594870794668E+00)*X-4.56752462103909E+01)*X +
+	       1.05804526830637E+03)*X-1.16003199605875E+04)*X -
+	     4.07297627297272E+04)*X+2.22215528319857E+06)*X -
+	   1.61196455032613E+07)*E + R55/(X-R55);
+    WW5 = (((((((((-4.61100906133970E-10*X+1.43069932644286E-07)*X -
+		  1.63960915431080E-05)*X+1.15791154612838E-03)*X -
+		5.30573476742071E-02)*X+1.61156533367153E+00)*X -
+	      3.23248143316007E+01)*X+4.12007318109157E+02)*X -
+	    3.02260070158372E+03)*X+9.71575094154768E+03)*E + W55*WW1;
+    WW4 = (((((((((-2.40799435809950E-08*X+8.12621667601546E-06)*X -
+		  9.04491430884113E-04)*X+6.37686375770059E-02)*X -
+		2.96135703135647E+00)*X+9.15142356996330E+01)*X -
+	      1.86971865249111E+03)*X+2.42945528916947E+04)*X -
+	    1.81852473229081E+05)*X+5.96854758661427E+05)*E + W45*WW1;
+    WW3 = (((((((( 1.83574464457207E-05*X-1.54837969489927E-03)*X +
+		 1.18520453711586E-01)*X-6.69649981309161E+00)*X +
+	       2.44789386487321E+02)*X-5.68832664556359E+03)*X +
+	     8.14507604229357E+04)*X-6.55181056671474E+05)*X +
+	   2.26410896607237E+06)*E + W35*WW1;
+    WW2 = (((((((( 2.77778345870650E-05*X-2.22835017655890E-03)*X +
+		 1.61077633475573E-01)*X-8.96743743396132E+00)*X +
+	       3.28062687293374E+02)*X-7.65722701219557E+03)*X +
+	     1.10255055017664E+05)*X-8.92528122219324E+05)*X +
+	   3.10638627744347E+06)*E + W25*WW1;
+    WW1 = WW1-0.01962E+00*E-WW2-WW3-WW4-WW5;
+  } else if (X < 59.0) {
+    WW1 = sqrt(PIE4/X);
+    XXX = pow(X,3);
+    E = XXX*exp(-X);
+    RT1 = (((-2.43758528330205E-02*X+2.07301567989771E+00)*X -
+	    6.45964225381113E+01)*X+7.14160088655470E+02)*E + R15/(X-R15);
+    RT2 = (((-2.28861955413636E-01*X+1.93190784733691E+01)*X -
+	    5.99774730340912E+02)*X+6.61844165304871E+03)*E + R25/(X-R25);
+    RT3 = (((-6.95053039285586E-01*X+5.76874090316016E+01)*X -
+	    1.77704143225520E+03)*X+1.95366082947811E+04)*E + R35/(X-R35);
+    RT4 = (((-1.58072809087018E+00*X+1.27050801091948E+02)*X -
+	    3.86687350914280E+03)*X+4.23024828121420E+04)*E + R45/(X-R45);
+    RT5 = (((-3.33963830405396E+00*X+2.51830424600204E+02)*X -
+	    7.57728527654961E+03)*X+8.21966816595690E+04)*E + R55/(X-R55);
+    E = XXX*E;
+    WW5 = (( 1.35482430510942E-08*X-3.27722199212781E-07)*X +
+	   2.41522703684296E-06)*E + W55*WW1;
+    WW4 = (( 1.23464092261605E-06*X-3.55224564275590E-05)*X +
+	   3.03274662192286E-04)*E + W45*WW1;
+    WW3 = (( 1.34547929260279E-05*X-4.19389884772726E-04)*X +
+	   3.87706687610809E-03)*E + W35*WW1;
+    WW2 = (( 2.09539509123135E-05*X-6.87646614786982E-04)*X +
+	   6.68743788585688E-03)*E + W25*WW1;
+    WW1 = WW1-WW2-WW3-WW4-WW5;
+  } else {
+    WW1 = sqrt(PIE4/X);
+    RT1 = R15/(X-R15);
+    RT2 = R25/(X-R25);
+    RT3 = R35/(X-R35);
+    RT4 = R45/(X-R45);
+    RT5 = R55/(X-R55);
+    WW2 = W25*WW1;
+    WW3 = W35*WW1;
+    WW4 = W45*WW1;
+    WW5 = W55*WW1;
+    WW1 = WW1-WW2-WW3-WW4-WW5;
+  }
+  roots[0] = RT1;
+  weights[0] = WW1;
+  roots[1] = RT2;
+  weights[1] = WW2;
+  roots[2] = RT3;
+  weights[2] = WW3;
+  roots[3] = RT4;
+  weights[3] = WW4;
+  roots[4] = RT5;
+  weights[4] = WW5;
+  return;
+}
+
+static void Root6(int n,double X){
+  printf("crys.c:Root6 not implemented yet\n");
+  return ;
+}
+
+static double Int1d(double t,int ix,int jx,int kx, int lx,
+	     double xi,double xj, double xk,double xl,
+	     double alphai,double alphaj,double alphak,double alphal){
+  double Ix;
+  Recur(t,ix,jx,kx,lx,xi,xj,xk,xl,
+	alphai,alphaj,alphak,alphal);
+  Ix = Shift(ix,jx,kx,lx,xi-xj,xk-xl);
+  return Ix;
+}
+
+static void RecurFactors(double t,double A,double B,
+		  double Px,double Qx,double xi,double xk){
+  /* ABD eqs 12-14 */
+  double fff;
+  fff = t/(A+B);
+  B00 = 0.5*fff;
+  B1 = (1-B*fff)/(2*A);
+  B1p = (1-A*fff)/(2*B);
+  C = (Px-xi) + B*(Qx-Px)*fff;
+  Cp = (Qx-xk) + A*(Px-Qx)*fff;
+  return;
+}
+
+static void RecurFactorsGamess(double t,double A,double B,
+			double Px,double Qx,double xi,double xk){
+  /* Analogous versions taken from Gamess source code */
+  double fff;
+  fff = t/(A+B)/(1+t);
+  B00 = 0.5*fff;
+  B1 = 1/(2*A*(1+t)) + 0.5*fff;
+  B1p = 1/(2*B*(1+t)) + 0.5*fff;
+  C = (Px-xi)/(1+t) + (B*(Qx-xi)+A*(Px-xi))*fff;
+  Cp = (Qx-xk)/(1+t) + (B*(Qx-xk)+A*(Px-xk))*fff;
+  return;
+}
+
+static void Recur(double t, int i, int j, int k, int l,
+	   double xi, double xj, double xk, double xl,
+	   double alphai, double alphaj, double alphak, double alphal){
+  /* Form G(n,m)=I(n,0,m,0) intermediate values for a Rys polynomial */
+  int n,m,a,b;
+  double A,B,Px,Qx;
+
+  n = i+j;
+  m = k+l;
+  A = alphai+alphaj;
+  B = alphak+alphal;
+  Px = (alphai*xi+alphaj*xj)/A;
+  Qx = (alphak*xk+alphal*xl)/B;
+
+  RecurFactorsGamess(t,A,B,Px,Qx,xi,xk);
+
+  /* ABD eq 11. */
+  G[0][0] = M_PI*exp(-alphai*alphaj*pow(xi-xj,2)/(alphai+alphaj)
+		     -alphak*alphal*pow(xk-xl,2)/(alphak+alphal))/sqrt(A*B);
+
+    if (n > 0) G[1][0] = C*G[0][0];  /* ABD eq 15 */
+    if (m > 0) G[0][1] = Cp*G[0][0]; /* ABD eq 16 */
+
+    for (a=2; a<n+1; a++) G[a][0] = B1*(a-1)*G[a-2][0] + C*G[a-1][0];
+    for (b=2; b<m+1; b++) G[0][b] = B1p*(b-1)*G[0][b-2] + Cp*G[0][b-1];
+
+    if ((m==0) || (n==0)) return;
+    
+    for (a=1; a<n+1; a++){
+      G[a][1] = a*B00*G[a-1][0] + Cp*G[a][0];
+      for (b=2; b<m+1; b++)
+	G[a][b] = B1p*(b-1)*G[a][b-2] + a*B00*G[a-1][b-1] + Cp*G[a][b-1];
+    }
+
+    return;
+}
+
+static double Shift(int i, int j, int k, int l, double xij, double xkl){
+  /* Compute and  output I(i,j,k,l) from I(i+j,0,k+l,0) (G) */
+  /*  xij = xi-xj, xkl = xk-xl */
+
+  double ijkl,ijm0;
+  int m,n;
+
+  ijkl = 0;
+  for (m=0; m<l+1; m++){
+    ijm0 = 0;
+    for (n=0; n<j+1; n++) /* I(i,j,m,0)<-I(n,0,m,0)  */
+      ijm0 += binomial(j,n)*pow(xij,j-n)*G[n+i][m+k];
+    ijkl += binomial(l,m)*pow(xkl,l-m)*ijm0; /* I(i,j,k,l)<-I(i,j,m,0) */
+  }
+  return ijkl;
+}
+
+/* Util functions: */
+static double product_center_1D(double alphaa, double xa, 
+			 double alphab, double xb){
+  return (alphaa*xa+alphab*xb)/(alphaa+alphab);
+}
+
+static double dist2(double x1, double y1, double z1, double x2, double y2, double z2){
+  return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);
+}
+
+static int binomial(int a, int b){return fact(a)/(fact(b)*fact(a-b));}
+
+static int fact(int n){
+  if (n <= 1) return 1;
+  return n*fact(n-1);
+}
diff --git a/PW/src/crys.h b/PW/src/crys.h
new file mode 100644
index 000000000..f22af4e37
--- /dev/null
+++ b/PW/src/crys.h
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ This program is part of the PyQuante quantum chemistry program suite.
+
+ Copyright (c) 2004, Richard P. Muller. All Rights Reserved. 
+
+ PyQuante version 1.2 and later is covered by the modified BSD
+ license. Please see the file LICENSE that is part of this
+ distribution. 
+ *
+ **************************************************************************/
+#define MAXROOTS 20
+static double roots[MAXROOTS],weights[MAXROOTS],G[MAXROOTS][MAXROOTS];
+static double B00,B1,B1p,C,Cp;
+
+static double contr_coulomb(int lena,double *aexps,double *acoefs,double *anorms,
+		     double xa,double ya,double za,int la,int ma,int na,
+		     int lenb,double *bexps,double *bcoefs,double *bnorms,
+		     double xb,double yb,double zb,int lb,int mb,int nb,
+		     int lenc,double *cexps,double *ccoefs,double *cnorms,
+		     double xc,double yc,double zc,int lc,int mc,int nc,
+		     int lend,double *dexps,double *dcoefs,double *dnorms,
+		     double xd,double yd,double zd,int ld,int md,int nd);
+
+double coulomb_repulsion(double xa,double ya,double za,double norma,
+			 int la,int ma,int na,double alphaa,
+			 double xb,double yb,double zb,double normb,
+			 int lb,int mb,int nb,double alphab,
+			 double xc,double yc,double zc,double normc,
+			 int lc,int mc,int nc,double alphac,
+			 double xd,double yd,double zd,double normd,
+			 int ld,int md,int nd,double alphad);
+
+static void Roots(int n, double X);
+static void Root123(int n, double X);
+static void Root4(double X);
+static void Root5(double X);
+static void Root6(int n,double X);
+static double Int1d(double t,int ix,int jx,int kx, int lx,
+	     double xi,double xj, double xk,double xl,
+	     double alphai,double alphaj,double alphak,double alphal);
+
+static void RecurFactors(double t,double A,double B,
+		  double Px,double Qx,double xi,double xk);
+
+static void RecurFactorsGamess(double t,double A,double B,
+			double Px,double Qx,double xi,double xk);
+
+static void Recur(double t, int i, int j, int k, int l,
+	   double xi, double xj, double xk, double xl,
+	   double alphai, double alphaj, double alphak, double alphal);
+
+static double Shift(int i, int j, int k, int l, double xij, double xkl);
+
+static double product_center_1D(double alphaa, double xa, 
+				double alphab, double xb);
+static double dist2(double x1, double y1, double z1, 
+		    double x2, double y2, double z2);
+static int binomial(int a, int b);
+static int fact(int n);
diff --git a/PW/src/electrons.f90 b/PW/src/electrons.f90
index 7c1de8a50..100c2b559 100644
--- a/PW/src/electrons.f90
+++ b/PW/src/electrons.f90
@@ -34,6 +34,9 @@ SUBROUTINE electrons()
   USE sic_mod,              ONLY : sic_energy, occ_f2fn, occ_fn2f, save_rhon, sic_first
   USE io_files,             ONLY : iunres, seqopn
   USE ldaU,                 ONLY : eth
+  ! by LSH
+  USE ldaV,                 ONLY : ehubene
+  ! by LSH
   USE extfield,             ONLY : tefield, etotefield
   USE wvfct,                ONLY : nbnd, wg, et
   USE klist,                ONLY : nks
@@ -149,8 +152,10 @@ SUBROUTINE electrons()
            domat = .false.
 ! 
            !
+           ! by LSH
            CALL v_of_rho( rho, rho_core, rhog_core, &
-               ehart, etxc, vtxc, eth, etotefield, charge, v)
+               ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v)
+           ! by LSH
            IF (lrism) CALL rism_calc3d(rho%of_g(:, 1), esol, vsol, v%of_r, tr2)
            IF (okpaw) CALL PAW_potential(rho%bec, ddd_PAW, epaw,etot_cmp_paw)
            CALL using_vrs(1)
@@ -243,8 +248,10 @@ SUBROUTINE electrons()
         ! Recalculate potential because XC functional has changed,
         ! start self-consistency loop on exchange
         !
+        ! by LSH
         CALL v_of_rho( rho, rho_core, rhog_core, &
-             ehart, etxc, vtxc, eth, etotefield, charge, v)
+             ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v)
+        ! by LSH
         etot = etot + etxc + exxen
         !
         IF (lrism) CALL rism_calc3d(rho%of_g(:, 1), esol, vsol, v%of_r, tr2)
@@ -439,6 +446,11 @@ SUBROUTINE electrons_scf ( printout, exxen )
                                    niter_with_fixed_ns, hub_pot_fix, &
                                    nsg, nsgnew, v_nsg, at_sc, neighood, &
                                    ldim_u, is_hubbard_back
+  ! by LSH
+  USE ldaV,                 ONLY : ehubene, ehubene_old, dehubene, &
+                                   lda_plus_v, lacbn0, acbn0_type, &
+                                   pot_fix, write_ehub_uv
+  ! by LSH
   USE extfield,             ONLY : tefield, etotefield, gate, etotgatefield !TB
   USE noncollin_module,     ONLY : noncolin, magtot_nc, i_cons,  bfield, &
                                    lambda, report, domag, nspin_mag, npol
@@ -833,6 +845,107 @@ SUBROUTINE electrons_scf ( printout, exxen )
            ENDIF
            !
         ENDIF
+        ! by LSH WIY
+        IF ( lda_plus_v ) hwf_energy = hwf_energy + ehubene
+        !
+        IF ( lacbn0 ) THEN
+           IF ( first ) THEN
+              dehubene = 1.D0
+           ELSE
+              dehubene = ABS(ehubene - ehubene_old)
+           ENDIF
+        ENDIF
+        !
+        IF ( lda_plus_v )  THEN
+           !
+           ! Write the Hubbard parameters
+           !
+           IF ( iverbosity > 0 .AND. first .AND. .NOT.lacbn0 ) THEN
+              CALL write_ehub_uv
+           ENDIF
+           !
+           ! Keep the Hubbard potential fixed,
+           ! i.e. keep the occupation matrix equal to the ground-state one.
+           ! This is needed for the calculation of Hubbard parameters
+           ! in a self-consistent way.
+           !
+           IF ( pot_fix ) THEN
+              IF ( noncolin ) THEN
+                 IF ( lacbn0 ) THEN
+                    IF ( acbn0_type == 1 ) THEN
+                       rho%na0_nc = rhoin%na0_nc
+                    ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                       rho%ne0_nc = rhoin%ne0_nc
+                    ENDIF
+                 ELSE
+                    rho%ne0_nc = rhoin%ne0_nc
+                 ENDIF
+              ELSE
+                 IF ( lacbn0 ) THEN
+                    IF ( acbn0_type == 1 ) THEN
+                       rho%na0 = rhoin%na0
+                    ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                       rho%ne0 = rhoin%ne0
+                    ENDIF
+                 ELSE
+                    rho%ne0 = rhoin%ne0
+                 ENDIF
+              ENDIF
+           ENDIF
+           !
+           IF ( first .AND. starting_pot == 'atomic' ) THEN
+              !
+!             IF ( noncolin ) THEN
+!                IF ( lacbn0 ) THEN
+!                   IF ( acbn0_type == 1 ) THEN
+!                      rhoin%na0_nc = rho%na0_nc
+!                   ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+!                      rhoin%ne0_nc = rho%ne0_nc
+!                   ENDIF
+!                ELSE
+!                   rhoin%ne0_nc = rho%ne0_nc
+!                ENDIF
+!             ELSE
+!                IF ( lacbn0 ) THEN
+!                   IF ( acbn0_type == 1 ) THEN
+!                      rhoin%na0 = rho%na0
+!                   ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+!                      rhoin%ne0 = rho%ne0
+!                   ENDIF
+!                ELSE
+!                   rhoin%ne0 = rho%ne0
+!                ENDIF
+!             ENDIF
+              !
+              IF ( iter <= niter_with_fixed_ns ) THEN
+                 WRITE( stdout, '(/,5X,"RESET ns to initial values (iter <= mixing_fixed_ns)",/)')
+                 IF ( noncolin ) THEN
+                    IF ( lacbn0 ) THEN
+                       IF ( acbn0_type == 1 ) THEN
+                          rho%na0_nc = rhoin%na0_nc
+                       ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                          rho%ne0_nc = rhoin%ne0_nc
+                       ENDIF
+                    ELSE
+                       rho%ne0_nc = rhoin%ne0_nc
+                    ENDIF
+                 ELSE
+                    IF ( lacbn0 ) THEN
+                       IF ( acbn0_type == 1 ) THEN
+                          rho%na0 = rhoin%na0
+                       ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                          rho%ne0 = rhoin%ne0
+                       ENDIF
+                    ELSE
+                       rho%ne0 = rhoin%ne0
+                    ENDIF
+                 ENDIF
+              ENDIF
+              !
+           ENDIF
+           !
+        ENDIF
+        ! by LSH WIY
         !
         ! ... calculate total and absolute magnetization
         !
@@ -869,6 +982,34 @@ SUBROUTINE electrons_scf ( printout, exxen )
               IF (ALLOCATED(nsg) ) CALL mp_bcast ( nsg, root_pool, inter_pool_comm)
            ENDIF
         ENDIF
+        ! by LSH WIY
+        IF ( lda_plus_v )  THEN
+           ! ... For DFT+U+V, ns and ns_nc are also broadcast inside each pool
+           ! ... to ensure consistency on all processors of all pools
+           ! acbn0_type = 2 or 3 is required without lacbn0.
+           IF ( noncolin ) THEN
+              IF ( lacbn0 ) THEN
+                 IF ( acbn0_type == 1 ) THEN
+                    CALL mp_bcast( rhoin%na0_nc, root_pool, intra_pool_comm )
+                 ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                    CALL mp_bcast( rhoin%ne0_nc, root_pool, intra_pool_comm )
+                 ENDIF
+              ELSE
+                 CALL mp_bcast( rhoin%ne0_nc, root_pool, intra_pool_comm )
+              ENDIF
+           ELSE
+              IF ( lacbn0 ) THEN
+                 IF ( acbn0_type == 1 ) THEN
+                    CALL mp_bcast( rhoin%na0, root_pool, intra_pool_comm )
+                 ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                    CALL mp_bcast( rhoin%ne0, root_pool, intra_pool_comm )
+                 ENDIF
+              ELSE
+                 CALL mp_bcast( rhoin%ne0, root_pool, intra_pool_comm )
+              ENDIF
+           ENDIF
+        ENDIF
+        ! by LSH WIY
         !
         CALL bcast_scf_type( rhoin, root_pool, inter_pool_comm )
         CALL mp_bcast( dr2, root_pool, inter_pool_comm )
@@ -910,8 +1051,12 @@ SUBROUTINE electrons_scf ( printout, exxen )
            ! ... no convergence yet: calculate new potential from mixed
            ! ... charge density (i.e. the new estimate)
            !
+           ! by LSH
+           IF ( lacbn0 ) ehubene_old = ehubene
            CALL v_of_rho( rhoin, rho_core, rhog_core, &
-                          ehart, etxc, vtxc, eth, etotefield, charge, v )
+                          ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+           IF ( lacbn0 ) dehubene = ABS(ehubene - ehubene_old)
+           ! by LSH
            !
            IF (lrism) THEN
               CALL rism_calc3d(rhoin%of_g(:, 1), esol, vsol, v%of_r, dr2)
@@ -950,9 +1095,12 @@ SUBROUTINE electrons_scf ( printout, exxen )
            vnew%of_r(:,:) = v%of_r(:,:)
            !
            IF (lda_plus_u .AND. lda_plus_u_kind.EQ.2) nsg = nsgnew
-           !
+           ! by LSH WIY
+           IF ( lacbn0 ) ehubene_old = ehubene
            CALL v_of_rho( rho,rho_core,rhog_core, &
-                          ehart, etxc, vtxc, eth, etotefield, charge, v )
+                          ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+           IF ( lacbn0 ) dehubene = ABS(ehubene - ehubene_old)
+           ! by LSH WIY
            !
            IF (lrism) THEN
               CALL rism_calc3d(rho%of_g(:, 1), esol, vsol, v%of_r, tr2)
@@ -1033,6 +1181,32 @@ SUBROUTINE electrons_scf ( printout, exxen )
 
      !
      IF ( conv_elec .OR. dmft_updated ) THEN
+        !
+        ! by LSH WIY
+        !
+        ! Recompute the occupation matrix:
+        ! needed when computing U and V in a SCF way
+        !
+        IF ( pot_fix ) THEN
+           IF ( noncolin ) THEN
+              IF ( acbn0_type == 1 ) THEN
+                 !CALL new_ns_a0_nc(rho%na0_nc)
+              ELSEIF ( acbn0_type == 2 ) THEN
+                 CALL new_ns_e0_nc_1(rho%ne0_nc)
+              ELSEIF ( acbn0_type == 3 ) THEN
+                 !CALL new_ns_e0_2_nc(rho%ne0_nc)
+              ENDIF
+           ELSE
+              IF ( acbn0_type == 1 ) THEN
+                 CALL new_ns_a0(rho%na0)
+              ELSEIF ( acbn0_type == 2 ) THEN 
+                 CALL new_ns_e0_1(rho%ne0)
+              ELSEIF ( acbn0_type == 3 ) THEN
+                 CALL new_ns_e0_2(rho%ne0)
+              ENDIF
+           ENDIF
+        ENDIF
+        ! by LSH WIY
         !
         ! iverbosity == 0 for the PW code
         ! iverbosity >  2 for the HP code
@@ -1100,6 +1274,9 @@ SUBROUTINE electrons_scf ( printout, exxen )
      !
      IF (okpaw) etot = etot + epaw
      IF ( lda_plus_u ) etot = etot + eth
+     ! by LSH
+     IF ( lda_plus_v ) etot = etot + ehubene
+     ! by LSH
      !
      IF ( lelfield ) etot = etot + en_el
      ! not sure about the HWF functional in the above case
@@ -1335,6 +1512,9 @@ SUBROUTINE electrons_scf ( printout, exxen )
        REAL(DP) :: delta_e
        REAL(DP) :: delta_e_hub
        INTEGER  :: ir, na1, nt1, na2, nt2, m1, m2, equiv_na2, viz, is, is1, i, j
+       ! by LSH
+       REAL(DP) :: delta_e_hubv
+       ! by LSH
        !
        delta_e = 0._DP
        IF ( nspin==2 ) THEN
@@ -1424,6 +1604,34 @@ SUBROUTINE electrons_scf ( printout, exxen )
             delta_e = delta_e + delta_e_hub
          ENDIF
        ENDIF
+       ! by LSH
+       IF ( lda_plus_v .AND. (.NOT.pot_fix) ) THEN
+          IF ( noncolin ) THEN
+             IF ( lacbn0 ) THEN
+                IF ( acbn0_type == 1 ) THEN
+                   delta_e_hubv = - SUM(rho%na0_nc(:,:,:,:)*v%na0_nc(:,:,:,:))
+                ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                   delta_e_hubv = - SUM(rho%ne0_nc(:,:,:,:,:,:)*v%ne0_nc(:,:,:,:,:,:))
+                ENDIF
+             ELSE
+                delta_e_hubv = - SUM(rho%ne0_nc(:,:,:,:,:,:)*v%ne0_nc(:,:,:,:,:,:))
+             ENDIF
+             delta_e = delta_e + delta_e_hubv
+          ELSE
+             IF ( lacbn0 ) THEN
+                IF ( acbn0_type == 1 ) THEN
+                   delta_e_hubv = - SUM(rho%na0(:,:,:,:)*v%na0(:,:,:,:))
+                ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                   delta_e_hubv = - SUM(rho%ne0(:,:,:,:,:,:)*v%ne0(:,:,:,:,:,:))
+                ENDIF
+             ELSE
+                delta_e_hubv = - SUM(rho%ne0(:,:,:,:,:,:)*v%ne0(:,:,:,:,:,:))
+             ENDIF
+             IF ( nspin == 1 ) delta_e_hubv = 2.d0 * delta_e_hubv
+             delta_e = delta_e + delta_e_hubv
+          ENDIF
+       ENDIF
+       ! by LSH
        !
        IF (okpaw) delta_e = delta_e - SUM( ddd_paw(:,:,:)*rho%bec(:,:,:) )
        !
@@ -1447,6 +1655,9 @@ SUBROUTINE electrons_scf ( printout, exxen )
        IMPLICIT NONE
        REAL(DP) :: delta_escf, delta_escf_hub, rho_dif(2)
        INTEGER  :: ir, na1, nt1, na2, nt2, m1, m2, equiv_na2, viz, is, is1, i, j
+       ! by LSH
+       REAL(DP) :: delta_escf_hubv
+       ! by LSH
        !
        delta_escf=0._dp
        IF ( nspin==2 ) THEN
@@ -1543,6 +1754,34 @@ SUBROUTINE electrons_scf ( printout, exxen )
              delta_escf = delta_escf + delta_escf_hub
           ENDIF
        ENDIF
+       ! by LSH
+       IF ( lda_plus_v .AND. (.NOT.pot_fix) ) THEN
+          IF ( noncolin ) THEN
+             IF ( lacbn0 ) THEN
+                IF ( acbn0_type == 1 ) THEN
+                   delta_escf_hubv = - SUM((rhoin%na0_nc(:,:,:,:)-rho%na0_nc(:,:,:,:))*v%na0_nc(:,:,:,:))
+                ELSEIF (acbn0_type == 2 .OR. acbn0_type == 3) THEN
+                   delta_escf_hubv = - SUM((rhoin%ne0_nc(:,:,:,:,:,:)-rho%ne0_nc(:,:,:,:,:,:))*v%ne0_nc(:,:,:,:,:,:))
+                ENDIF
+             ELSE
+                delta_escf_hubv = - SUM((rhoin%ne0_nc(:,:,:,:,:,:)-rho%ne0_nc(:,:,:,:,:,:))*v%ne0_nc(:,:,:,:,:,:))
+             ENDIF
+             delta_escf = delta_escf + delta_escf_hubv
+          ELSE
+             IF ( lacbn0 ) THEN
+                IF ( acbn0_type == 1 ) THEN
+                   delta_escf_hubv = - SUM((rhoin%na0(:,:,:,:)-rho%na0(:,:,:,:))*v%na0(:,:,:,:))
+                ELSEIF (acbn0_type == 2 .OR. acbn0_type == 3) THEN
+                   delta_escf_hubv = - SUM((rhoin%ne0(:,:,:,:,:,:)-rho%ne0(:,:,:,:,:,:))*v%ne0(:,:,:,:,:,:))
+                ENDIF
+             ELSE
+                delta_escf_hubv = - SUM((rhoin%ne0(:,:,:,:,:,:)-rho%ne0(:,:,:,:,:,:))*v%ne0(:,:,:,:,:,:))
+             ENDIF
+             IF ( nspin == 1 ) delta_escf_hubv = 2.d0 * delta_escf_hubv
+             delta_escf = delta_escf + delta_escf_hubv
+          ENDIF
+       ENDIF
+       ! by LSH
 
        IF ( okpaw ) delta_escf = delta_escf - &
                                  SUM(ddd_paw(:,:,:)*(rhoin%bec(:,:,:)-rho%bec(:,:,:)))
@@ -1659,11 +1898,26 @@ SUBROUTINE electrons_scf ( printout, exxen )
           WRITE( stdout, 9081 ) etot
           IF ( only_paw ) WRITE( stdout, 9085 ) etot+total_core_energy
           IF ( iverbosity > 1 ) WRITE( stdout, 9082 ) hwf_energy
-          IF ( dr2 > eps8 ) THEN
-             WRITE( stdout, 9083 ) dr2
+          ! by LSH WIY
+          IF ( lacbn0 ) THEN
+              IF ( dr2 > eps8 .AND. dehubene > eps8 ) THEN
+                WRITE( stdout, 9083 ) dr2
+                WRITE( stdout, 9086 ) dehubene
+             ELSEIF ( dr2 < eps8 .AND. dehubene > eps8 ) THEN
+                WRITE( stdout, 9084 ) dr2
+                WRITE( stdout, 9086 ) dehubene 
+             ELSEIF ( dr2 < eps8 .AND. dehubene < eps8 ) THEN
+                WRITE( stdout, 9084 ) dr2
+                WRITE( stdout, 9088 ) dehubene 
+             ENDIF
           ELSE
-             WRITE( stdout, 9084 ) dr2
-          END IF
+             IF ( dr2 > eps8 ) THEN
+                WRITE( stdout, 9083 ) dr2
+             ELSE
+                WRITE( stdout, 9084 ) dr2
+             ENDIF
+          ENDIF
+          ! by LSH WIY
           !
           IF ( lgcscf )  WRITE( stdout, 9181 ) tot_charge
           !
@@ -1692,6 +1946,9 @@ SUBROUTINE electrons_scf ( printout, exxen )
           IF ( tefield )            WRITE( stdout, 9064 ) etotefield
           IF ( gate )               WRITE( stdout, 9065 ) etotgatefield
           IF ( lda_plus_u )         WRITE( stdout, 9066 ) eth
+          ! by LSH
+          IF ( lda_plus_v )         WRITE( stdout, 9999 ) ehubene
+          ! by LSH
           IF ( ABS (descf) > eps8 ) WRITE( stdout, 9069 ) descf
           IF ( okpaw ) THEN
             WRITE( stdout, 9067 ) epaw
@@ -1725,11 +1982,26 @@ SUBROUTINE electrons_scf ( printout, exxen )
           !
           WRITE( stdout, 9081 ) etot
           IF ( iverbosity > 1 ) WRITE( stdout, 9082 ) hwf_energy
-          IF ( dr2 > eps8 ) THEN
-             WRITE( stdout, 9083 ) dr2
+          ! by LSH WIY
+          IF ( lacbn0 ) THEN
+             IF ( dr2 > eps8 .AND. dehubene > eps8 ) THEN
+                WRITE( stdout, 9083 ) dr2
+                WRITE( stdout, 9086 ) dehubene
+             ELSEIF ( dr2 < eps8 .AND. dehubene > eps8 ) THEN
+                WRITE( stdout, 9084 ) dr2
+                WRITE( stdout, 9086 ) dehubene 
+             ELSEIF ( dr2 < eps8 .AND. dehubene < eps8 ) THEN
+                WRITE( stdout, 9084 ) dr2
+                WRITE( stdout, 9088 ) dehubene
+             ENDIF 
           ELSE
-             WRITE( stdout, 9084 ) dr2
-          END IF
+             IF ( dr2 > eps8 ) THEN
+                WRITE( stdout, 9083 ) dr2
+             ELSE
+                WRITE( stdout, 9084 ) dr2
+             ENDIF
+          ENDIF 
+          ! by LSH WIY
           IF ( lgauss ) then
              WRITE( stdout, 9070 ) demet
              WRITE( stdout, 9170 ) etot-demet
@@ -1746,11 +2018,26 @@ SUBROUTINE electrons_scf ( printout, exxen )
             WRITE( stdout, 9301 ) eband
           ENDIF
           IF ( iverbosity > 1 ) WRITE( stdout, 9082 ) hwf_energy
-          IF ( dr2 > eps8 ) THEN
-             WRITE( stdout, 9083 ) dr2
+          ! by LSH WIY
+          IF ( lacbn0 ) THEN
+             IF ( dr2 > eps8 .AND. dehubene > eps8 ) THEN
+                WRITE( stdout, 9083 ) dr2
+                WRITE( stdout, 9086 ) dehubene
+             ELSEIF ( dr2 < eps8 .AND. dehubene > eps8 ) THEN
+                WRITE( stdout, 9084 ) dr2
+                WRITE( stdout, 9086 ) dehubene 
+             ELSEIF ( dr2 < eps8 .AND. dehubene < eps8 ) THEN
+                WRITE( stdout, 9084 ) dr2
+                WRITE( stdout, 9088 ) dehubene 
+             ENDIF
           ELSE
-             WRITE( stdout, 9084 ) dr2
-          END IF
+             IF ( dr2 > eps8 ) THEN
+                WRITE( stdout, 9083 ) dr2
+             ELSE
+                WRITE( stdout, 9084 ) dr2
+             ENDIF
+          ENDIF
+          ! by LSH WIY
           !
           IF( lgcscf ) WRITE( stdout, 9182 ) tot_charge, ef*RYTOEV, &
                                              ABS( ef - gcscf_mu ) * RYTOEV
@@ -1794,6 +2081,9 @@ SUBROUTINE electrons_scf ( printout, exxen )
 9064 FORMAT( '     electric field correction =',F17.8,' Ry' )
 9065 FORMAT( '     gate field correction     =',F17.8,' Ry' ) ! TB
 9066 FORMAT( '     Hubbard energy            =',F17.8,' Ry' )
+! by LSH
+9999 FORMAT( '     Extended Hubbard energy   =',F17.8,' Ry' )
+! by LSH
 9067 FORMAT( '     one-center paw contrib.   =',F17.8,' Ry' )
 9068 FORMAT( '      -> PAW hartree energy AE =',F17.8,' Ry' &
             /'      -> PAW hartree energy PS =',F17.8,' Ry' &
@@ -1817,6 +2107,10 @@ SUBROUTINE electrons_scf ( printout, exxen )
 9083 FORMAT( '     estimated scf accuracy    <',0PF17.8,' Ry' )
 9084 FORMAT( '     estimated scf accuracy    <',1PE17.1,' Ry' )
 9085 FORMAT( '     total all-electron energy =',0PF17.6,' Ry' )
+! by LSH WIY
+9086 FORMAT( '     Hubbard accuracy          <',0PF17.8,' Ry' )
+9088 FORMAT( '     Hubbard accuracy          <',1PE17.1,' Ry' )
+! by LSH WIY
 9170 FORMAT( '     internal energy E=F+TS    =',0PF17.8,' Ry' )
 9181 FORMAT(                                                  &
             /'!    total charge of GC-SCF    =',0PF17.8,' e' )
diff --git a/PW/src/force_hub_v.f90 b/PW/src/force_hub_v.f90
new file mode 100644
index 000000000..878204327
--- /dev/null
+++ b/PW/src/force_hub_v.f90
@@ -0,0 +1,2063 @@
+! Following codes are from force_hub.f90 by Iruii Timrov
+!
+! Copyright (C) 2002-2020 Quantum ESPRESSO group
+! This file is distributed under the terms of the
+! GNU General Public License. See the file `License'
+! in the root directory of the present distribution,
+! or http://www.gnu.org/copyleft/gpl.txt .
+!
+!
+!-------------------------------------------------------------------------
+SUBROUTINE force_hub_u ( forceh )
+   !
+   USE kinds,                ONLY : DP 
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp 
+   USE cell_base,            ONLY : at, bg 
+   USE basis,                ONLY : natomwfc 
+   USE symme,                ONLY : symvector 
+   USE io_files,             ONLY : prefix 
+   USE wvfct,                ONLY : nbnd, npwx 
+   USE control_flags,        ONLY : gamma_only 
+   USE lsda_mod,             ONLY : lsda, nspin, current_spin, isk 
+   USE scf,                  ONLY : v, rho 
+   USE mp_pools,             ONLY : inter_pool_comm, intra_pool_comm, me_pool, &
+                                    nproc_pool 
+   USE mp,                   ONLY : mp_sum 
+   USE becmod,               ONLY : bec_type, becp, calbec, allocate_bec_type, &
+                                    deallocate_bec_type 
+   USE uspp,                 ONLY : nkb, vkb, ofsbeta 
+   USE uspp_param,           ONLY : nh 
+   USE wavefunctions,        ONLY : evc 
+   USE klist,                ONLY : nks, xk, ngk, igk_k 
+   USE io_files,             ONLY : nwordwfc, iunwfc 
+   USE buffers,              ONLY : get_buffer 
+   USE ldaU,                 ONLY : Hubbard_projectors 
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, acbn0_type,  & 
+                                    wfcv, nwfcv, ofstv, copy_v_wfc, ehub_v
+   USE uspp_init,            ONLY : init_us_2
+   !
+   IMPLICIT NONE
+   !
+   REAL(DP)                 :: forceh(3,nat)
+   !
+   ! ... local variables
+   !
+   TYPE(bec_type)           :: proj
+
+   COMPLEX(DP), ALLOCATABLE :: spsi(:,:), wfcatom(:,:) 
+   COMPLEX(DP), ALLOCATABLE :: dns(:,:,:,:)
+
+   INTEGER                  :: ics, nnc
+   INTEGER                  :: is, ik, ijkb0, ipol, alpha, npw
+   INTEGER                  :: m1, m2, na1, na2, nt1, nt2
+   INTEGER                  :: n1, n2, n3
+   INTEGER                  :: nb_s, nb_e, mykey
+   !
+   IF ( Hubbard_projectors /= "ortho-atomic" ) CALL errore("force_hub_u", &
+                   " eACBN0 for this Hubbard_projectors type not implemented", 1 )
+   ! even though Hubbard_projectors is ortho-atomic, I consider atomic calculcation in this SUBROUTINE
+   CALL start_clock ('force_hub_u')
+   !
+   ALLOCATE ( dns(ehub_lm_max,ehub_lm_max,nspin,nat) )
+   !
+   ALLOCATE ( spsi(npwx,nbnd) )
+   ALLOCATE ( wfcatom(npwx,natomwfc) )
+   !
+   CALL allocate_bec_type(nkb, nbnd, becp)
+   CALL allocate_bec_type(nwfcv, nbnd, proj)
+   !
+   ! poor-man parallelization over bands
+   ! - if nproc_pool=1     : nb_s=1, nb_e=nbnd, mykey=0
+   ! - if nproc_pool<=nbnd : each processor calculates band nb_s to nb_e; mykey=0
+   ! - if nproc_pool>nbnd  : each processor takes care of band na_s=nb_e;
+   !   mykey labels how many times each band appears (mykey=0 first time etc.)
+   !
+   CALL block_distribute(nbnd, me_pool, nproc_pool, nb_s, nb_e, mykey)
+   !
+   forceh(:,:) = 0.D0
+   !
+   DO ik = 1, nks
+      !
+      IF (lsda) current_spin = isk(ik)
+      npw = ngk(ik)
+      !
+      IF (nks > 1) &
+         CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+      !
+      CALL init_us_2(npw, igk_k(1,ik), xk(1,ik), vkb)
+      CALL calbec(npw, vkb, evc, becp)
+      CALL s_psi(npwx, npw, nbnd, evc, spsi)
+      !
+      ! re-calculate atomic wfc - wfcatom is used here as work space
+      !
+      CALL atomic_wfc(ik, wfcatom)
+      CALL copy_v_wfc(wfcatom)
+      !
+      ! wfcv contains Hubbard-U atomic wavefunctions
+      ! proj=<wfcv|S|evc> - no need to read S*wfcv from buffer
+      !
+      CALL calbec(npw, wfcv, spsi, proj)
+      !
+      ! now we need the first derivative of proj with respect to tau(alpha,ipol)
+      !
+      DO alpha = 1, nat ! forces are calculated for atom alpha ...
+         !
+         ijkb0 = ofsbeta(alpha) ! positions of beta functions for atom alpha
+         !
+         DO ipol = 1, 3  ! forces are calculated for coordinate ipol ...
+            !
+            IF ( gamma_only ) THEN
+               CALL dndtau_gamma_u(proj%r, spsi, alpha, ijkb0, ipol, ik, &
+                                   nb_s, nb_e, mykey, dns)
+            ELSE
+               CALL dndtau_k_u(proj%k, spsi, alpha, ijkb0, ipol, ik, &
+                               nb_s, nb_e, mykey, dns)
+            ENDIF
+            !
+            DO is = 1, nspin
+               !
+               DO na1 = 1, nat
+                  nt1 = ityp(na1)
+                  !
+                  IF ( ehub_lm(nt1) == 0 ) CYCLE
+                  !
+                  DO m1 = 1, ehub_lm(nt1)
+                  DO m2 = 1, ehub_lm(nt1)
+                  !
+                  !
+                     forceh(ipol,alpha) = forceh(ipol,alpha) &
+                                        - DBLE(v%na0(m1,m2,is,na1) &
+                                        * dns(m1,m2,is,na1))
+                  !                      
+                  ENDDO ! m2
+                  ENDDO ! m1
+                  ! 
+               ENDDO ! na1
+               !
+            ENDDO ! is
+            !
+         ENDDO ! ipol
+         !
+      ENDDO ! alpha
+      !
+   ENDDO ! ik
+   !
+   CALL mp_sum(forceh, inter_pool_comm)
+   !
+   CALL deallocate_bec_type(becp)
+   CALL deallocate_bec_type(proj)
+   !
+   DEALLOCATE( dns )
+   DEALLOCATE( wfcatom ) 
+   DEALLOCATE( spsi ) 
+   !
+   IF ( nspin == 1 ) forceh(:,:) = 2.D0 * forceh(:,:)
+   !
+   ! symmetrize
+   !
+   CALL symvector(nat, forceh)
+   !
+#if defined(__DEBUG)
+   WRITE ( 66,'("Hubbard contribution Begin")' )
+   WRITE ( 66,'(3f12.6)' ) forceh(:,:)
+   WRITE ( 66,'("Hubbard contribution End")' )
+#endif
+   !
+   CALL stop_clock('force_hub_u')
+   !
+   RETURN
+   !
+END SUBROUTINE force_hub_u
+!
+!-------------------------------------------------------------------------
+SUBROUTINE dndtau_k_u &
+            (proj, spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dns)
+   !----------------------------------------------------------------------
+   USE kinds,                ONLY : DP
+   USE constants,            ONLY : tpi
+   USE ions_base,            ONLY : nat, ityp
+   USE cell_base,            ONLY : at
+   USE klist,                ONLY : xk
+   USE lsda_mod,             ONLY : nspin, current_spin
+   USE wvfct,                ONLY : nbnd, npwx, npw, wg
+   USE mp_pools,             ONLY : intra_pool_comm, me_pool, nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, nwfcv, ofstv
+
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   COMPLEX(DP), INTENT(IN)  :: proj(nwfcv,nbnd)
+   COMPLEX(DP), INTENT(IN)  :: spsi(npwx,nbnd)
+
+   INTEGER, INTENT(IN)      :: alpha, jkb0
+   INTEGER, INTENT(IN)      :: ipol, ik
+   INTEGER, INTENT(IN)      :: nb_s, nb_e, mykey
+
+   COMPLEX(DP), INTENT(OUT) :: dns(ehub_lm_max,ehub_lm_max,nspin,nat)
+   !
+   ! ... local variables
+   !
+   COMPLEX(DP), ALLOCATABLE :: dproj(:,:)
+
+   INTEGER                  :: ibnd, is
+   INTEGER                  :: m1, m2
+   INTEGER                  :: na1, na2, nt1, nt2
+   !
+   CALL start_clock('dndtau_k_u')
+   !
+   ALLOCATE ( dproj(nwfcv,nb_s:nb_e) )
+   !
+   ! Compute the derivative of the generalized occupation matrices 
+   ! (the quantities dnsg(m1,m2)) of the atomic orbitals. 
+   ! They are complex quantities as well as nsg(m1,m2).
+   !
+   CALL dprojdtau_k_v(spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dproj)
+   !
+   dns(:,:,:,:) = (0.D0, 0.D0)
+   !
+   ! Band parallelization. If each band appears more than once
+   ! compute its contribution only once (i.e. when mykey=0)
+   !
+   IF ( mykey /= 0 ) GO TO 10
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO m1 = 1,  ehub_lm(nt1)
+      DO m2 = m1, ehub_lm(nt1)
+         !
+         DO ibnd = nb_s, nb_e
+            dns(m1,m2,current_spin,na1) = &
+            dns(m1,m2,current_spin,na1) + &
+                                  wg(ibnd,ik) * &
+              DBLE((proj(ofstv(na1)+m2,ibnd)) * &
+             CONJG(dproj(ofstv(na1)+m1,ibnd)) + &
+                  (dproj(ofstv(na1)+m1,ibnd)) * &
+              CONJG(proj(ofstv(na1)+m2,ibnd)))
+         ENDDO ! ibnd
+         !
+      ENDDO ! m1
+      ENDDO ! m2
+      !
+   ENDDO ! na1
+   !
+10 DEALLOCATE ( dproj ) 
+   !
+   CALL mp_sum(dns, intra_pool_comm)
+   !
+   ! In nspin=1 k-point weight wg is normalized to 2 el/band 
+   ! in the whole BZ but we are interested in dnsg of one spin component
+   !
+   IF ( nspin == 1 ) dns = 0.5D0 * dns
+   !
+   ! Impose hermiticity of dns_{m1,m2}
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = m1+1, ehub_lm(nt2)
+         dns(m2,m1,current_spin,na1) = dns(m1,m2,current_spin,na1)
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na1
+   !
+   CALL stop_clock('dndtau_k_u')
+   !
+   RETURN
+   !
+END SUBROUTINE
+!
+!-------------------------------------------------------------------------
+SUBROUTINE dndtau_gamma_u &
+            (rproj, spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dns)
+   !----------------------------------------------------------------------
+   USE kinds,                ONLY : DP
+   USE constants,            ONLY : tpi
+   USE ions_base,            ONLY : nat, ityp
+   USE cell_base,            ONLY : at
+   USE klist,                ONLY : xk
+   USE lsda_mod,             ONLY : nspin, current_spin
+   USE wvfct,                ONLY : nbnd, npwx, npw, wg
+   USE mp_pools,             ONLY : intra_pool_comm, me_pool, nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, nwfcv, ofstv
+
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   COMPLEX(DP), INTENT(IN)  :: rproj(nwfcv,nbnd)
+   COMPLEX(DP), INTENT(IN)  :: spsi(npwx,nbnd)
+
+   INTEGER, INTENT(IN)      :: alpha, jkb0
+   INTEGER, INTENT(IN)      :: ipol, ik
+   INTEGER, INTENT(IN)      :: nb_s, nb_e, mykey
+
+   COMPLEX(DP), INTENT(OUT) :: dns(ehub_lm_max,ehub_lm_max,nspin,nat)
+   !
+   ! ... local variables
+   !
+   COMPLEX(DP), ALLOCATABLE :: dproj(:,:)
+
+   INTEGER                  :: ibnd, is
+   INTEGER                  :: m1, m2
+   INTEGER                  :: na1, na2, nt1, nt2
+   !
+   CALL start_clock('dndtau_gamma_u')
+   !
+   ALLOCATE ( dproj(nwfcv,nb_s:nb_e) )
+   !
+   ! Compute the derivative of the generalized occupation matrices 
+   ! (the quantities dnsg(m1,m2)) of the atomic orbitals. 
+   ! They are complex quantities as well as nsg(m1,m2).
+   !
+   CALL dprojdtau_gamma_v(spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dproj)
+   !
+   dns(:,:,:,:) = (0.D0, 0.D0)
+   !
+   ! Band parallelization. If each band appears more than once
+   ! compute its contribution only once (i.e. when mykey=0)
+   !
+   IF ( mykey /= 0 ) GO TO 10
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO m1 = 1,  ehub_lm(nt1)
+      DO m2 = m1, ehub_lm(nt1)
+         !
+         DO ibnd = nb_s, nb_e
+            dns(m1,m2,current_spin,na1) = &
+            dns(m1,m2,current_spin,na1) + &
+                                  wg(ibnd,ik) * &
+                                  rproj(ofstv(na1)+m2,ibnd) * &
+                                  dproj(ofstv(na1)+m1,ibnd) + &
+                                  dproj(ofstv(na1)+m1,ibnd) * &
+                                  rproj(ofstv(na1)+m2,ibnd)
+         ENDDO ! ibnd
+         !
+      ENDDO ! m1
+      ENDDO ! m2
+      !
+   ENDDO ! na1
+   !
+10 DEALLOCATE ( dproj ) 
+   !
+   CALL mp_sum(dns, intra_pool_comm)
+   !
+   ! In nspin=1 k-point weight wg is normalized to 2 el/band 
+   ! in the whole BZ but we are interested in dnsg of one spin component
+   !
+   IF ( nspin == 1 ) dns = 0.5D0 * dns
+   !
+   ! Impose hermiticity of dns_{m1,m2}
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = m1+1, ehub_lm(nt2)
+         dns(m2,m1,current_spin,na1) = dns(m1,m2,current_spin,na1)
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na1
+   !
+   CALL stop_clock('dndtau_gamma_u')
+   !
+   RETURN
+   !
+END SUBROUTINE
+!
+!-------------------------------------------------------------------------
+SUBROUTINE force_hub_v ( forceh )
+   !----------------------------------------------------------------------
+   ! This routine computes the Hubbard contribution to the force. It gives
+   ! as output the product:
+   ! $$ \frac{dE_\text{hub}}{dn_{ij}^\alpha}\cdot\frac{dn_{ij}^\alpha} 
+   ! {du}(\alpha,\text{ipol}) \ ,$$
+   ! which is the force acting on the atom at \(\text{tau_alpha}\)
+   ! (in the unit cell) along the direction \(\text{ipol}\).
+   ! Note: DFT+U+V force does not support OpenMP.
+   !
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp
+   USE cell_base,            ONLY : at, bg
+   USE basis,                ONLY : natomwfc, wfcatom, swfcatom
+   USE symme,                ONLY : symvector
+   USE io_files,             ONLY : prefix
+   USE wvfct,                ONLY : nbnd, npwx
+   USE control_flags,        ONLY : gamma_only, offload_type
+   USE lsda_mod,             ONLY : lsda, nspin, current_spin, isk
+   USE scf,                  ONLY : v, rho
+   USE mp_pools,             ONLY : inter_pool_comm, intra_pool_comm, me_pool, &
+                                    nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE becmod,               ONLY : bec_type, becp, calbec, allocate_bec_type, &
+                                    deallocate_bec_type
+   USE uspp,                 ONLY : nkb, vkb, ofsbeta, okvan
+   USE uspp_param,           ONLY : nh
+   USE wavefunctions,        ONLY : evc
+   USE klist,                ONLY : nks, xk, ngk, igk_k
+   USE io_files,             ONLY : nwordwfc, iunwfc
+   USE buffers,              ONLY : get_buffer
+   !by WIY
+   USE mp_bands,             ONLY : use_bgrp_in_hpsi, intra_bgrp_comm
+   USE noncollin_module,     ONLY : npol, noncolin
+   USE force_mod,            ONLY : eigenval, eigenvect, overlap_inv
+   USE ldaU,                 ONLY : Hubbard_projectors 
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, ehub_csize,     &
+                                    ehub_nn_vect, ehub_nn_dim, ehub_nnnc, &
+                                    wfcv, nwfcv, ofstv, copy_v_wfc, ehub_v
+   !by WIY
+   USE uspp_init,            ONLY : init_us_2
+   !
+   IMPLICIT NONE
+   !
+   REAL(DP)                 :: forceh(3,nat)
+   !
+   ! ... local variables
+   !
+   TYPE(bec_type)           :: proj     ! proj(nwfcV,nbnd)
+   !COMPLEX(DP), ALLOCATABLE :: proj_nc     ! proj(nwfcV,nbnd)
+   COMPLEX(DP), ALLOCATABLE :: spsi(:,:)
+   COMPLEX(DP), ALLOCATABLE :: dns(:,:,:,:,:,:)
+   ! dns(ehub_lm,ehub_lm,nspin,nat1,nat2,ics)
+   INTEGER                  :: ics, nnc
+   INTEGER                  :: is, is_prime, ik, ijkb0, ipol, alpha, npw, npw_
+   INTEGER                  :: m1, m2, na1, na2, nt1, nt2
+   INTEGER                  :: n1, n2, n3
+   INTEGER                  :: nb_s, nb_e, mykey
+   LOGICAL                  :: save_flag
+   !
+   CALL start_clock ('force_hub_v')
+   !
+   save_flag = use_bgrp_in_hpsi ; use_bgrp_in_hpsi = .false.
+   !
+   IF ( Hubbard_projectors /= "ortho-atomic" ) CALL errore("force_hub_v", &
+                   " forces for this Hubbard_projectors type not implemented", 1 )
+   !
+   !IF (noncolin) CALL errore ("forceh","Noncollinear case is not supported",1)
+   !
+   ALLOCATE ( dns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+   !
+   ALLOCATE ( spsi(npwx*npol,nbnd) )
+   ALLOCATE ( wfcatom(npwx*npol,natomwfc) )
+   !! in case Hubbard_projectors == "ortho-atomic"
+   ALLOCATE ( swfcatom(npwx*npol,natomwfc))
+   ALLOCATE ( eigenval(natomwfc))
+   ALLOCATE ( eigenvect(natomwfc, natomwfc))
+   ALLOCATE ( overlap_inv(natomwfc,natomwfc))
+   !
+   IF (noncolin) THEN
+    ALLOCATE ( proj%k(nwfcv,nbnd))
+    !ALLOCATE ( proj_nc(nwfcv,nbnd))
+    !proj_nc(:,:) = (0.0_DP, 0.0_DP)
+   ELSE
+    CALL allocate_bec_type(nwfcv, nbnd, proj)
+   ENDIF
+   !
+   ! poor-man parallelization over bands
+   ! - if nproc_pool=1     : nb_s=1, nb_e=nbnd, mykey=0
+   ! - if nproc_pool<=nbnd : each processor calculates band nb_s to nb_e; mykey=0
+   ! - if nproc_pool>nbnd  : each processor takes care of band na_s=nb_e;
+   !   mykey labels how many times each band appears (mykey=0 first time etc.)
+   !
+   CALL block_distribute(nbnd, me_pool, nproc_pool, nb_s, nb_e, mykey)
+   !
+   forceh(:,:) = 0.D0
+   !
+   ics = ehub_csize + 1
+   !
+   !
+   ! we start a loop on k points
+   !
+   DO ik = 1, nks
+      !
+      IF (lsda) current_spin = isk(ik)
+      npw = ngk(ik)
+      npw_ = npwx * npol
+      !
+      IF (nks > 1) CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+      !
+      CALL init_us_2(npw, igk_k(1,ik), xk(1,ik), vkb, .TRUE.)
+      ! Compute Spsi = S * psi
+      CALL allocate_bec_type(nkb, nbnd, becp)
+      CALL calbec(offload_type, npw, vkb, evc, becp)
+      CALL s_psi(npwx, npw, nbnd, evc, spsi)
+      !CALL s_psi_acc(npwx, npw, nbnd, evc, spsi)
+      CALL deallocate_bec_type(becp)
+      !
+      ! Set up various quantities, in particular wfcv which
+      ! contains Hubbard-U ortho-atomic wavefunctions (w.o. ultrasoft S)
+      CALL orthowfcv2 (ik)  
+      !
+      ! wfcv contains Hubbard-U atomic wavefunctions
+      ! proj=<wfcv|S|evc> - no need to read S*wfcv from buffer
+      !
+      IF (noncolin) THEN
+         !CALL calbec( offload_type, npw_, wfcv, spsi, proj_nc)
+         CALL ZGEMM ('C', 'N', nwfcv, nbnd, npwx*npol, (1.0_DP, 0.0_DP), wfcv, &
+                    npwx*npol, spsi, npwx*npol, (0.0_DP, 0.0_DP),  proj%k, nwfcv)
+         CALL mp_sum( proj%k( :, 1:nbnd ), intra_bgrp_comm )
+      ELSE
+         CALL calbec( offload_type, npw, wfcv, spsi, proj)
+      ENDIF
+      !
+      ! now we need the first derivative of proj with respect to tau(alpha,ipol)
+      !
+      DO alpha = 1, nat ! forces are calculated for atom alpha ...
+         !
+         ijkb0 = ofsbeta(alpha) ! positions of beta functions for atom alpha
+         !
+         DO ipol = 1, 3  ! forces are calculated for coordinate ipol ...
+            !
+            IF ( gamma_only ) THEN
+               ! .. we don't support gamma calculation
+               !
+               !CALL dndtau_gamma_v(proj%r, spsi, alpha, ijkb0, ipol, ik, &
+               !                    nb_s, nb_e, mykey, dns)
+            ELSE
+               ! 
+               IF (noncolin) THEN
+                  !CALL dndtau_k_v(proj_nc, spsi, alpha, ijkb0, ipol, ik, &
+                  CALL dndtau_k_v(proj%k, spsi, alpha, ijkb0, ipol, ik, &
+                                  nb_s, nb_e, mykey, dns)
+               ELSE
+                  CALL dndtau_k_v(proj%k, spsi, alpha, ijkb0, ipol, ik, &
+                                  nb_s, nb_e, mykey, dns)
+               ENDIF
+               ! 
+            ENDIF
+            !
+            DO is = 1, nspin
+               !
+               DO na1 = 1, nat
+                  nt1 = ityp(na1)
+                  !
+                  IF ( ehub_lm(nt1) == 0 ) CYCLE
+                  !
+               DO na2 = 1, nat
+                  nt2 = ityp(na2)
+                  !
+                  IF ( ehub_lm(nt2) == 0 ) CYCLE
+                  ! 
+                  DO m1 = 1, ehub_lm(nt1)
+                  DO m2 = 1, ehub_lm(nt2)
+                     !
+                     IF (noncolin) THEN
+                        forceh(ipol,alpha) = forceh(ipol,alpha) &
+                                           - DBLE(v%ne0_nc(m1,m2,is,na1,na2,1) &
+                                           * dns(m1,m2,is,na1,na2,1))            
+                     ELSE
+                        forceh(ipol,alpha) = forceh(ipol,alpha) &
+                                           - DBLE(v%ne0(m1,m2,is,na1,na2,1) &
+                                           * dns(m1,m2,is,na1,na2,1))
+                     ENDIF
+                     !
+                  ENDDO ! m2
+                  ENDDO ! m1
+                  !
+               ENDDO ! na2
+               ENDDO ! na1
+               !
+               nnc = 2
+               !
+               DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+               DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+               DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+                  !
+                  IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+                  !
+                  DO na1 = 1, nat
+                     nt1 = ityp(na1)
+                     !
+                     IF ( ehub_lm(nt1) == 0 ) CYCLE
+                     !
+                  DO na2 = 1, nat
+                     nt2 = ityp(na2)
+                     !
+                     IF ( ehub_lm(nt2) == 0 ) CYCLE
+                     !
+                     IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+                     !
+                     DO m1 = 1, ehub_lm(nt1)
+                     DO m2 = 1, ehub_lm(nt2)
+                         !
+                         IF (noncolin) THEN
+                            forceh(ipol,alpha) = forceh(ipol,alpha) &
+                                               - DBLE(v%ne0_nc(m1,m2,is,na1,na2,nnc) &
+                                               * dns(m1,m2,is,na1,na2,nnc))
+                         ELSE
+                            forceh(ipol,alpha) = forceh(ipol,alpha) &
+                                               - DBLE(v%ne0(m1,m2,is,na1,na2,nnc) &
+                                               * dns(m1,m2,is,na1,na2,nnc))
+                         ENDIF
+                     ENDDO ! m2
+                     ENDDO ! m1
+                     !
+                  ENDDO ! na2
+                  ENDDO ! na1
+                  !
+                  IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+                  !
+               ENDDO ! n3
+               ENDDO ! n2
+               ENDDO ! n1
+               !
+            ENDDO ! is
+            !
+         ENDDO ! ipol
+         !
+      ENDDO ! alpha
+      !
+   ENDDO ! ik
+   !
+   CALL mp_sum(forceh, inter_pool_comm)
+   !
+   CALL deallocate_bec_type(proj)
+   !
+   DEALLOCATE( dns )
+   DEALLOCATE( wfcatom ) 
+   DEALLOCATE( spsi )
+   !
+   DEALLOCATE( swfcatom )
+   DEALLOCATE( eigenval )
+   DEALLOCATE( eigenvect )
+   DEALLOCATE( overlap_inv )
+   !
+   IF ( nspin == 1 ) forceh(:,:) = 2.D0 * forceh(:,:)
+   !
+   ! symmetrize
+   !
+   CALL symvector(nat, forceh)
+   !
+#if defined(__DEBUG)
+   WRITE ( 66,'("Hubbard contribution Begin")' )
+   WRITE ( 66,'(3f12.6)' ) forceh(:,:)
+   WRITE ( 66,'("Hubbard contribution End")' )
+#endif
+   use_bgrp_in_hpsi = save_flag
+   !
+   CALL stop_clock('force_hub_v')
+   !
+   RETURN
+   !
+END SUBROUTINE force_hub_v
+!
+!
+SUBROUTINE dndtau_k_v ( proj, spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dns )
+   !-------------------------------------------------------------------------
+   ! This routine computes the derivative of the nsg (generalized occupation
+   ! matrix of the DFT+U+V scheme) with respect to the ionic
+   ! displacement \(u(\text{alpha,ipol})\) used to obtain the generalized 
+   ! Hubbard contribution to the atomic forces.
+   !
+   USE kinds,                ONLY : DP
+   USE constants,            ONLY : tpi
+   USE ions_base,            ONLY : nat, ityp
+   USE cell_base,            ONLY : at
+   USE klist,                ONLY : xk
+   USE lsda_mod,             ONLY : nspin, current_spin
+   USE wvfct,                ONLY : nbnd, npwx, npw, wg
+   USE mp_pools,             ONLY : intra_pool_comm, me_pool, nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE wavefunctions,        ONLY : evc
+   USE uspp,                 ONLY : okvan
+   USE force_mod,            ONLY : doverlap_inv
+   USE basis,                ONLY : natomwfc
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, ehub_csize,     &
+                                    ehub_nn_vect, ehub_nn_dim, ehub_nnnc, &
+                                    wfcv, nwfcv, ofstv, ehub_l, counter_lm
+   USE noncollin_module,     ONLY : npol, noncolin
+   USE symm_base,            ONLY : time_reversal
+
+
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   COMPLEX(DP), INTENT(IN)  :: proj(nwfcv,nbnd)
+   !! projection 
+   COMPLEX(DP), INTENT(IN)  :: spsi(npwx*npol,nbnd)
+   !! \(S|\ \text{evc}\rangle\)
+   INTEGER, INTENT(IN)      :: alpha
+   !! the displaced atom index
+   INTEGER, INTENT(IN)      :: jkb0
+   !! positions of beta functions for atom alpha
+   INTEGER, INTENT(IN)      :: ipol
+   !! the component of displacement
+   INTEGER, INTENT(IN)      :: ik
+   !! k-point index
+   INTEGER, INTENT(IN)      :: nb_s, nb_e, mykey
+   !! For band parallelization, starting and ending band number
+   !! If each band appears more than once,
+   !! compute ist contribution only once (i.e. when mykey=0)
+   COMPLEX(DP), INTENT(OUT) :: dns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+   !! the derivative of the generalized atomic occupations
+   !
+   ! ... local variables
+   !
+   COMPLEX(DP), ALLOCATABLE :: dproj1(:,:,:), dproj_us(:,:)
+   !
+   COMPLEX(DP)              :: kphase
+   !
+   REAL(DP)                 :: arg
+   !
+   INTEGER                  :: ibnd, is1, is2
+   INTEGER                  :: ics, nnc
+   INTEGER                  :: m1, m2
+   INTEGER                  :: na1, na2, nt1, nt2
+   INTEGER                  :: n1, n2, n3
+   INTEGER                  :: nnnc_count
+   !
+   CALL start_clock('dndtau_k_v')
+   !
+   ALLOCATE ( dproj1(nwfcv,nb_s:nb_e,nat) )
+   IF (okvan) ALLOCATE ( dproj_us(nwfcv,nb_s:nb_e) )
+   !
+   ! Compute the derivative of the generalized occupation matrices 
+   ! (the quantities dns(m1,m2)) of the atomic orbitals. 
+   ! They are complex quantities as well as ns(m1,m2).
+   !
+   dns(:,:,:,:,:,:) = (0.0_DP, 0.0_DP)
+   !
+   ! Band parallelization. If each band appears more than once
+   ! compute its contribution only once (i.e. when mykey=0)
+   !
+   nnc = 1
+   ics = ehub_csize + 1
+   !
+   !
+   ! At this ik, need to compute the phase for each atom because the overlap
+   ! matrix has the derivative of ortho-atomic orbital in na2 (dproj2).
+   !! For the calculation of phase foctor, I will decide later to make new 
+   !! subroutine or in the for-loop.
+   ! 
+   ! Compute the USPP contribution to dproj1:
+   ! <\phi^{at}_{I,m1}|dS/du(alpha,ipol)|\psi_{k,v,s}>
+   !
+   IF (okvan) THEN
+    CALL matrix_element_of_dSdtau_v (alpha, ipol, ik, jkb0, nwfcv, wfcv, nbnd, &
+                        evc, dproj_us, nb_s, nb_e, mykey, .false.)
+   ENDIF
+   !
+   ! In the 'ortho-atomic' case calculate d[(O^{-1/2})^T]
+   ALLOCATE ( doverlap_inv(natomwfc,natomwfc) )
+   CALL calc_doverlap_inv_v (alpha, ipol, ik, jkb0)
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) > 0 ) THEN
+         CALL dprojdtau_k_v (spsi, alpha, na1, jkb0, ipol, ik, nb_s, nb_e, mykey, dproj1)
+         IF (okvan) THEN
+         dproj1(:,:,na1) = dproj1(:,:,na1) + dproj_us(:,:)
+         ENDIF
+      ENDIF !ehub_lm(nt1)
+      !
+   ENDDO !na1
+   !
+   ! Band parallelization. If each band appears more then once
+   ! compute its contribution only once (i.e. when mykey=0)
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = 1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      IF (mykey==0) THEN
+         ! 
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            DO ibnd = nb_s, nb_e
+               !
+               IF (noncolin) THEN
+                  !
+                  DO is1 = 1, npol
+                  DO is2 = 1, npol
+                     dns(m1,m2,npol*(is1-1)+is2,na1,na2,1) = &
+                     dns(m1,m2,npol*(is1-1)+is2,na1,na2,1) + &
+                     wg(ibnd,ik) * &
+                dcmplx(proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) &
+             * CONJG(dproj1(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd,na1)) + &
+                     dproj1(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd,na2) &
+             * CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd)))
+                  ENDDO
+                  ENDDO
+                  !
+               ELSE
+                  dns(m1,m2,current_spin,na1,na2,1) = &
+                  dns(m1,m2,current_spin,na1,na2,1) + &
+                   wg(ibnd,ik) *   DBLE( &
+                  (proj(ofstv(na2)+m2,ibnd) * CONJG(dproj1(ofstv(na1)+m1,ibnd,na1)) + &
+                   dproj1(ofstv(na2)+m2,ibnd,na2) * CONJG(proj(ofstv(na1)+m1,ibnd))))
+               ENDIF
+            ENDDO ! ibnd
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDIF ! mykey
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      arg = tpi * (                                              &
+       xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+       xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+       xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+      !
+      kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         IF ( mykey == 0 ) THEN
+            !
+            DO m1 = 1, ehub_lm(nt1)
+            DO m2 = 1, ehub_lm(nt2)
+               !
+               DO ibnd = nb_s, nb_e
+                  !
+                  IF (noncolin) THEN
+                     !
+                     DO is1 = 1, npol
+                     DO is2 = 1, npol
+                        dns(m1,m2,npol*(is1-1)+is2,na1,na2,nnc) = &
+                        dns(m1,m2,npol*(is1-1)+is2,na1,na2,nnc) + &
+                        wg(ibnd,ik) * dcmplx( kphase *( &
+                        proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) &
+                * CONJG(dproj1(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd,na1)) + &
+                        dproj1(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd,na2) &
+                * CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))))
+                     ENDDO
+                     ENDDO
+                  ELSE
+                     dns(m1,m2,current_spin,na1,na2,nnc) = &
+                     dns(m1,m2,current_spin,na1,na2,nnc) + &
+                       wg(ibnd,ik) * DBLE( kphase * &
+                    (proj(ofstv(na2)+m2,ibnd) * CONJG(dproj1(ofstv(na1)+m1,ibnd,na1)) + &
+                     dproj1(ofstv(na2)+m2,ibnd,na2) * CONJG(proj(ofstv(na1)+m1,ibnd))))
+                  ENDIF
+                  !
+               ENDDO ! ibnd
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            !
+         ENDIF ! mykey
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+   DEALLOCATE ( dproj1 ) 
+   IF (ALLOCATED(doverlap_inv)) DEALLOCATE ( doverlap_inv )
+   IF (okvan)     DEALLOCATE ( dproj_us )
+   !
+   CALL mp_sum(dns, intra_pool_comm)   
+   !
+   ! In nspin=1 k-point weight wg is normalized to 2 el/band 
+   ! in the whole BZ but we are interested in dnsg of one spin component
+   !
+   !DO is2 = 1, ehub_nnnc
+   !  DO na1 = 1, nat
+   !  DO na2 = 1, nat
+   !    nt1 = ityp(na1)
+   !    nt2 = ityp(na2)
+   !    DO m1 = 1, ehub_lm(nt1)
+   !    DO m2 = 1, ehub_lm(nt2)
+   !      IF(noncolin) THEN
+   !        DO is1 = 1, nspin
+   !         WRITE(11,'(6I4, f17.12)') m1, m2, is1, na1, na2, is2, ABS(dns(m1,m2,is1,na1,na2,is2))
+   !        ENDDO
+   !      ELSE
+   !         WRITE(11,'(6I4, f17.12)') m1, m2, current_spin, na1, na2, is2, ABS(dns(m1,m2,current_spin,na1,na2,is2))
+   !      ENDIF
+   !    ENDDO
+   !    ENDDO
+   !  ENDDO
+   !  ENDDO
+   !ENDDO
+   ! temp
+   IF ( nspin == 1 ) dns = 0.5D0 * dns
+   !
+   ! Impose hermiticity of dns_{m1,m2}
+   !
+!   DO nnnc_count = 1, ehub_nnnc
+!    DO na1 = 1, nat
+!       nt1 = ityp(na1)
+!       !
+!       IF ( ehub_lm(nt1) == 0 ) CYCLE
+!       !
+!    DO na2 = na1, nat
+!       nt2 = ityp(na2)
+!       !
+!       IF ( ehub_lm(nt2) == 0 ) CYCLE
+!       !
+!       IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+!       !
+!       DO m1 = 1, ehub_lm(nt1)
+!       DO m2 = 1, ehub_lm(nt2)
+!          dns(m1,m2,current_spin,na1,na2,nnnc_count) = (dns(m1,m2,current_spin,na1,na2,nnnc_count)   + &
+!                                         CONJG(dns(m2,m1,current_spin,na2,na1,nnnc_count))) * 0.5D0
+!          dns(m2,m1,current_spin,na2,na1,nnnc_count) = &
+!                                         CONJG(dns(m1,m2,current_spin,na1,na2,nnnc_count))
+!       ENDDO ! m2
+!       ENDDO ! m1
+!       !
+!    ENDDO ! na2
+!    ENDDO ! na1
+!   ENDDO ! nnnc_count
+   !
+   CALL stop_clock('dndtau_k_v')
+   !
+   RETURN
+   !
+END SUBROUTINE dndtau_k_v
+!
+!
+SUBROUTINE dndtau_gamma_v (rproj, spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dns)
+   !--------------------------------------------------------------------------
+   ! This routine computes the derivative of the nsg (generalized occupation
+   ! matrix of the DFT+U+V scheme) with respect to the ionic
+   ! displacement \(u(\text{alpha,ipol})\) used to obtain the generalized 
+   ! Hubbard contribution to the atomic forces.
+   !
+   USE kinds,                ONLY : DP
+   USE constants,            ONLY : tpi
+   USE ions_base,            ONLY : nat, ityp
+   USE cell_base,            ONLY : at
+   USE klist,                ONLY : xk
+   USE lsda_mod,             ONLY : nspin, current_spin
+   USE wvfct,                ONLY : nbnd, npwx, npw, wg
+   USE mp_pools,             ONLY : intra_pool_comm, me_pool, nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, ehub_csize,     &
+                                    ehub_nn_vect, ehub_nn_dim, ehub_nnnc, &
+                                    nwfcv, ofstv
+
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   COMPLEX(DP), INTENT(IN)  :: spsi(npwx,nbnd)
+
+   REAL(DP), INTENT(IN)     :: rproj(nwfcv,nbnd)
+
+   INTEGER, INTENT(IN)      :: alpha, jkb0
+   INTEGER, INTENT(IN)      :: ipol, ik
+   INTEGER, INTENT(IN)      :: nb_s, nb_e, mykey
+
+   COMPLEX(DP), INTENT(OUT) :: dns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+   !
+   ! ... local variables
+   !
+   REAL(DP), ALLOCATABLE    :: dproj(:,:)
+
+   COMPLEX(DP)              :: kphase
+
+   REAL(DP)                 :: arg
+
+   INTEGER                  :: ibnd, is
+   INTEGER                  :: ics, nnc
+   INTEGER                  :: m1, m2
+   INTEGER                  :: na1, na2, nt1, nt2
+   INTEGER                  :: n1, n2, n3
+   !
+   CALL start_clock( 'dndtau_v' )
+   !
+   ALLOCATE ( dproj(nwfcv,nb_s:nb_e) )
+   !
+   ! Compute the derivative of the generalized occupation matrices
+   ! (the quantities dnsg(m1,m2)) of the atomic orbitals.
+   ! They are complex quantities as well as nsg(m1,m2).
+   !
+   CALL dprojdtau_gamma_v (spsi, alpha, jkb0, ipol, ik, nb_s, nb_e, mykey, dproj)
+   !
+   dns(:,:,:,:,:,:) = (0.D0, 0.D0)
+   !
+   ! Band parallelization. If each band appears more than once
+   ! compute its contribution only once (i.e. when mykey=0)
+   !
+   IF ( mykey /= 0 ) GO TO 10
+   !
+   ics = ehub_csize + 1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = 1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         !
+         DO ibnd = nb_s, nb_e
+            dns(m1,m2,current_spin,na1,na2,1) = &
+            dns(m1,m2,current_spin,na1,na2,1) + &
+                                  wg(ibnd,ik) * &
+                   (rproj(ofstv(na2)+m2,ibnd) * &
+                    dproj(ofstv(na1)+m1,ibnd) + &
+                    dproj(ofstv(na2)+m2,ibnd) * &
+                    rproj(ofstv(na1)+m1,ibnd))
+         ENDDO ! ibnd
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      arg = tpi * (                                              &
+       xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+       xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+       xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+      !
+      kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            DO ibnd = nb_s, nb_e
+               dns(m1,m2,current_spin,na1,na2,nnc) = &
+               dns(m1,m2,current_spin,na1,na2,nnc) + &
+                          DBLE(kphase)*wg(ibnd,ik) * &
+                        (rproj(ofstv(na2)+m2,ibnd) * &
+                         dproj(ofstv(na1)+m1,ibnd) + &
+                         dproj(ofstv(na2)+m2,ibnd) * &
+                         rproj(ofstv(na1)+m1,ibnd))
+            ENDDO ! ibnd
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+10 DEALLOCATE ( dproj )
+   !
+   CALL mp_sum(dns, intra_pool_comm)
+   !
+   ! In nspin=1 k-point weight wg is normalized to 2 el/band 
+   ! in the whole BZ but we are interested in dnsg of one spin component
+   !
+   IF ( nspin == 1 ) dns = 0.5D0 * dns
+   !
+   ! Impose hermiticity of dns_{m1,m2}
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = na1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         dns(m1,m2,current_spin,na1,na2,1) = (dns(m1,m2,current_spin,na1,na2,1)   + &
+                                        CONJG(dns(m2,m1,current_spin,na2,na1,1))) * 0.5D0
+         dns(m1,m2,current_spin,na1,na2,1) =                                        &
+                                        CONJG(dns(m2,m1,current_spin,na2,na1,1))
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   CALL stop_clock('dndtau_v')
+   !
+   RETURN
+   !
+END SUBROUTINE dndtau_gamma_v
+!
+SUBROUTINE dprojdtau_k_v(spsi, alpha, na, ijkb0, ipol, ik, nb_s, nb_e, mykey, dproj)
+   !-----------------------------------------------------------------------------
+   ! This routine computes the first derivative of the projection
+   ! \(\langle\phi^{at}_{I,m1}|S|\psi_{k,v,s}\rangle\) with respect to 
+   ! the atomic displacement \(u(\text{alpha,ipol})\). We remind that:
+   ! $$ \text{ns}_{I,s,m1,m2} = \sum_{k,v}
+   !    f_{kv} \langle\phi^{at}_{I,m1}|S|\psi_{k,v,s}\rangle
+   !           \langle\psi_{k,v,s}|S|\phi^{at}_{I,m2}\rangle $$
+   !
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp
+   USE cell_base,            ONLY : tpiba
+   USE gvect,                ONLY : g
+   USE klist,                ONLY : xk, ngk, igk_k
+   USE wvfct,                ONLY : nbnd, npwx, wg
+   USE uspp,                 ONLY : nkb, vkb, okvan
+   USE uspp_param,           ONLY : nh
+   USE wavefunctions,        ONLY : evc
+   USE becmod,               ONLY : bec_type, becp, calbec, allocate_bec_type, &
+                                    deallocate_bec_type 
+   USE mp_bands,             ONLY : intra_bgrp_comm
+   USE mp,                   ONLY : mp_sum
+   USE basis,                ONLY : natomwfc, wfcatom, swfcatom
+   USE force_mod,            ONLY : eigenval, eigenvect, overlap_inv, doverlap_inv
+   USE ldaV,                 ONLY : counter_lm, ehub_l, ehub_lm, wfcv, nwfcv, ofst, ofstv
+   ! ofst: index of atomic wfcs used as projectors
+   ! ofstv: For each atom, index of its projectors (among projectors only)
+   USE noncollin_module,     ONLY : npol, noncolin
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   COMPLEX(DP), INTENT(IN)   :: spsi(npwx*npol,nbnd)
+   !! \(S\ |\text{evc}\rangle\)
+   INTEGER, INTENT(IN)       :: alpha
+   !! the displaced atom
+   INTEGER, INTENT(IN)       :: na
+   !! the atom for which the force is computed
+   INTEGER, INTENT(IN)       :: ijkb0
+   !! the postion of beta functions for atom alpha
+   INTEGER, INTENT(IN)       :: ipol
+   !! the component of displacement
+   INTEGER, INTENT(IN)       :: ik
+   !! k-point index
+   INTEGER, INTENT(IN)       :: nb_s
+   !! starting band number (for band parallelization)
+   INTEGER, INTENT(IN)       :: nb_e
+   !! ending band number (for band parallelization)
+   INTEGER, INTENT(IN)       :: mykey
+   !! If each band appears more than once, compute
+   !! its contribution only once (i.e. when \(\text{mykey}=0)\)
+   COMPLEX(DP), INTENT(OUT)  :: dproj(nwfcv,nb_s:nb_e,na)
+   !! derivative of projection
+   !
+   ! ... local variables
+   !
+   REAL(DP)                  :: gvec, xki
+   INTEGER                   :: nh_nt
+
+   INTEGER                   :: npw, npw_, nt, ig, m1, m2, ibnd, m_start, m_end
+   ! need to set local variable properly to calculate dproj
+
+   COMPLEX (DP), ALLOCATABLE :: dproj0(:,:), dwfc(:,:)
+   !! dproj0(:,:)   ! derivative of the projector    
+   !! dwfc(:,:)     ! the derivative of the ortho-atomic wavefunction 
+   !
+   CALL start_clock('dprojdtau')
+   !
+   nt = ityp(na)
+   npw = ngk(ik)
+   npw_ = npwx*npol
+   xki = xk(ipol,ik)
+   nh_nt = nh(nt)
+   !
+   !$acc kernels
+   dproj(:,:,na) = (0.d0, 0.d0)
+   !$acc end kernels
+   !
+   !!! ORTHO-ATOMIC CASE !!!
+   !
+   ! Compute the derivative of the ortho-atomic wfc 'na' when displacing atom
+   ! 'alpha'.
+   ! Note, this derivative is different from zero not only when na = alpha but
+   ! also when na /= alpha, i.e. when we displace a non-Hubbard atom this will
+   ! give a non-zero contribution to the derivative of the ortho-atomic wfc na.
+   ! This is so due to the definition of the ortho-atomic wfc:
+   ! \phi_ortho_I = \sum_J O^{-1/2}_JI \phi_J
+   ! Note: parallelization here is over plane waves, not over bands!
+   !
+   ALLOCATE( dwfc(npwx*npol,ehub_lm(nt)*npol) )
+   !$acc data create(dwfc) present_or_copyin(wfcatom,overlap_inv)
+   !
+   !$acc kernels
+   dwfc(:,:) = (0.d0,0.d0)
+   !$acc end kernels
+   !
+   ! Determine how many atomic wavefunctions there are for atom 'alpha' and
+   ! dertermine their position in the list of all atomic wavefunctions of all
+   ! atoms
+   CALL natomwfc_per_atom_v(alpha, m_start, m_end)
+   !
+   ! 1. Derivative of the atomic wavefunctions (the only one which is different
+   ! from zero)) times O^-0.5 transposed.
+   ! NOTE: overlap_inv is already transposed (it is O^{-1/2}_JI),
+   !       hence we obtain \sum_J O^{-1/2}_JI \dphi_J/d\tau(alpha,ipol)
+   DO ig = 1, npw
+      !
+      ! DFT+U: In the expression of dwfc we don't need (k+G) but just G; k always
+      ! multiplies the underived quantity and gives an opposite contribution
+      ! in c.c. term because the sign of the imaginary unit.
+      ! DFT+U+V: the k-point coordinate is needed, i.e. (k+G) instead of just G
+      !
+      gvec = (g(ipol,igk_k(ig,ik)) + xk(ipol,ik)) * tpiba 
+      DO m1 = 1, ehub_lm(nt)*npol
+         DO m2 = m_start, m_end
+         dwfc(ig,m1) = dwfc(ig,m1) + (0.D0,-1.D0) * gvec * &
+                    overlap_inv(ofst(na)+m1,m2) *  wfcatom(ig,m2)
+         IF (noncolin) THEN
+         dwfc(ig+npwx,m1) = dwfc(ig+npwx,m1) + (0.D0,-1.D0) * gvec * &
+                    overlap_inv(ofst(na)+m1,m2) *  wfcatom(ig+npwx,m2)
+         ENDIF
+         ENDDO !m2
+      ENDDO !m1
+      !
+   ENDDO !ig
+   !
+   ! 2. Contribution due to the derivative of (O^{-1/2})_JI which is multiplied
+   ! by atomic wavefunctions
+   !
+   ! Now compute \sum_J dO^{-1/2}_JI/d\tau(alpha,ipol) \phi_J
+   ! and add it to another term (see above)
+   ! Note, doverlap_inv is d(O^{-1/2}) not transposed. The transposition
+   ! of d(O^{-1/2}) is taken into account via a proper usage of the order
+   ! of indices in doverlap_inv:
+   ! dwfc(ig,m1) = dwfc(ig,m1) + wfcatom(ig,m2) * doverlap_inv(m2,ofst(na)+m1)
+   ! where m1=1, ehub_lm(nt); m2=1,natomwfc, ig=1,npw
+   !
+   !DO ig = 1, npw
+   !   DO m1 = 1, ehub_lm(nt)
+   !      DO m2 = 1, natomwfc
+   !         dwfc(ig,m1) = dwfc(ig,m1) + &
+   !             doverlap_inv(ofst(na)+m1,m2) * wfcatom(ig,m2)
+   !      ENDDO !m2
+   !   ENDDO !m1
+   !ENDDO !ig
+   !$acc host_data use_device(wfcatom,doverlap_inv,dwfc)
+   CALL MYZGEMM( 'N','N', npwx*npol, ehub_lm(nt)*npol, natomwfc, (1.d0,0.d0), &
+                 wfcatom, npwx*npol, doverlap_inv(:,ofst(na)+1:ofst(na)+ehub_lm(nt)*npol), &
+                 natomwfc, (1.d0,0.d0), dwfc, npwx*npol )
+   !$acc end host_data
+   !   CALL ZGEMM('N','N', npw, ehub_lm(nt), natomwfc, (1.d0,0.d0), &
+   !               wfcatom, npwx, doverlap_inv(:,ofst(na)+1:ofst(na)+ehub_lm(nt)), &
+   !               natomwfc, (1.d0,0.d0), dwfc, npwx)
+   !
+   ! 3. Final step: compute dproj0 = <dwfc|spsi>
+   !
+   ALLOCATE ( dproj0(ehub_lm(nt)*npol,nbnd) )
+   dproj0(:,:) = (0.0d0, 0.0d0)
+   !$acc data create(dproj0)
+   !
+   !$acc host_data use_device(dwfc,spsi,dproj0)
+   CALL MYZGEMM( 'C','N',ehub_lm(nt)*npol, nbnd, npwx*npol, (1.d0,0.d0), &
+                 dwfc, npwx*npol, spsi, npwx*npol,  (0.d0,0.d0), &
+                 dproj0, ehub_lm(nt)*npol )         
+   !IF (noncolin) THEN
+   !   CALL ZGEMM('C','N',ehub_lm(nt), nbnd, npw_, (1.D0,0.D0), &
+   !           dwfc, npw_, spsi, npw_, (0.D0,0.D0), dproj0, &
+   !           ehub_lm(nt)) 
+   !ELSE
+   !   CALL ZGEMM('C','N',ehub_lm(nt), nbnd, npw, (1.D0,0.D0), &
+   !           dwfc, npwx, spsi, npwx, (0.D0,0.D0), dproj0, &
+   !           ehub_lm(nt)) 
+   !ENDIF
+   !
+   CALL mp_sum( dproj0, intra_bgrp_comm )
+   !$acc end host_data
+   !
+   ! copy to dproj results for the bands treated by this processor
+   !
+   IF (mykey==0) THEN
+      DO ibnd = nb_s, nb_e
+         DO m1 = 1, ehub_lm(nt)*npol
+            dproj(ofstv(na)+m1,ibnd,na) = dproj0(m1,ibnd)
+            !IF (noncolin) dproj(ofstv(na)+m1+ehub_lm(nt),ibnd,na) = dproj0(m1+ehub_lm(nt),ibnd)
+         ENDDO
+      ENDDO 
+   ENDIF
+   !
+   !$acc end data
+   !$acc end data
+   DEALLOCATE ( dproj0 ) 
+   DEALLOCATE ( dwfc   )
+   !
+   CALL stop_clock('dprojdtau')
+   !
+   RETURN
+   !
+END SUBROUTINE dprojdtau_k_v
+!
+!------------------------------------------------------------------------
+SUBROUTINE natomwfc_per_atom_v(alpha, m_start, m_end)
+   !-----------------------------------------------------------------------
+   !! This routine determines the starting (m_start) and the last (m_end)
+   !! index for all atomic wavefunctions of a given atom 'alpha'
+   !! when referring to the total list of all atomic wavefunctions of all atoms.
+   !
+   USE ions_base,    ONLY : nat, ityp
+   USE uspp_param,   ONLY : upf
+   USE io_global,    ONLY : stdout
+   USE noncollin_module, ONLY : noncolin
+   USE kinds,            ONLY : DP
+   !
+   IMPLICIT NONE
+   !
+   INTEGER, INTENT(IN)  :: alpha
+   INTEGER, INTENT(OUT) :: m_start
+   INTEGER, INTENT(OUT) :: m_end
+   !
+   ! Local variables
+   !
+   INTEGER :: counter, l, na, nt, nb
+   !
+   counter = 0
+   m_start = 0
+   m_end   = 0
+   DO na = 1, nat
+      IF (na == alpha) m_start = counter + 1
+      nt = ityp(na)
+      DO nb = 1, upf(nt)%nwfc
+         IF (upf(nt)%oc(nb) >= 0.d0) THEN
+            l = upf(nt)%lchi(nb)
+            !
+            IF (noncolin) THEN
+               IF (upf(nt)%has_so) THEN
+                  ! j = l-1/2, degeneracy 2*l
+                  counter = counter + 2*l
+                  ! j = l+1/2, degeneracy 2*l+2
+                  IF (ABS( upf(nt)%jchi(nb)-l-0.5_DP ) < 1.D-6) &
+                  & counter = counter + 2
+                  !
+               ELSE
+                  counter = counter + 2*( 2*l + 1 )
+               ENDIF
+            ELSE
+                counter = counter + 2*l + 1
+            ENDIF
+         ENDIF
+      ENDDO
+      IF (na == alpha) THEN
+         m_end = counter
+         GO TO 11
+      ENDIF
+   ENDDO
+   !
+11 CONTINUE
+   !
+   IF (m_start==0 .OR. m_end==0) CALL errore("natomwfc_per_atom_v", &
+                                   "m_start=0 or m_end=0",1)
+   IF (m_start > m_end) CALL errore("natomwfc_per_atom_v", &
+                                   "m_start > m_end",1)
+   !
+   RETURN
+   !
+END SUBROUTINE natomwfc_per_atom_v
+! by WIY
+! by WIY
+!--------------------------------------------------------------------
+SUBROUTINE calc_doverlap_inv_v (alpha, ipol, ik, ijkb0)
+   !-----------------------------------------------------------------
+   ! This routine computes the derivative of O^{-1/2} transposed 
+   !
+   USE kinds,          ONLY : DP
+   USE cell_base,      ONLY : tpiba
+   USE gvect,          ONLY : g
+   USE uspp,           ONLY : okvan
+   USE klist,          ONLY : xk, ngk, igk_k
+   USE basis,          ONLY : natomwfc, wfcatom, swfcatom
+   USE force_mod,      ONLY : eigenval, eigenvect, overlap_inv, doverlap_inv
+   USE mp_bands,       ONLY : intra_bgrp_comm
+   USE mp,             ONLY : mp_sum
+   USE ldaU,           ONLY : Hubbard_projectors
+   USE noncollin_module, ONLY : npol, noncolin
+   USE wvfct,            ONLY : nbnd, npwx, wg
+   !
+   IMPLICIT NONE
+   !
+   INTEGER, INTENT(IN) :: alpha
+   !! the displaced atom
+   INTEGER, INTENT(IN) :: ipol
+   !! the component of displacement
+   INTEGER, INTENT(IN) :: ik
+   !! k-point index
+   INTEGER, INTENT(IN) :: ijkb0
+   !! position of beta functions for atom alpha
+   !
+   INTEGER :: ig, m1, m2, npw, m_start, m_end
+   REAL(DP) :: gvec, xki
+   COMPLEX(DP) :: temp
+   COMPLEX(DP), ALLOCATABLE :: doverlap(:,:), doverlap_us(:,:)
+   !! derivative of the overlap matrix  
+   !
+   CALL start_clock( 'calc_doverlap_inv_v' )
+   !
+   IF (Hubbard_projectors.NE."ortho-atomic") RETURN
+   !
+   xki = xk(ipol,ik)
+   !
+   ALLOCATE (doverlap(natomwfc,natomwfc))
+   !
+   !$acc data present_or_copyin(wfcatom,swfcatom) 
+   !
+   !$acc kernels
+   doverlap_inv(:,:) = (0.0d0,0.0d0)
+   !$acc end kernels
+   doverlap(:,:) = (0.0d0, 0.0d0)
+   !
+   npw = ngk(ik)
+   !
+   ! Determine how many atomic wafefunctions there are for atom 'alpha'
+   ! and determine their position in the list of all atomic 
+   ! wavefunctions of all atoms
+   CALL natomwfc_per_atom_v(alpha, m_start, m_end)
+   !
+   ! Compute the derivative dO_IJ/d\tau(alpha,ipol)
+   ! Calculate < dphi_I/d\tau(alpha,ipol) | S | phi_J >
+   DO m1 = m_start, m_end
+      DO m2 = 1, natomwfc
+         temp = (0.d0,0.d0)
+         DO ig = 1, npw
+            ! (k+G) * 2pi/a
+            gvec = (g(ipol,igk_k(ig,ik)) + xki) * tpiba
+            temp = temp + (0.d0,1.d0) * gvec * CONJG(wfcatom(ig,m1))  *&
+                          swfcatom(ig,m2)
+            IF (noncolin) THEN
+            temp = temp + (0.d0,1.d0) * gvec * CONJG(wfcatom(ig+npwx,m1)) *&
+                          swfcatom(ig+npwx,m2)
+            ENDIF
+         ENDDO
+         doverlap(m1,m2) = temp
+      ENDDO
+   ENDDO
+   ! Calculate < phi_I | S | dphi_J/d\tau(alpha,ipol) >
+   DO m1 = 1, natomwfc
+      DO m2 = m_start, m_end
+         temp = (0.d0,0.d0)
+         !$acc parallel loop reduction(+:temp)
+         DO ig = 1, npw
+            ! (k+G) * 2pi/a
+            gvec = (g(ipol,igk_k(ig,ik)) + xki) * tpiba
+            temp = temp + (0.d0,-1.d0) * gvec * CONJG(swfcatom(ig,m1))  *&
+                          wfcatom(ig,m2)
+            IF (noncolin) THEN
+            temp = temp + (0.d0,-1.d0) * gvec * CONJG(swfcatom(ig+npwx,m1)) *&
+                          wfcatom(ig+npwx,m2)
+            ENDIF
+         ENDDO
+         doverlap(m1,m2) = doverlap(m1,m2) + temp
+      ENDDO
+   ENDDO
+   !
+   ! Sum over G vectors
+   CALL mp_sum( doverlap, intra_bgrp_comm )
+   !
+   ! Add the USPP term in dO_IJ/d\tau(alpha,ipol):
+   ! < phi_I | dS/d\tau(alpha,ipol) | phi_J >
+   !
+   IF (okvan) THEN
+      ! ... Calculate doverlap_us = < phi_I | dS/d\tau(alpha,ipol) | phi_J >
+      ALLOCATE(doverlap_us(natomwfc,natomwfc))
+      !$acc data create(doverlap_us)
+      CALL matrix_element_of_dSdtau_v (alpha, ipol, ik, ijkb0, &
+               natomwfc, wfcatom, natomwfc, wfcatom, doverlap_us, 1, natomwfc, 0, .TRUE.)
+      !$acc kernels
+      doverlap(:,:) = doverlap(:,:) + doverlap_us(:,:)
+      !$acc end kernels
+      !$acc end data 
+      DEALLOCATE(doverlap_us)
+   ENDIF
+   !
+   ! Now compute dO^{-1/2}_JI/d\tau(alpha,ipol) using dO_IJ/d\tau(alpha,ipol)
+   ! Note the transposition!
+   !
+   CALL calculate_doverlap_inv (natomwfc, eigenval, eigenvect, &
+                                doverlap, doverlap_inv)
+   !
+   !$acc end data
+   !$acc end data
+   DEALLOCATE (doverlap)
+   !
+   CALL stop_clock('calc_doverlap_inv_v')
+   !
+   RETURN
+   !
+END SUBROUTINE calc_doverlap_inv_v
+! by WIY
+! by WIY
+SUBROUTINE matrix_element_of_dSdtau_v( alpha, ipol, ik, ijkb0, lA, A, &
+                                       lB, B, A_dS_B, lB_s, lB_e, mykey, flag )
+   !--------------------------------------------------------------------
+   !! This routine computes the matrix element \(\langle A | 
+   !! dS/d\tau(\alpha,\text{ipol}) | B \rangle\).  
+   !! Written by I. Timrov (2020).
+   !
+   USE ldav,                 ONLY : ehub_lm, ofstv, ehub_l, counter_lm
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp
+   USE cell_base,            ONLY : tpiba
+   USE wvfct,                ONLY : npwx, wg
+   USE uspp,                 ONLY : nkb, vkb, qq_at, qq_so, okvan
+   USE uspp_param,           ONLY : nh, upf
+   USE klist,                ONLY : igk_k, ngk
+   USE becmod,               ONLY : calbec
+   USE gvect,                ONLY : g
+   USE control_flags,        ONLY : offload_type
+   USE noncollin_module,     ONLY : noncolin, npol, lspinorb
+   USE mp,                   ONLY : mp_sum   
+   USE mp_bands,             ONLY : intra_bgrp_comm
+   !
+   IMPLICIT NONE
+   !
+   INTEGER, INTENT(IN) :: alpha
+   !! the displaced atom
+   INTEGER, INTENT(IN) :: ipol
+   !! the component of displacement
+   INTEGER, INTENT(IN) :: ik
+   !! the k point
+   INTEGER, INTENT(IN) :: ijkb0
+   !! position of beta functions for atom alpha 
+   INTEGER, INTENT(IN) :: lA
+   INTEGER, INTENT(IN) :: lB
+   !! There is a possibility to parallelize over lB
+   INTEGER, INTENT(IN) :: lB_s
+   !! lB start
+   INTEGER, INTENT(IN) :: lB_e
+   !! lB end
+   LOGICAL, INTENT(IN) :: flag   ! noncollinear: controlling whether 
+                                 ! calculating <phi|dS|PSI> 
+                                 ! or          <phi|dS|PHI> (= .true.)
+   COMPLEX(DP), INTENT(IN)  :: A(npwx*npol,lA)
+   COMPLEX(DP), INTENT(IN)  :: B(npwx*npol,lB)
+   COMPLEX(DP), INTENT(OUT) :: A_dS_B(lA,lB_s:lB_e)
+   INTEGER, INTENT(IN) :: mykey
+   !
+   ! ... local variables
+   !
+   INTEGER :: npw, nt, ih, jh, ig, iA, iB, mU, mD, nt1, na, nh_nt, nt2, is1
+   REAL(DP) :: gvec
+   COMPLEX(DP), ALLOCATABLE :: Adbeta(:,:), Abeta(:,:), dbetaB(:,:), &
+                               betaB(:,:), aux(:,:), qq(:,:)
+   !
+   A_dS_B(:,:) = (0.0d0, 0.0d0)
+   !
+   IF (.NOT.okvan) RETURN
+   !
+   !$acc data present_or_copyin(A,B) present_or_copyout(A_dS_B)
+   !
+   nt = ityp(alpha)
+   npw = ngk(ik)
+   nh_nt = nh(nt)
+   !
+   ALLOCATE( Adbeta(lA,npol*nh(nt)) )
+   ALLOCATE( Abeta(lA,npol*nh(nt))  )
+   ALLOCATE( dbetaB(npol*nh(nt),lB) )
+   ALLOCATE( betaB(npol*nh(nt),lB)  )
+   ALLOCATE( qq(npol*nh(nt),npol*nh(nt)) )
+   !$acc data create(Adbeta,Abeta,dbetaB,betaB,qq)
+   !
+   !$acc parallel loop collapse(2) present(qq_at)
+   DO jh = 1, nh_nt
+      DO ih = 1, nh_nt
+         IF (noncolin) THEN
+            IF ( upf(nt)%has_so ) THEN     
+               qq(ih,jh) =             qq_so(ih,jh,1,nt)
+               qq(ih,jh+nh_nt) =       qq_so(ih,jh,2,nt)
+               qq(ih+nh_nt,jh) =       qq_so(ih,jh,3,nt)
+               qq(ih+nh_nt,jh+nh_nt) = qq_so(ih,jh,4,nt)
+            ELSE
+               qq(ih,jh) =             CMPLX(qq_at(ih,jh,alpha), 0.0d0, kind=DP)
+               qq(ih,jh+nh_nt) =       (0.0,0.0)
+               qq(ih+nh_nt,jh) =       (0.0,0.0)
+               qq(ih+nh_nt,jh+nh_nt) = CMPLX(qq_at(ih,jh,alpha), 0.0d0, kind=DP)     
+            ENDIF   
+         ELSE
+            qq(ih,jh) = CMPLX(qq_at(ih,jh,alpha), 0.0d0, kind=DP)
+         ENDIF
+      ENDDO
+   ENDDO
+   !
+   ! ... aux is used as a workspace
+   ALLOCATE( aux(npwx*npol,nh(nt)*npol) )
+   !$acc data create(aux)
+   !
+   !$acc parallel loop collapse(2) 
+   DO ih = 1, nh_nt*npol
+      DO ig = 1, npwx*npol
+         aux(ig,ih) = (0.0d0, 0.0d0)
+      ENDDO
+   ENDDO
+   !
+   ! ... Beta function
+! !omp parallel do default(shared) private(ig,ih)
+   !$acc parallel loop collapse(2) present(vkb(:,:))
+   DO ih = 1, nh_nt
+      DO ig = 1, npw
+         aux(ig,ih) = vkb(ig,ijkb0+ih)
+         IF (noncolin) aux(ig+npwx,ih+nh_nt) = vkb(ig,ijkb0+ih)
+      ENDDO
+   ENDDO
+! !omp end parallel do
+   !
+   IF (noncolin) THEN
+      ! Calculate Abeta = <A|beta>
+      ! Abeta(:,1       : nh(nt))      = spin up
+      ! Abeta(:,1+nh(nt): nh(nt)*npol) = spin down      
+      !
+      Abeta=(0.0,0.0)
+      CALL ZGEMM ('C', 'N', lA, nh_nt*npol, npwx*npol, (1.0_DP, 0.0_DP), A, &
+                 npwx*npol, aux, npwx*npol, (0.0_DP, 0.0_DP), Abeta, lA)
+      CALL mp_sum( Abeta(:, 1:nh_nt*npol) , intra_bgrp_comm )
+      !
+      ! Calculate betaB = <beta|B>
+      ! betaB(:,1       : nh(nt))      = spin up
+      ! betaB(:,1+nh(nt): nh(nt)*npol) = spin down
+      !      
+      betaB=(0.0,0.0)
+      CALL ZGEMM ('C', 'N', nh_nt*npol, lB, npwx*npol, (1.0_DP, 0.0_DP), aux, &
+                 npwx*npol, B, npwx*npol, (0.0_DP, 0.0_DP), betaB, nh_nt*npol)
+      CALL mp_sum( betaB(:, 1:lB) , intra_bgrp_comm )
+   ELSE 
+      ! ... Calculate Abeta = <A|beta>
+      CALL calbec( offload_type, npw, A, aux, Abeta )
+      ! ... Calculate betaB = <beta|B>
+      CALL calbec( offload_type, npw, aux, B, betaB )
+   ENDIF
+   !
+   ! ... Calculate the derivative of the beta function
+! !omp parallel do default(shared) private(ig,ih)
+   !
+   !$acc parallel loop
+   DO ih = 1, nh_nt
+      DO ig = 1, npw
+         gvec = g(ipol,igk_k(ig,ik)) * tpiba
+         aux(ig,ih) = (0.d0,-1.d0) * aux(ig,ih) * gvec
+         IF (noncolin) aux(ig+npwx,ih+nh(nt)) = &
+                    (0.d0,-1.d0) * aux(ig+npwx,ih+nh(nt)) * gvec
+      ENDDO
+   ENDDO
+! !omp end parallel do
+   !
+   IF (noncolin) THEN
+      ! Calculate Adbeta = <A|dbeta>      
+      ! (same as Abeta)
+      !
+      Adbeta=(0.0,0.0)
+      CALL ZGEMM ('C', 'N', lA, nh(nt)*npol, npwx*npol, (1.0_DP, 0.0_DP), A, &
+               npwx*npol, aux, npwx*npol, (0.0_DP, 0.0_DP), Adbeta, lA)
+      CALL mp_sum( Adbeta(:, 1:nh(nt)*npol) , intra_bgrp_comm )
+      !
+      ! Calculate dbetaB = <dbeta|B>
+      ! (same as betaB)
+      !
+      dbetaB=(0.0,0.0)
+      CALL ZGEMM ('C', 'N', nh(nt)*npol, lB, npwx*npol, (1.0_DP, 0.0_DP), aux, &
+               npwx*npol, B, npwx*npol, (0.0_DP, 0.0_DP), dbetaB, nh(nt)*npol)
+      CALL mp_sum( dbetaB(:, 1:lB) , intra_bgrp_comm )
+   ELSE
+      ! ... Calculate Abeta = <A|beta>
+      CALL calbec( offload_type, npw, A, aux, Adbeta )
+      ! ... Calculate betaB = <beta|B>
+      CALL calbec( offload_type, npw, aux, B, dbetaB )
+      !
+   ENDIF
+   !$acc end data
+   DEALLOCATE( aux )
+   ALLOCATE( aux(nh(nt)*npol,lB) )
+   !$acc data create(aux)
+   !
+   IF (noncolin) THEN    
+      aux(:,:) = (0.0,0.0)
+      ! aux(:, 1:nh(nt))             = \sum_jh qq(1,jh)*dbetaB(1,jh) + qq(2,jh)*dbetaB(2,jh)     
+      ! aux(:, 1+nh(nt):nh(nt)*npol) = \sum_jh qq(3,jh)*dbetaB(1,jh) + qq(4,jh)*dbetaB(2,jh)
+      !
+      ! spin up
+      CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                 qq(1, 1), nh(nt)*npol, &
+                 dbetaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                 aux(1, lB_s), nh(nt)*npol)
+      ! spin down   
+      CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                 qq(1+nh(nt), 1), nh(nt)*npol, &
+                 dbetaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                 aux(1+nh(nt), lB_s), nh(nt)*npol)
+   ELSE
+      ! ... Calculate \sum_jh qq_at(ih,jh) * dbetaB(jh)
+      !$acc host_data use_device(qq,dbetaB,aux)
+      CALL MYZGEMM( 'N', 'N', nh(nt), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                  qq, nh(nt), dbetaB(1,lB_s),    nh(nt), (0.0d0,0.0d0), &
+                  aux(1,lB_s), nh(nt) )
+      !$acc end host_data
+   ENDIF
+   !
+   !$acc kernels
+   dbetaB(:,:) = aux(:,:)
+   !$acc end kernels
+   !
+   IF (noncolin) THEN
+      aux(:,:) = (0.0,0.0)
+      ! (same as dbetaB)     
+      !
+      ! spin up 
+      CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                 qq(1, 1), nh(nt)*npol, &
+                 betaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                 aux(1, lB_s), nh(nt)*npol)
+      ! spin down   
+      CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                 qq(1+nh(nt), 1), nh(nt)*npol, &
+                 betaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                 aux(1+nh(nt), lB_s), nh(nt)*npol)
+   ELSE 
+      ! ... Calculate \sum_jh qq_at(ih,jh) * betaB(jh)
+      !$acc host_data use_device(qq,betaB,aux)
+      CALL MYZGEMM( 'N', 'N', nh(nt), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                  qq, nh(nt), betaB(1,lB_s),     nh(nt), (0.0d0,0.0d0), &
+                  aux(1,lB_s), nh(nt) )
+      !$acc end host_data
+   ENDIF
+   !
+   !$acc kernels
+   betaB(:,:) = aux(:,:)
+   !$acc end kernels
+   !
+   !$acc end data
+   DEALLOCATE( aux )
+   !
+   ! ... A_dS_B(iA,iB) = \sum_ih [Adbeta(iA,ih) * betaB(ih,iB) +
+   ! ...                          Abeta(iA,ih)  * dbetaB(ih,iB)] 
+   ! ... Only A_dS_B(:,lB_s:lB_e) are calculated
+   !
+   IF ( mykey == 0 ) THEN
+      IF (noncolin) THEN
+         nt1 = nh(nt) + 1
+         IF ( .NOT.flag ) THEN
+            DO na = 1, nat
+               nt2 = ityp(na)
+               IF ( ehub_lm(nt2) > 0 ) THEN
+                  mU = ofstv(na) + 1
+                  mD = mU + ehub_lm(nt2) 
+                  !
+                  ! actually, if we consider more than one Hubard channel, the order of wfcatom is
+                  ! 121112221111122222.... (1: spin up, 2: spin down) 
+                  ! temp
+                  DO ih = 1, ehub_lm(nt2)
+                    DO jh = lB_s, lB_e
+                      DO ig = 1, nh(nt)
+                        DO is1 = 1, npol
+                          A_dS_B(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), jh) &
+                        = A_dS_B(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), jh) &
+                        + Adbeta(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), &
+                          ig+nh(nt)*(is1-1)) * betaB(ig+nh(nt)*(is1-1), jh) &
+                        + Abeta(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), &
+                          ig+nh(nt)*(is1-1)) * dbetaB(ig+nh(nt)*(is1-1), jh) 
+                        ENDDO
+                      ENDDO
+                    ENDDO
+                  ENDDO
+                  ! temp
+                  !! spin up
+                  !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                  !         Adbeta(mU,1), lA, &
+                  !         betaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                  !         A_dS_B(mU, lB_s), lA)
+                  !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                  !         Abeta(mU,1), lA, &
+                  !         dbetaB(1, lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                  !         A_dS_B(mU, lB_s), lA)        
+                  !! spin down
+                  !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                  !            Adbeta(mD, nt1), lA, &
+                  !            betaB(nt1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                  !            A_dS_B(mD,lB_s), lA)
+                  !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                  !            Abeta(mD, nt1), lA, &
+                  !            dbetaB(nt1, lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                  !            A_dS_B(mD,lB_s), lA)   
+               ENDIF    
+            ENDDO 
+         ELSEIF ( flag ) THEN
+            CALL ZGEMM('N', 'N', lA, lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                        Adbeta, lA, betaB(1,lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                        A_dS_B(1,lB_s), lA)
+            CALL ZGEMM('N', 'N', lA, lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                        Abeta, lA, dbetaB(1,lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                        A_dS_B(1,lB_s), lA)
+         ENDIF        
+      ELSE
+         !$acc host_data use_device(Adbeta,betaB,Abeta,dbetaB,A_dS_B)
+         CALL MYZGEMM( 'N', 'N', lA, lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                     Adbeta, lA, betaB(1,lB_s), nh(nt), (0.0d0,0.0d0), &
+                     A_dS_B(1,lB_s), lA )
+         CALL MYZGEMM( 'N', 'N', lA, lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                     Abeta, lA, dbetaB(1,lB_s), nh(nt), (1.0d0,0.0d0), &
+                     A_dS_B(1,lB_s), lA )
+         !$acc end host_data
+      ENDIF
+   ENDIF
+   !
+   !$acc end data
+   DEALLOCATE( Abeta  )
+   DEALLOCATE( Adbeta )
+   DEALLOCATE( dbetaB )
+   DEALLOCATE( betaB  )
+   DEALLOCATE( qq     )
+   !
+   !$acc end data
+   !
+   RETURN
+   !
+END SUBROUTINE matrix_element_of_dSdtau_v
+! by WIY
+!
+!
+SUBROUTINE dprojdtau_gamma_v(spsi, alpha, ijkb0, ipol, ik, nb_s, nb_e, mykey, dproj)
+   !-----------------------------------------------------------------------
+   ! This routine is the gamma version of \(\texttt{dprojdtau_k}\).
+   ! It computes the first derivative of the projection
+   ! \(\langle\phi^{at}_{I,m1}|S|\psi_{k,v,s}\rangle\) with respect to 
+   ! the atomic displacement \(u(\text{alpha,ipol})\). We remind that:
+   ! $$ \text{ns}_{I,s,m1,m2} = \sum_{k,v}
+   !    f_{kv} \langle\phi^{at}_{I,m1}|S|\psi_{k,v,s}\rangle
+   !           \langle\psi_{k,v,s}|S|\phi^{at}_{I,m2}\rangle $$
+   !
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp
+   USE cell_base,            ONLY : tpiba
+   USE gvect,                ONLY : g
+   USE klist,                ONLY : nks, xk, ngk, igk_k
+   USE wvfct,                ONLY : nbnd, npwx,  wg
+   USE uspp,                 ONLY : nkb, vkb, qq_at
+   USE uspp_param,           ONLY : nh
+   USE wavefunctions,        ONLY : evc
+   USE becmod,               ONLY : bec_type, becp, calbec
+   USE mp_bands,             ONLY : intra_bgrp_comm
+   USE mp_pools,             ONLY : intra_pool_comm, me_pool, nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE ldaV,                 ONLY : ehub_lm, wfcv, nwfcv, ofstv
+
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   COMPLEX(DP), INTENT(IN)  :: spsi(npwx,nbnd)
+
+   INTEGER, INTENT(IN)      :: alpha, ijkb0
+   INTEGER, INTENT(IN)      :: ipol, ik
+   INTEGER, INTENT(IN)      :: nb_s, nb_e, mykey
+
+   REAL(DP), INTENT(OUT)    :: dproj(nwfcv,nb_s:nb_e)
+   !
+   ! ... local variables
+   !
+   REAL(DP)                 :: gvec
+
+   INTEGER                  :: nt
+   INTEGER                  :: ih, jh, ig, npw
+   INTEGER                  :: m, ibnd
+
+   COMPLEX(DP), ALLOCATABLE :: dwfc(:,:), dbeta(:,:)
+
+   REAL(DP), ALLOCATABLE    :: dproj0(:,:), betapsi(:,:), dbetapsi(:,:), &
+                               wfatbeta(:,:), wfatdbeta(:,:), bproj(:,:)
+   !      dwfc(npwx,ldim),     ! the derivative of the atomic wavefunction
+   !      dbeta(npwx,nhm),     ! the derivative of the beta function
+   !      betapsi(nhm,nbnd),   ! <beta|evc>
+   !      dbetapsi(nhm,nbnd),  ! <dbeta|evc>
+   !      wfatbeta(nwfcv,nhm), ! <wfcv|beta>
+   !      wfatdbeta(nwfcv,nhm) ! <wfcv|dbeta>
+   !
+   CALL start_clock('dprojdtau')
+   !
+   nt = ityp(alpha)
+   npw = ngk(ik)
+   !
+   dproj(:,:) = 0.0_dp
+   !
+   ! First the derivatives of the atomic wfc and the beta are computed
+   ! Note: parallelization here is over plane waves, not over bands!
+   !
+   ALLOCATE ( dproj0(ehub_lm(nt),nbnd) )
+   ALLOCATE ( dwfc(npwx,ehub_lm(nt)) )
+   !
+   dproj0(:,:) =  0.D0
+   dwfc(:,:)   = (0.D0,0.D0)
+   !
+   DO ig = 1, npw
+      !
+      ! In the expression of dwfc we don't need (k+G) but just G; k always
+      ! multiplies the underived quantity and gives an opposite contribution
+      ! in c.c. term because the sign of the imaginary unit. But in any case,
+      ! here we consider the situation when k = 0.
+      !
+      gvec = g(ipol,igk_k(ig,ik)) * tpiba
+      !
+      DO m = 1, ehub_lm(nt)
+         dwfc(ig,m) = (0.D0,-1.D0) * gvec * wfcv(ig,ofstv(alpha)+m)
+      ENDDO
+      !
+   ENDDO
+   !
+   ! there is no G=0 term
+   CALL DGEMM('T', 'N', ehub_lm(nt), nbnd, 2*npw, 2.0_dp, &
+              dwfc, 2*npwx, spsi, 2*npwx, 0.0_dp, dproj0, &
+              ehub_lm(nt))
+   !
+   DEALLOCATE ( dwfc )
+   !
+   CALL mp_sum(dproj0, intra_bgrp_comm)
+   !
+   ! copy to dproj results for the bands treated by this processor
+   !
+   DO m = 1, ehub_lm(nt)
+      dproj(ofstv(alpha)+m,:) = dproj0(m,nb_s:nb_e)
+   ENDDO
+   !
+   DEALLOCATE ( dproj0 ) 
+   !
+   !
+   ALLOCATE ( dbetapsi(nh(nt),nbnd) ) 
+   ALLOCATE ( wfatdbeta(nwfcv,nh(nt)) )
+   ALLOCATE ( wfatbeta(nwfcv,nh(nt)) )
+   ALLOCATE(dbeta(npwx,nh(nt)))
+   !
+   DO ih = 1, nh(nt)
+      DO ig = 1, npw
+         dbeta(ig,ih) = vkb(ig,ijkb0+ih)
+      ENDDO
+   ENDDO
+   !
+   CALL calbec(npw, wfcv, dbeta, wfatbeta)
+   !
+   DO ih = 1, nh(nt)
+      DO ig = 1, npw
+         gvec = g(ipol,igk_k(ig,ik)) * tpiba
+         dbeta(ig,ih) = (0.D0,-1.D0) * dbeta(ig,ih) * gvec
+      ENDDO
+   ENDDO
+   !
+   CALL calbec(npw, dbeta, evc, dbetapsi)
+   CALL calbec(npw, wfcv, dbeta, wfatdbeta)
+   !
+   DEALLOCATE ( dbeta )
+   !
+   ! calculate \sum_j qq(i,j)*dbetapsi(j)
+   ! betapsi is used here as work space
+   !
+   ALLOCATE ( betapsi(nh(nt), nbnd) )
+   !
+   betapsi(:,:) = (0.0_dp, 0.0_dp)
+   !
+   ! here starts band parallelization
+   DO ih = 1, nh(nt)
+      DO ibnd = nb_s, nb_e
+         DO jh = 1, nh(nt)
+            betapsi(ih,ibnd) = betapsi(ih,ibnd) + &
+                             qq_at(ih,jh,alpha) * &
+                              dbetapsi(jh,ibnd)
+         ENDDO
+      ENDDO
+   ENDDO
+   !
+   dbetapsi(:,:) = betapsi(:,:)
+   !
+   ! calculate \sum_j qq(i,j)*betapsi(j)
+   !
+   betapsi(:,:) = (0.0_dp, 0.0_dp)
+   !
+   DO ih = 1, nh(nt)
+      DO ibnd = nb_s, nb_e
+         DO jh = 1, nh(nt)
+            betapsi(ih,ibnd) = betapsi(ih,ibnd) + &
+                             qq_at(ih,jh,alpha) * &
+                          becp%r(ijkb0+jh,ibnd)
+         ENDDO
+      ENDDO
+   ENDDO
+   !
+   ! dproj(iwf,ibnd) = \sum_ih wfatdbeta(iwf,ih)*betapsi(ih,ibnd) +
+   !                           wfatbeta(iwf,ih)*dbetapsi(ih,ibnd) 
+   !
+   IF ( mykey == 0 .AND. nh(nt) > 0 ) THEN
+      CALL DGEMM('N', 'N', nwfcv, nb_e-nb_s+1, nh(nt), 1.0_dp, &
+           wfatdbeta, nwfcv, betapsi(1,nb_s), nh(nt), 1.0_dp,  &
+           dproj(1,nb_s), nwfcv)
+      CALL DGEMM('N', 'N', nwfcv, nb_e-nb_s+1, nh(nt), 1.0_dp, &
+           wfatbeta, nwfcv, dbetapsi(1,nb_s), nh(nt), 1.0_dp,  &
+           dproj(1,nb_s), nwfcv)
+   ENDIF
+   !
+   ! end band parallelization - only dproj(1,nb_s:nb_e) are calculated
+   !
+   DEALLOCATE ( betapsi )
+   DEALLOCATE ( wfatbeta )
+   DEALLOCATE ( wfatdbeta )
+   DEALLOCATE ( dbetapsi )
+   !
+   CALL stop_clock('dprojdtau')
+   !
+   RETURN
+   !
+END SUBROUTINE dprojdtau_gamma_v
diff --git a/PW/src/forces.f90 b/PW/src/forces.f90
index bf211d0fa..a4b353267 100644
--- a/PW/src/forces.f90
+++ b/PW/src/forces.f90
@@ -36,6 +36,9 @@ SUBROUTINE forces()
   USE scf,               ONLY : rho
   USE ions_base,         ONLY : if_pos
   USE ldaU,              ONLY : lda_plus_u, Hubbard_projectors
+  ! by LSH
+  USE ldaV,              ONLY : lda_plus_v, acbn0_type
+  ! by LSH
   USE extfield,          ONLY : tefield, forcefield, gate, forcegate, relaxz
   USE control_flags,     ONLY : gamma_only, remove_rigid_rot, textfor, &
                                 iverbosity, llondon, ldftd3, lxdm, ts_vdw, &
@@ -149,6 +152,13 @@ SUBROUTINE forces()
   !     (included by force_us if using beta as local projectors)
   !
   IF ( lda_plus_u .AND. Hubbard_projectors.NE.'pseudo' ) CALL force_hub( forceh )
+  ! by LSH WIY
+  IF ( lda_plus_v .AND. Hubbard_projectors.NE.'pseudo' ) THEN
+    IF( .NOT.(acbn0_type == 2 .or. acbn0_type == 3)) &
+      CALL errore("force_hub_v", 'acbn0_type should be assigned to 2 or 3', 1)
+    CALL force_hub_v( forceh )
+  ENDIF
+  ! by LSH WIY
   !
   ! ... The ionic contribution is computed here
   !
diff --git a/PW/src/h_psi.f90 b/PW/src/h_psi.f90
index 09f375a99..690d9017a 100644
--- a/PW/src/h_psi.f90
+++ b/PW/src/h_psi.f90
@@ -93,6 +93,9 @@ SUBROUTINE h_psi_( lda, n, m, psi, hpsi )
   USE wvfct,                   ONLY: g2kin
   USE uspp,                    ONLY: vkb, nkb
   USE ldaU,                    ONLY: lda_plus_u, Hubbard_projectors
+  ! by LSH
+  USE ldaV,                    ONLY: lda_plus_v, lacbn0, acbn0_type
+  ! by LSH
   USE gvect,                   ONLY: gstart
   USE control_flags,           ONLY: gamma_only, scissor
   USE noncollin_module,        ONLY: npol, noncolin
@@ -251,6 +254,32 @@ SUBROUTINE h_psi_( lda, n, m, psi, hpsi )
      ENDIF
      !
   ENDIF
+  ! by LSH WIY
+  IF ( lda_plus_v .AND. Hubbard_projectors.NE."pseudo" ) THEN
+     IF ( noncolin ) THEN
+       IF ( lacbn0 ) THEN
+          IF ( acbn0_type == 1 ) THEN
+            CALL errore( 'h_psi_nc', 'Noncollinear ACBN0 is not implemented yet', 2 )
+         !   CALL vhpsi_a0_nc(lda, n, m, psi, hpsi)
+          ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            CALL vhpsi_v_nc(lda, n, m, psi, hpsi)
+          ENDIF
+       ELSE
+          CALL vhpsi_v_nc(lda, n, m, psi, hpsi)
+       ENDIF
+     ELSE
+        IF ( lacbn0 ) THEN
+           IF ( acbn0_type == 1 ) THEN
+              CALL vhpsi_a0(lda, n, m, psi, hpsi)
+           ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+              CALL vhpsi_v(lda, n, m, psi, hpsi)
+           ENDIF
+        ELSE
+           CALL vhpsi_v(lda, n, m, psi, hpsi)
+        ENDIF
+     ENDIF
+  ENDIF
+  ! by LSH WIY
   !
   ! ... apply scissor operator
   !
diff --git a/PW/src/hinit1.f90 b/PW/src/hinit1.f90
index 233a4206f..0402c8116 100644
--- a/PW/src/hinit1.f90
+++ b/PW/src/hinit1.f90
@@ -19,6 +19,9 @@ SUBROUTINE hinit1()
   USE fft_base,            ONLY : dfftp
   USE gvecs,               ONLY : doublegrid
   USE ldaU,                ONLY : lda_plus_u
+  ! by LSH
+  USE ldaV,                ONLY : lda_plus_v
+  ! by LSH
   USE lsda_mod,            ONLY : nspin
   USE noncollin_module,    ONLY : report
   USE scf,                 ONLY : vrs, vltot, v, kedtau
@@ -133,6 +136,12 @@ SUBROUTINE hinit1()
   !
   IF ( lda_plus_u  ) CALL orthoUwfc(.FALSE.)
   IF ( use_wannier ) CALL orthoatwfc( .TRUE. )
+  ! by LSH WIY
+  !
+  ! ... used in DFT+U+V calculations
+  !
+  IF ( lda_plus_v  ) CALL orthowfcv()
+  ! by LSH WIY
   !
   ! ... The following line forces recalculation of terms used by EXX
   ! ... It is actually needed only in case of variable-cell calculations
diff --git a/PW/src/hubbard_nns.f90 b/PW/src/hubbard_nns.f90
new file mode 100644
index 000000000..c852701a4
--- /dev/null
+++ b/PW/src/hubbard_nns.f90
@@ -0,0 +1,282 @@
+! similar to the routine in Modules/dist.f90
+SUBROUTINE hubbard_nns()
+
+      USE kinds,     ONLY : dp
+      USE constants, ONLY : bohr_radius_angs
+      USE cell_base, ONLY : at, alat
+      USE ions_base, ONLY : nat, tau
+      USE ldaV,      ONLY : ehub_nn_vect, ehub_nn_distance, &
+                            ehub_nn_leng, ehub_nn_dim,      &
+                            ehub_nn_leng_all, ehub_csize
+
+      REAL(DP) :: rmax, dtau(3)
+      REAL(DP) :: r(3), r2
+
+      INTEGER  :: ics
+      INTEGER  :: na, nb
+      INTEGER  :: n1, n2, n3, ix
+
+      rmax = ehub_nn_distance / bohr_radius_angs / alat
+      !
+      ehub_nn_vect(:,:,:,:,:) = 0
+      ehub_nn_leng(:,:,:,:,:) = 1000.0_DP
+      !
+      IF ( rmax == 0.0_DP ) RETURN
+      !
+      ics = ehub_csize + 1
+      !
+      DO na = 1, nat
+      DO nb = 1, nat
+         !
+         dtau(:) = tau(:, na) - tau(:, nb)
+         !
+         DO n1 = -1*ehub_csize, ehub_csize
+         DO n2 = -1*ehub_csize, ehub_csize
+         DO n3 = -1*ehub_csize, ehub_csize
+            !
+            r2 = 0.0_DP
+            !
+            DO ix = 1, 3
+               r(ix) = n1 * at(ix,1) + n2 * at(ix,2) + n3 * at(ix,3) - dtau(ix)
+               r2 = r2 + r(ix) * r(ix)
+            ENDDO
+            !
+            ehub_nn_leng_all(n1+ics,n2+ics,n3+ics,na,nb) = SQRT(r2)
+            !
+            IF ( r2 <= rmax**2 .AND. ABS(r2) > 1.0D-8 ) THEN
+               ehub_nn_vect(n1+ics,n2+ics,n3+ics,na,nb) = 1
+               ehub_nn_leng(n1+ics,n2+ics,n3+ics,na,nb) = SQRT(r2)
+            ENDIF
+            !
+         ENDDO ! n3
+         ENDDO ! n2
+         ENDDO ! n1
+         !
+      ENDDO ! nb
+      ENDDO ! na
+      !
+      ehub_nn_dim(:) = -1000
+      !
+      DO n1 = -1*ehub_csize, ehub_csize
+      DO n2 = -1*ehub_csize, ehub_csize
+      DO n3 = -1*ehub_csize, ehub_csize
+         !
+         DO na = 1, nat
+         DO nb = 1, nat
+            !
+            IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na,nb) == 1 ) THEN
+               IF (ABS(n1) > ehub_nn_dim(1)) ehub_nn_dim(1) = ABS(n1)
+               IF (ABS(n2) > ehub_nn_dim(2)) ehub_nn_dim(2) = ABS(n2)
+               IF (ABS(n3) > ehub_nn_dim(3)) ehub_nn_dim(3) = ABS(n3)
+            ENDIF
+            !
+         ENDDO
+         ENDDO
+         !
+      ENDDO
+      ENDDO
+      ENDDO
+      !
+      RETURN
+      !
+END SUBROUTINE hubbard_nns
+
+
+SUBROUTINE hubbard_symmetry(atom1, atom2, opatom1, opatom2, n, nnc, sym)
+      !-----------------------------------------------------------------------
+      !
+      !  This subroutine acts the symmetry operatorion number p_sym over the
+      !  atomic position of atom at1 in the reference unit cell and over the
+      !  atomic position of atom at2 in the supercell.
+      !  Then it identifies, in the reference unit cell,
+      !  the equivalent atom to the first 'rotation' above, storing the result
+      !  in rat1 and the equivalent atom to the second 'rotation', storing the
+      !  result in rat2 (temporarily).
+      !  The difference dx = O(p_sym)at1 - rat1 is also subtracted from
+      !  O(p_sym)at2 to find the final position of the second atom.
+      !  To determine in which unit cell the second atom ended up, we
+      !  compute the difference between its final position and the position
+      !  of its equivalent in the reference unit cell.
+      !  Finally, we store in rat2 the position, in the full list of atoms in
+      !  the supercell, the rotated and translated second atom corresponds to.
+      !
+      !  slightly modified version of symonpair.f90
+      !
+      USE kinds
+      USE symm_base, ONLY : s, ft, nsym 
+      USE ions_base, ONLY : nat, ityp, tau
+      USE cell_base, ONLY : bg
+      USE ldaV,      ONLY : ehub_nn_vect, ehub_nn_dim
+      !
+      IMPLICIT NONE
+      !
+      INTEGER, INTENT(IN)  :: atom1, atom2
+      INTEGER, INTENT(IN)  :: n(3)
+      INTEGER, INTENT(IN)  :: sym
+      INTEGER, INTENT(OUT) :: opatom1, opatom2
+      INTEGER, INTENT(OUT) :: nnc
+      !
+      ! Local variables
+      !
+      INTEGER :: i, j
+      INTEGER :: n1, n2, n3
+      INTEGER :: na
+      INTEGER :: opn(3)
+      !
+      REAL(DP) :: ss(3,3)
+      REAL(DP) :: xd(3,nat), x1(3), x2(3)
+      REAL(DP) :: diff, dx(3)
+      !
+      REAL(DP), PARAMETER :: eps = 5.0D-5
+      !
+      ! Convert the symmetry matrix from integer to real type
+      ! for a given symmetry operation p_sym
+      !
+      DO i = 1, 3
+         DO j = 1, 3
+            ss(i,j) = DBLE(s(i,j,sym))
+         ENDDO
+      ENDDO
+      !
+      ! Compute the coordinates of each atom
+      ! in the basis of the direct lattice vectors
+      !
+      DO na = 1, nat
+         DO i = 1, 3
+            xd(i,na) = bg(1,i)*tau(1,na) &
+                     + bg(2,i)*tau(2,na) &
+                     + bg(3,i)*tau(3,na)
+         ENDDO
+      ENDDO
+      !
+      ! Apply the symmetry operation: S*atom - f
+      !
+      DO i = 1, 3
+         !
+         x1(i) = 0.D0
+         x2(i) = 0.D0
+         !
+         ! Rotate atom1 and atom2
+         !
+         DO j = 1, 3
+            x1(i) = x1(i) + (xd(j,atom1)             ) * ss(j,i)
+            x2(i) = x2(i) + (xd(j,atom2) + DBLE(n(j))) * ss(j,i)
+         ENDDO
+         !
+         ! Subtract vectors of fractional translations
+         !
+         x1(i) = x1(i) - ft(i,sym)
+         x2(i) = x2(i) - ft(i,sym)
+         !
+      ENDDO
+      !
+      ! Atom equivalent to x2 : irt(sym,atom2)
+      !
+      diff = 1.D0
+      na = 1
+      !
+      DO WHILE ( na <= nat .AND. diff > eps )
+         !
+         IF ( ityp(na) == ityp(atom2) ) THEN
+            diff = 0.D0
+            DO i = 1, 3
+               dx(i) = x2(i) - xd(i,na)
+               diff = diff + ABS(dx(i)-NINT(dx(i)))
+            ENDDO
+         ELSE
+            diff = 1.D0
+         ENDIF
+         !
+         na = na + 1
+         !
+      ENDDO
+      !
+      IF ( diff > eps ) THEN
+         WRITE(*,*) "diff > 0, diff= ", diff, "atom1= ", atom1, "atom2= ", atom2
+         CALL errore('hubbard_symmetry', 'No atom equivalent to x2', 1)
+      ENDIF
+      !
+      opatom2 = na - 1
+      !
+      ! Atom equivalent to x1 : irt(sym,atom1)
+      !
+      diff = 1.D0
+      na = 1
+      !
+      DO WHILE ( na <= nat .AND. diff > eps )
+         !
+         IF ( ityp(na) == ityp(atom1) ) THEN
+            diff = 0.D0
+            DO i = 1, 3
+               dx(i) = x1(i) - xd(i,na)
+               diff = diff + ABS(dx(i)-NINT(dx(i)))
+            ENDDO
+         ELSE
+            diff = 1.D0
+         ENDIF
+         !
+         na = na + 1
+         !
+      ENDDO
+      !
+      IF ( diff > eps ) THEN
+        WRITE(*,*) "diff > 0, diff= ", diff, "atom1= ", atom1, "atom2= ", atom2
+        CALL errore('hubbard_symmetry', 'No atom equivalent to x1', 1)
+      ENDIF
+      !
+      opatom1 = na - 1
+      !
+      DO i = 1, 3
+         x2(i) = x2(i) - dx(i)
+         opn(i) = NINT(x2(i) - xd(i,opatom2))
+      ENDDO
+      !
+      CALL hubbard_get_nnc(opn,nnc)
+      !
+      RETURN
+      !
+END SUBROUTINE hubbard_symmetry
+
+
+SUBROUTINE hubbard_get_nnc(n, nnc)
+
+      USE ions_base, ONLY : nat
+      USE ldaV,      ONLY : ehub_nn_vect, ehub_nn_dim, ehub_csize
+
+      IMPLICIT NONE
+
+      INTEGER, INTENT(IN)  :: n(3)
+      INTEGER, INTENT(OUT) :: nnc
+
+      INTEGER              :: ics
+      INTEGER              :: n1, n2, n3, opnnc
+
+      ics = ehub_csize + 1
+      !
+      IF ( n(1) == 0 .AND. n(2) == 0 .AND. n(3) == 0 ) THEN
+         nnc = 1
+      ELSE
+         opnnc = 2
+         !
+         DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+         DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+         DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+            !
+            IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+            !
+            IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) THEN
+               IF (n(1) == n1 .AND. n(2) == n2 .AND. n(3) == n3) THEN
+                  nnc = opnnc
+               ELSE
+                  opnnc = opnnc + 1
+               ENDIF
+            ENDIF
+            !
+         ENDDO
+         ENDDO
+         ENDDO
+      ENDIF
+
+      RETURN
+
+END SUBROUTINE hubbard_get_nnc
diff --git a/PW/src/init_ns_v.f90 b/PW/src/init_ns_v.f90
new file mode 100644
index 000000000..5f6f5a0b2
--- /dev/null
+++ b/PW/src/init_ns_v.f90
@@ -0,0 +1,246 @@
+SUBROUTINE init_ns_v
+
+   USE kinds,      ONLY : DP
+   USE ions_base,  ONLY : nat, ityp, ntyp => nsp
+   USE lsda_mod,   ONLY : nspin, starting_magnetization
+   USE ldaV,       ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                          ehub_l_choice, lacbn0, acbn0_type
+   USE scf,        ONLY : rho
+   USE uspp_param, ONLY : upf
+
+   IMPLICIT NONE
+
+   REAL(DP) :: totocc(3,ntyp)
+
+   LOGICAL  :: nm
+
+   INTEGER  :: na, nt
+   INTEGER  :: nw, l, m, ldim
+   INTEGER  :: is, majs, mins
+
+   totocc(:,:) = 0.0_DP
+   !
+   IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+      rho%na0(:,:,:,:) = 0.0_DP
+   ELSE
+      rho%ne0(:,:,:,:,:,:) = 0.0_DP
+   ENDIF
+   !
+   DO nt = 1, ntyp
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      DO nw = 1, upf(nt)%nwfc
+         !
+         IF ( upf(nt)%oc(nw) >= 0.0_DP .AND. ehub_l_choice(nt,nw) == 1 ) THEN
+            l = upf(nt)%lchi(nw)
+            totocc(l+1,nt) = upf(nt)%oc(nw)
+         ENDIF
+         !
+      ENDDO ! nw
+      !
+   ENDDO ! nt
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      nm = .true.
+      !
+      IF ( nspin == 2 ) THEN
+         IF ( starting_magnetization(nt) > 0.0_DP ) THEN
+            nm = .false.
+            majs = 1
+            mins = 2
+         ELSE IF ( starting_magnetization(nt) < 0.0_DP ) THEN
+            nm = .false.
+            majs = 2
+            mins = 1
+         ENDIF
+      ENDIF
+      !
+      IF ( .NOT. nm ) THEN
+         !
+         DO m = 1, ehub_lm(nt)
+            ldim = 2 * (ehub_l(m,nt) - 1) + 1
+            !
+            IF ( totocc(ehub_l(m,nt),nt) > ldim ) THEN
+               !
+               IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+                  rho%na0(m,m,majs,na) = 1.0_DP
+                  rho%na0(m,m,mins,na) = (totocc(ehub_l(m,nt),nt) - ldim) / ldim
+               ELSE
+                  rho%ne0(m,m,majs,na,na,1) = 1.0_DP
+                  rho%ne0(m,m,mins,na,na,1) = (totocc(ehub_l(m,nt),nt) - ldim) / ldim
+               ENDIF
+            ELSE
+               IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+                  rho%na0(m,m,majs,na) = totocc(ehub_l(m,nt),nt) / ldim
+               ELSE
+                  rho%ne0(m,m,majs,na,na,1) = totocc(ehub_l(m,nt),nt) / ldim
+               ENDIF
+            ENDIF
+            !
+         ENDDO
+         !
+      ELSE
+         !
+         DO is = 1, nspin
+            DO m = 1, ehub_lm(nt)
+               ldim = 2 * (ehub_l(m,nt) - 1) + 1
+               !
+               IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+                  rho%na0(m,m,is,na) = totocc(ehub_l(m,nt),nt) / 2.0_DP / ldim
+               ELSE
+                  rho%ne0(m,m,is,na,na,1) = totocc(ehub_l(m,nt),nt) / 2.0_DP / ldim
+               ENDIF
+               !
+            ENDDO
+         ENDDO
+         !
+      ENDIF
+      !
+   ENDDO
+   !
+   RETURN
+
+END SUBROUTINE init_ns_v
+!
+! WIY
+SUBROUTINE init_ns_v_nc
+   !
+   !! Noncollinear version of init_ns (WIY)
+   !
+   USE kinds,              ONLY : DP
+   USE ions_base,          ONLY : nat, ityp, ntyp => nsp
+   USE lsda_mod,           ONLY : nspin, starting_magnetization
+   USE ldaV,               ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                                  ehub_l_choice, lacbn0, acbn0_type
+   USE noncollin_module,   ONLY : angle1, angle2
+   USE scf,                ONLY : rho
+   USE uspp_param,         ONLY : upf
+   !
+   IMPLICIT NONE
+   !
+   REAL(DP) :: totocc(3,ntyp), cosin
+   COMPLEX(DP) :: esin, ns(4)
+   !! parameter for rotating occp. matrix
+   COMPLEX(DP) :: n_charge
+   !! electron charge
+   COMPLEX(DP) :: m_moment
+   !! magnetic moment
+   !
+   LOGICAL  :: nm 
+   !! true if the atom is nonmagnetic
+   !
+   INTEGER  :: na, nt
+   INTEGER  :: nw, l, m, ldim
+   INTEGER  :: is, majs, mins
+   !
+   totocc(:,:) = 0.0_DP
+   !
+   IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+      rho%na0_nc(:,:,:,:) = 0.0_DP
+   ELSE
+      rho%ne0_nc(:,:,:,:,:,:) = 0.0_DP
+   ENDIF
+   !
+   DO nt = 1, ntyp
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      DO nw = 1, upf(nt)%nwfc
+         !
+         l = upf(nt)%lchi(nw)
+         !
+         IF ( upf(nt)%oc(nw) >= 0.0_DP .AND. ehub_l_choice(nt,l+1) == nw ) THEN
+            !
+            totocc(l+1,nt) = upf(nt)%oc(nw)
+            !
+            IF ( (nw-1 > 0) .AND. ( trim(upf(nt)%els(nw)) == trim(upf(nt)%els(nw-1)) ))  THEN
+            !
+            totocc(l+1,nt) = totocc(l+1,nt) + upf(nt)%oc(nw-1)
+            !
+            ENDIF
+            !
+         ENDIF
+         !
+      ENDDO ! nw
+      !
+   ENDDO ! nt
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      nm = .true.
+      !
+      IF ( starting_magnetization(nt) > 0.0_DP ) THEN
+         nm = .false.
+         majs = 1
+         mins = 2
+      ELSE IF ( starting_magnetization(nt) < 0.0_DP ) THEN
+         nm = .false.
+         majs = 2
+         mins = 1
+      ENDIF
+      !
+      IF ( .NOT. nm ) THEN
+         !
+         cosin = COS(angle1(nt))
+         esin  = ( COS(angle2(nt)) + (0.0_DP,1.0_DP)*SIN(angle2(nt))) * SIN(angle1(nt))
+         !
+         DO m = 1, ehub_lm(nt)
+            ldim = 2 * (ehub_l(m,nt) - 1) + 1
+            !
+            ! occp. matrix in quantized axis
+            IF ( totocc(ehub_l(m,nt),nt) > ldim ) THEN
+               ns(majs) = 1.0_DP 
+               ns(mins) = (totocc(ehub_l(m,nt),nt) - ldim) / ldim
+            ELSE
+               ns(majs) = totocc(ehub_l(m,nt),nt) / ldim 
+               ns(mins) = 0.0_DP 
+            ENDIF
+            !
+            n_charge = ns(1) + ns(2)
+            m_moment = ns(1) - ns(2) 
+            !
+            ! rotating occp. matrix
+            ns(1) = ( n_charge + m_moment * cosin) / 2.0_DP
+            ns(2) = m_moment * esin / 2.0_DP 
+            ns(3) = m_moment * CONJG (esin) / 2.0_DP 
+            ns(4) = ( n_charge - m_moment * cosin) / 2.0_DP 
+            !
+            IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+               rho%na0_nc(m,m,:,na) = ns(:)
+            ELSE
+               rho%ne0_nc(m,m,:,na,na,1) = ns(:)
+            ENDIF
+            !
+         ENDDO
+         !
+      ELSE
+         !
+         DO m = 1, ehub_lm(nt)
+            ldim = 2 * (ehub_l(m,nt) - 1) + 1
+            !
+            IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+               rho%na0_nc(m,m,1,na) = totocc(ehub_l(m,nt),nt) / 2.0_DP / ldim
+               rho%na0_nc(m,m,4,na) = totocc(ehub_l(m,nt),nt) / 2.0_DP / ldim              
+            ELSE
+               rho%ne0_nc(m,m,1,na,na,1) = totocc(ehub_l(m,nt),nt) / 2.0_DP / ldim
+               rho%ne0_nc(m,m,4,na,na,1) = totocc(ehub_l(m,nt),nt) / 2.0_DP / ldim
+            ENDIF
+            !
+         ENDDO
+         !
+      ENDIF
+      !
+   ENDDO
+   !
+   RETURN
+
+END SUBROUTINE init_ns_v_nc
+! WIY
diff --git a/PW/src/input.f90 b/PW/src/input.f90
index cdc59b45d..2a7cbd995 100644
--- a/PW/src/input.f90
+++ b/PW/src/input.f90
@@ -387,7 +387,7 @@ SUBROUTINE control_iosys()
                                lgcscf,                                        &
                                zgate, relaxz, block, block_1, block_2,        &
                                block_height, lgcscf, nbnd_cond, nelec_cond,   &
-                               degauss_cond
+                               degauss_cond                                   
   !
   ! ... ELECTRONS namelist
   !
@@ -1217,6 +1217,12 @@ SUBROUTINE control_iosys()
   !
   CALL dftu_iosys ( nsp, noncolin )
   !
+  ! LSH, WIY
+  ! eACBN0 DFT+U+V
+  !
+  CALL dftu_iosys_v1 ( nsp, noncolin )
+  ! LSH, WIY
+  !
   ! REAL-SPACE TREATMENT
   !
   tqr_        = tqr
@@ -1706,6 +1712,12 @@ SUBROUTINE iosys_end ( )
   IF ( llondon) CALL init_london ( )
   IF ( ldftd3)  CALL dftd3_iosys ()
   !
+  ! LSH, WIY
+  ! ... set rest parameter for eACBN0 DFT+U+V
+  !
+  CALL dftu_iosys_v2 ( nat, tau, at, alat )
+  ! LSH, WIY
+
   ! ... set parameters for hybrid functionals (requires cutoffs)
   !
   CALL exx_iosys ( ecutwfc, ecutrho )
@@ -2019,6 +2031,175 @@ SUBROUTINE dftu_iosys ( ntyp, noncolin )
   !
 END SUBROUTINE dftu_iosys
 !
+! LSH, WIY
+!----------------------------------------------------------------------------
+SUBROUTINE dftu_iosys_v1 ( ntyp, noncolin )
+  !----------------------------------------------------------------------------
+  !
+  ! Hubbard parameters: input
+  !
+  USE input_parameters, ONLY : lda_plus_v, lacbn0, acbn0_type, ehub_u, ehub_v,&
+                               ehub_nn_distance, ehub_conv_thr, ehub_mixing,  &
+                               remove_ehub_u, remove_ehub_v, ehub_l_choice,   &
+                               ehub_pot_fix, read_ehub_ns_file, read_ehub_uv_file, &
+                               stop_acbn0
+  !
+  USE constants,     ONLY : rytoev
+  !
+  ! Hubbard parameters: output
+  !
+  USE ldaV,          ONLY : lda_plus_v_ => lda_plus_v, &
+                            lacbn0_ => lacbn0, &
+                            acbn0_type_ => acbn0_type, &
+                            ehub_u_ => ehub_u, &
+                            ehub_v_ => ehub_v, &
+                            ehub_nn_distance_ => ehub_nn_distance, &
+                            ehub_l_choice_ => ehub_l_choice, &
+                            remove_ehub_u_ => remove_ehub_u, &
+                            remove_ehub_v_ => remove_ehub_v, &
+                            ehub_nnnc_ => ehub_nnnc, &
+                            ehub_conv_thr_ => ehub_conv_thr, &
+                            ehub_mixing_ => ehub_mixing, &
+                            read_ehub_ns_file_ => read_ehub_ns_file, &
+                            read_ehub_uv_file_ => read_ehub_uv_file, &
+                            stop_acbn0_ => stop_acbn0, &
+                            pot_fix
+  IMPLICIT NONE
+  !
+  ! Needed input variables
+  INTEGER, INTENT(IN) :: ntyp
+  LOGICAL, INTENT(IN) :: noncolin
+  !
+  ehub_u(:,:,:)              = ehub_u(:,:,:) / rytoev
+  ehub_v(:,:,:,:,:)          = ehub_v(:,:,:,:,:) / rytoev
+  lda_plus_v_                 = lda_plus_v
+  lacbn0_                     = lacbn0
+  acbn0_type_                 = acbn0_type
+  ehub_nn_distance_           = ehub_nn_distance
+  ehub_l_choice_(:,:)         = 0
+  ehub_l_choice_(1:ntyp,:)    = ehub_l_choice(1:ntyp,:)
+  remove_ehub_u_(:,:)         = 1
+  remove_ehub_u_(1:ntyp,:)    = remove_ehub_u(1:ntyp,:)
+  remove_ehub_v_(:,:)         = 1
+  remove_ehub_v_(1:ntyp,:)    = remove_ehub_v(1:ntyp,:)
+  ehub_conv_thr_              = ehub_conv_thr
+  ehub_mixing_                = ehub_mixing
+  pot_fix                     = ehub_pot_fix
+  read_ehub_ns_file_          = read_ehub_ns_file
+  read_ehub_uv_file_          = read_ehub_uv_file
+  stop_acbn0_                 = stop_acbn0
+  !
+  IF ( lacbn0_ .AND. .NOT.lda_plus_v_ ) lda_plus_v_ = lacbn0
+  !
+END SUBROUTINE dftU_iosys_v1
+!
+!----------------------------------------------------------------------------
+SUBROUTINE dftu_iosys_v2 ( nat, tau, at, alat )
+  !----------------------------------------------------------------------------
+  !
+  ! Hubbard parameters: input
+  !
+  USE input_parameters, ONLY : ehub_u, ehub_v, calculation
+  !
+  USE constants,     ONLY : rytoev, bohr_radius_angs
+  USE kinds,     ONLY : DP
+  !
+  ! Hubbard parameters: output
+  USE ldaV,          ONLY : lda_plus_v_ => lda_plus_v, &
+                            lacbn0_ => lacbn0, &
+                            acbn0_type_ => acbn0_type, &
+                            ehub_u_ => ehub_u, &
+                            ehub_v_ => ehub_v, &
+                            ehub_nn_distance_ => ehub_nn_distance, &
+                            ehub_l_choice_ => ehub_l_choice, &
+                            remove_ehub_u_ => remove_ehub_u, &
+                            remove_ehub_v_ => remove_ehub_v, &
+                            ehub_nnnc_ => ehub_nnnc, &
+                            ehub_conv_thr_ => ehub_conv_thr, &
+                            ehub_mixing_ => ehub_mixing, &
+                            read_ehub_ns_file_ => read_ehub_ns_file, &
+                            read_ehub_uv_file_ => read_ehub_uv_file, &
+                            stop_acbn0_ => stop_acbn0, &
+                            pot_fix
+  IMPLICIT NONE
+  !
+  ! Needed input variables
+  INTEGER, INTENT(IN) :: nat
+  REAL(DP), INTENT(IN) :: tau(3,nat)
+  REAL(DP), INTENT(IN) :: at(3,3)
+  REAL(DP), INTENT(IN) :: alat
+  !
+  REAL(DP)             :: rmax, dtau(3)
+  REAL(DP)             :: r(3), r2
+
+  INTEGER              :: na, nb
+  INTEGER              :: n1, n2, n3, ix
+  INTEGER              :: counter
+  INTEGER              :: nnnc
+  !
+  IF ( lda_plus_v_ ) THEN
+     !
+     counter = 0
+     nnnc = 0
+     rmax = ehub_nn_distance_ / bohr_radius_angs / alat
+     !
+     ! calculating nnnc
+     !
+     DO n1 = -10, 10
+     DO n2 = -10, 10
+     DO n3 = -10, 10
+        !
+        DO na = 1, nat
+        DO nb = 1, nat
+           !
+           dtau(:) = tau(:, na) - tau(:, nb)
+           !
+           r2 = 0.0_DP
+           !
+           DO ix = 1, 3
+              r(ix) = n1 * at(ix,1) + n2 * at(ix,2) + n3 * at(ix,3) - dtau(ix)
+              r2 = r2 + r(ix) * r(ix)
+           ENDDO
+           !
+           IF (r2 <= rmax**2 .AND. ABS(r2) > 1.0D-10) THEN
+              IF (n1 == 0 .AND. n2 == 0 .AND. n3 == 0) counter = 1
+              nnnc = nnnc + 1
+              GO TO 10
+           ENDIF
+           !
+        ENDDO ! nb
+        ENDDO ! na
+        !
+10      CONTINUE
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+     !
+     IF (counter == 0) nnnc = nnnc + 1
+     !
+     IF ( lacbn0_ ) THEN
+        IF ( acbn0_type_ == 1 ) THEN
+           IF ( .NOT.ALLOCATED(ehub_u_) ) ALLOCATE ( ehub_u_(nat,9,9) )
+           IF ( TRIM(calculation) /= 'nscf' .OR. TRIM(calculation) /= 'bands' ) ehub_u_(:,:,:) = 0.0_DP
+           ehub_u_(1:nat,:,:) = ehub_u(1:nat,:,:)
+        ELSEIF ( acbn0_type_ == 2 .OR. acbn0_type_ == 3 ) THEN
+           ehub_nnnc_ = nnnc
+           IF ( .NOT.ALLOCATED(ehub_v_) ) ALLOCATE ( ehub_v_(nat,nat,9,9,ehub_nnnc_) )
+           IF ( TRIM(calculation) /= 'nscf' .OR. TRIM(calculation) /= 'bands' ) ehub_v_(:,:,:,:,:) = 0.0_DP
+           ehub_v_(1:nat,1:nat,:,:,1:ehub_nnnc_) = ehub_v(1:nat,1:nat,:,:,1:ehub_nnnc_)
+        ENDIF
+     ELSE
+        ehub_nnnc_ = nnnc
+        IF ( .NOT.ALLOCATED(ehub_v_) ) ALLOCATE ( ehub_v_(nat,nat,9,9,ehub_nnnc_) )
+        IF ( TRIM(calculation) /= 'nscf' .OR. TRIM(calculation) /= 'bands') ehub_v_(:,:,:,:,:) = 0.0_DP
+        ehub_v_(1:nat,1:nat,:,:,1:ehub_nnnc_) = ehub_v(1:nat,1:nat,:,:,1:ehub_nnnc_)
+     ENDIF
+  ENDIF
+  !
+END SUBROUTINE dftu_iosys_v2
+!
+! LSH, WIY
 !----------------------------------------------------------------------------
 SUBROUTINE dftd3_iosys ( )
   !----------------------------------------------------------------------------
@@ -2151,4 +2332,4 @@ SUBROUTINE set_wmass ( )
   IF ( wmass <= 0.D0 ) CALL errore( 'set_wmass', &
             & 'vcsmd: a positive value for cell mass is required', 1 )
   !
-END SUBROUTINE set_wmass
\ No newline at end of file
+END SUBROUTINE set_wmass
diff --git a/PW/src/io_rho_xml.f90 b/PW/src/io_rho_xml.f90
index 7680c0409..b0bd0ca3a 100644
--- a/PW/src/io_rho_xml.f90
+++ b/PW/src/io_rho_xml.f90
@@ -15,7 +15,9 @@ MODULE io_rho_xml
   USE io_base,     ONLY : write_rhog, read_rhog
   !
   PRIVATE
-  PUBLIC :: write_scf, read_scf
+  ! by LSH WIY
+  PUBLIC :: write_scf, read_scf, read_ehub_uv, read_ehub_ns
+  ! by LSH WIY
   !
   ! {read|write}_rho: read or write the charge density
   ! {read|write}_scf: as above, plus ldaU ns, PAW becsum, meta-GGA
@@ -27,6 +29,11 @@ MODULE io_rho_xml
       USE paw_variables,    ONLY : okpaw
       USE ldaU,             ONLY : lda_plus_u, hub_back, lda_plus_u_kind, nsg
       USE two_chem,         ONLY : twochem
+      ! by LSH WIY
+      USE ldaV,             ONLY : lda_plus_v, lacbn0, acbn0_type, &
+                                   ehub_u, ehub_v, ehub_lm, ehub_l, ehub_nn_vect, &
+                                   ehub_nn_dim, ehub_csize, ehub_lm_max, ehub_nnnc
+      ! by LSH WIY
       USE xc_lib,           ONLY : xclib_dft_is
       USE noncollin_module, ONLY : noncolin, domag
       USE scf,              ONLY : scf_type
@@ -41,6 +48,13 @@ MODULE io_rho_xml
                                    root_bgrp, intra_bgrp_comm
       USE mp_images,        ONLY : intra_image_comm
       USE mp,               ONLY : mp_bcast
+      ! by KSJ
+      USE constants,  ONLY : rytoev
+      USE kinds,      ONLY : DP
+      USE parameters, ONLY : ntypx
+      USE ions_base,  ONLY : nat, ntyp => nsp, ityp
+      USE uspp_param,  ONLY : upf
+      ! by KSJ
 
       !
       IMPLICIT NONE
@@ -49,6 +63,15 @@ MODULE io_rho_xml
       !
       CHARACTER (LEN=256) :: dirname
       INTEGER :: nspin_, iunocc, iunpaw, iuntwochem, ierr
+      ! by KSJ LSH WIY
+      INTEGER :: na, na1, na2
+      INTEGER :: nt, nt1, nt2
+      INTEGER :: m1, m2
+      INTEGER :: n1, n2, n3, nnc, ics
+      INTEGER :: iunehubu, iunehubv, iunoccv, iunoccuv
+      INTEGER :: lm1, lm2, spin_idx
+      ! by KSJ LSH WIY
+      INTEGER, EXTERNAL :: find_free_unit
 
       dirname = restart_dir ( )
       CALL create_directory( dirname )
@@ -107,6 +130,341 @@ MODULE io_rho_xml
          !
       END IF
       !
+      ! by LSH
+      IF ( lda_plus_v ) THEN
+         ! by KSJ
+         iunoccv = find_free_unit ()
+         iunoccuv = iunoccv+1
+!         WRITE( stdout, *) iunoccv, iunoccuv
+         ! by KSJ
+         IF ( ionode ) THEN
+            !
+            OPEN ( NEWUNIT = iunoccv, FILE = TRIM(dirname)//'occupation_uv.txt', FORM = 'FORMATTED', STATUS = 'unknown')
+            ! by KSJ
+            OPEN ( NEWUNIT = iunoccuv, FILE = TRIM(dirname)//'occupation_uv0.txt', FORM = 'FORMATTED', STATUS = 'unknown')
+            ! by KSJ
+            !
+            IF ( noncolin ) THEN
+               !
+               IF ( lacbn0 ) THEN
+                  IF ( acbn0_type == 1 ) THEN
+                     WRITE ( iunoccv, *, IOSTAT = ierr ) rho%na0_nc
+                  ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                      ! by KSJ
+!                     WRITE ( stdout,*) '=================================='
+!                     WRITE ( stdout,*) '     occupation_uv information    '
+!                     WRITE ( stdout,*) SIZE(rho%ne0_nc), SHAPE(rho%ne0_nc)
+!                     WRITE ( stdout,*) '=================================='             
+                      ! by KSJ
+                      WRITE ( iunoccv, *, IOSTAT = ierr ) rho%ne0_nc
+                      ! by KSJ
+                      WRITE ( iunoccuv,'(a)' ) '# ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc'
+                      WRITE ( iunoccuv, '(A, I3, 5I4)') '#', ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc  
+                      DO lm1 = 1, ehub_lm_max
+                         DO lm2 = 1, ehub_lm_max
+                            DO spin_idx = 1, nspin
+                               DO na1 = 1, nat
+                                  DO na2 = 1, nat
+                                     DO nnc = 1, ehub_nnnc
+                                     !
+                                     IF (rho%ne0_nc(lm1, lm2, spin_idx, na1, na2, nnc) /= 0.) WRITE ( iunoccuv, '(6i4, 2f25.15)') lm1, lm2, spin_idx, na1, na2, nnc, rho%ne0_nc(lm1, lm2, spin_idx, na1, na2, nnc)
+                                     !
+                                     ENDDO
+                                  ENDDO
+                               ENDDO
+                            ENDDO
+                         ENDDO
+                      ENDDO 
+                      ! by KSJ
+                  ENDIF
+               ELSE
+                  WRITE ( iunoccv, *, IOSTAT = ierr ) rho%ne0_nc
+                  ! by KSJ
+                  WRITE ( iunoccuv,'(a)' ) '# ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc'
+                  WRITE ( iunoccuv, '(A, I3, 5I4)') '#', ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc  
+                  DO lm1 = 1, ehub_lm_max
+                     DO lm2 = 1, ehub_lm_max
+                        DO spin_idx = 1, nspin
+                           DO na1 = 1, nat
+                              DO na2 = 1, nat
+                                 DO nnc = 1, ehub_nnnc
+                                 !
+                                 IF (rho%ne0_nc(lm1, lm2, spin_idx, na1, na2, nnc) /= 0.) WRITE ( iunoccuv, '(6i4, 2f25.15)') lm1, lm2, spin_idx, na1, na2, nnc, rho%ne0_nc(lm1, lm2, spin_idx, na1, na2, nnc)
+                                 !
+                                 ENDDO
+                              ENDDO
+                           ENDDO
+                        ENDDO
+                     ENDDO
+                  ENDDO 
+                  ! by KSJ
+               ENDIF
+               !
+            ELSE
+               !
+               IF ( lacbn0 ) THEN
+                  IF ( acbn0_type == 1 ) THEN
+                     WRITE ( iunoccv, *, IOSTAT = ierr ) rho%na0
+                  ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                     ! by KSJ
+!                     WRITE ( stdout,*) '=================================='
+!                     WRITE ( stdout,*) '     occupation_uv information    '
+!                     WRITE ( stdout,*) SIZE(rho%ne0), SHAPE(rho%ne0)
+!                     WRITE ( stdout,*) '=================================='
+                     ! by KSJ
+                     !
+                     WRITE ( iunoccv, *, IOSTAT = ierr ) rho%ne0
+                     !
+                     ! by KSJ
+                     WRITE ( iunoccuv,'(a)' ) '# ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc'
+                     WRITE ( iunoccuv, '(A, I3, 5I4)') '#', ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc  
+                     DO lm1 = 1, ehub_lm_max
+                        DO lm2 = 1, ehub_lm_max
+                           DO spin_idx = 1, nspin
+                              DO na1 = 1, nat
+                                 DO na2 = 1, nat
+                                    DO nnc = 1, ehub_nnnc
+                                    !
+                                    IF (rho%ne0(lm1, lm2, spin_idx, na1, na2, nnc) /= 0.) WRITE ( iunoccuv, '(6i4, 1f25.15)') lm1, lm2, spin_idx, na1, na2, nnc, rho%ne0(lm1, lm2, spin_idx, na1, na2, nnc)
+                                    !
+                                    ENDDO
+                                 ENDDO
+                              ENDDO
+                           ENDDO
+                        ENDDO
+                     ENDDO 
+                     !
+                     ! by KSJ
+                     !
+                  ENDIF
+               ELSE
+                  WRITE ( iunoccv, *, IOSTAT = ierr ) rho%ne0
+                  !
+                  ! by KSJ
+                  ! rho%ne0(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+!                  WRITE ( stdout,*) '=================================='
+!                  WRITE ( stdout,*) '     occupation_uv information    '
+!                  WRITE ( stdout,*) SIZE(rho%ne0), SHAPE(rho%ne0)
+!                  WRITE ( stdout,*) '=================================='
+                  !
+                  WRITE ( iunoccuv,'(a)' ) '# ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc'
+                  WRITE ( iunoccuv, '(A, I3, 5I4)') '#', ehub_lm_max, ehub_lm_max, nspin, nat, nat, ehub_nnnc
+                  DO lm1 = 1, ehub_lm_max
+                     DO lm2 = 1, ehub_lm_max
+                        DO spin_idx = 1, nspin
+                           DO na1 = 1, nat
+                              DO na2 = 1, nat
+                                 DO nnc = 1, ehub_nnnc
+                                 !
+                                 IF (rho%ne0(lm1, lm2, spin_idx, na1, na2, nnc) /= 0.) WRITE ( iunoccuv, '(6i4, 1f25.15)') lm1, lm2, spin_idx, na1, na2, nnc, rho%ne0(lm1, lm2, spin_idx, na1, na2, nnc)
+                                 !
+                                 ENDDO
+                              ENDDO
+                           ENDDO
+                        ENDDO
+                     ENDDO
+                  ENDDO
+                  ! by KSJ
+               ENDIF
+            ENDIF
+            !
+         ENDIF
+         !
+         CALL mp_bcast(ierr, ionode_id, intra_image_comm)
+         !
+         IF ( ierr/=0 ) CALL errore('write_scf', 'Writing occupation matrices ns for DFT+U+V calculation', 1)
+         !
+         IF ( ionode ) THEN
+            CLOSE ( UNIT = iunoccv, STATUS = 'KEEP' )
+            ! by KSJ
+            CLOSE ( UNIT = iunoccuv, STATUS = 'KEEP' )
+            ! by KSJ
+         ENDIF
+         ! by KSJ
+         iunoccv = find_free_unit ()
+         ! by KSJ
+         !
+         IF ( ionode ) THEN
+            !
+            OPEN ( NEWUNIT = iunoccv, FILE = TRIM(dirname)//'ehub_uv.txt', FORM = 'FORMATTED', STATUS = 'unknown')
+            !
+            ! by KSJ
+!            WRITE ( stdout,*) '=================================='
+!            WRITE ( stdout,*) '        ehub_uv information       '
+!            WRITE ( stdout,*) '=================================='
+!            WRITE ( stdout,*) SIZE(ehub_v), SHAPE(ehub_v)
+!            WRITE ( stdout,*) '=================================='
+            ! by KSJ
+            IF ( lacbn0 ) THEN
+               IF ( acbn0_type == 1 ) THEN
+                  WRITE ( iunoccv, *, IOSTAT = ierr ) ehub_u
+               ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                  WRITE ( iunoccv, *, IOSTAT = ierr ) ehub_v
+               ENDIF
+            ELSE
+               WRITE ( iunoccv, *, IOSTAT = ierr ) ehub_v
+            ENDIF
+            !
+         ENDIF
+         !
+         CALL mp_bcast(ierr, ionode_id, intra_image_comm)
+         !
+         IF ( ierr/=0 ) CALL errore('write_scf', 'Writing Hubbard parameters U or V', 1)
+         !
+         IF ( ionode ) THEN
+            CLOSE( UNIT = iunoccv, STATUS = 'KEEP' )
+         ENDIF
+         !
+         ! by KSJ
+         IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+
+            iunehubu = find_free_unit ()
+
+            IF ( ionode ) THEN
+               OPEN (UNIT= iunehubu, FILE = TRIM(dirname)//'ehub_u0.txt', FORM='FORMATTED', STATUS = 'unknown')
+
+               !
+               ! Write U matrix
+               !
+               WRITE ( iunehubu,'(a)' ) '                          '
+               WRITE ( iunehubu,'(a)' ) '     ---------------------'
+               WRITE ( iunehubu,'(a)' ) '     U[atom i, #orb, #orb]'
+               WRITE ( iunehubu,'(a)' ) '     ---------------------'
+ 
+               DO na = 1, nat
+                  nt = ityp(na)
+                  !
+                  IF ( ehub_lm(nt) == 0 ) CYCLE
+                  !
+                  WRITE ( iunehubu,'(3(a,i2),a)' ) &
+                        '     [ ', na, ', ', 2*MAXVAL(ehub_l(:,nt))-1, ', ', 2*MAXVAL(ehub_l(:,nt))-1, '  ]'
+                  !
+                  DO m1 = 1, ehub_lm(nt)
+                     WRITE ( iunehubu,'(4x,16f9.4)' ) &
+                           (ehub_u(na,m1,m2) * rytoev, m2 = 1, ehub_lm(nt))
+                  ENDDO
+                  !
+                  WRITE ( iunehubu,* ) ''
+                 !
+               ENDDO ! na
+               !
+            ENDIF
+
+            CALL mp_bcast( ierr, ionode_id, intra_image_comm)
+
+            IF (ierr/=0) CALL errore('write_ehub_uv_file', 'Writing Hubbard parameters U', 1)
+
+            IF ( ionode ) THEN
+               CLOSE( UNIT=iunehubu, STATUS = 'KEEP')
+            ENDIF
+
+         ELSE
+
+            iunehubv = find_free_unit ()
+
+            IF ( ionode ) THEN
+
+               OPEN (UNIT= iunehubv, FILE = TRIM(dirname)//'ehub_uv0.txt', FORM='FORMATTED', STATUS = 'unknown')
+               !
+               ! Write V matrices
+               !
+               !WRITE ( iunehubv,'(a)' ) '                                        '
+               !WRITE ( iunehubv,'(a)' ) '     -----------------------------------'
+               WRITE ( iunehubv,'(a)' ) '     # V[atom i, atom j, #orb(i), #orb(j), l, m, n, nnc]'
+               !WRITE ( iunehubv,'(a)' ) '     -----------------------------------'
+               !
+               ics = ehub_csize + 1
+               !
+               DO na1 = 1, nat
+                  nt1 = ityp(na1)
+                  !
+                  IF ( ehub_lm(nt1) == 0 ) CYCLE
+                  !
+               DO na2 = 1, nat
+                  nt2 = ityp(na2)
+                  !
+                  IF ( ehub_lm(nt2) == 0 ) CYCLE
+                  !
+                  IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+                  !
+                  !WRITE ( iunehubv,'(4(a,i2),a)' ) &
+                  !      '     [ ', na1, ', ', na2, ', ', ehub_lm(nt1), ', ', ehub_lm(nt2),'  ]'
+                  !
+                  !WRITE ( iunehubv,'(7i4)' ) na1, na2, ehub_lm(nt1), ehub_lm(nt2), 0, 0, 0
+                  !
+                  !
+                  !WRITE ( iunehubv,'(a,i2,2i6,a)' ) '     [ ', 0, 0, 0, '  ]'
+                  !
+                  DO m1 = 1, ehub_lm(nt1)
+                     DO m2 = 1, ehub_lm(nt2)
+                        WRITE ( iunehubv,'(8i4, 1f25.15)' ) na1, na2, m1, m2, 0, 0, 0, 1, ehub_v(na1,na2,m1,m2,1)
+                        !WRITE ( iunehubv,'(4x,16f9.4)' ) &
+                        !      (ehub_v(na1,na2,m1,m2,1) * rytoev, m2 = 1, ehub_lm(nt2))
+                     ENDDO
+                  ENDDO
+                  !
+                  !WRITE ( iunehubv,* ) ''
+                  !
+               ENDDO ! na2
+               ENDDO ! na1
+               !
+               nnc = 2
+               !
+               DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+               DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+               DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+               !
+               IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+               !
+               DO na1 = 1, nat
+                  nt1 = ityp(na1)
+                  !
+                  IF ( ehub_lm(nt1) == 0 ) CYCLE
+                  !
+               DO na2 = 1, nat
+                  nt2 = ityp(na2)
+                  !
+                  IF ( ehub_lm(nt2) == 0 ) CYCLE
+                  !
+                  IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+                  !
+                  !WRITE ( iunehubv, '(4(a,i2),a)' ) &
+                  !      '     [ ', na1, ', ', na2, ', ', ehub_lm(nt1), ', ', ehub_lm(nt2), '  ]'
+                  !
+                  !WRITE ( iunehubv, '(a,i2,2i6,a)' ) '     [ ', n1, n2, n3, '  ]'
+                  !
+                  DO m1 = 1, ehub_lm(nt1)
+                     DO m2 = 1, ehub_lm(nt2)
+                        WRITE ( iunehubv,'(8i4, 1f25.15)' ) na1, na2, m1, m2, n1, n2, n3, nnc, ehub_v(na1,na2,m1,m2,nnc)
+                        !WRITE ( iunehubv,'(4x,16f9.4)' ) &
+                        !      (ehub_v(na1,na2,m1,m2,nnc) * rytoev, m2 = 1, ehub_lm(nt2))
+                     ENDDO
+                  ENDDO
+                  !
+                  !WRITE ( iunehubv,* ) ''
+                  !
+               ENDDO ! na2
+               ENDDO ! na1
+               !
+               IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+               !
+            ENDDO ! n3
+            ENDDO ! n2
+            ENDDO ! n1
+         ENDIF
+
+         CALL mp_bcast(ierr, ionode_id, intra_image_comm)
+
+         IF ( ierr/=0 ) CALL errore('write_ehub_uv_file', 'Writing Hubbard parameters U or V', 1)
+
+         IF ( ionode ) THEN 
+            CLOSE( UNIT = iunehubv, STATUS = 'KEEP' )
+         ENDIF
+      ENDIF
+         ! by KSJ
+      ENDIF
+      ! by LSH
+      !
       IF ( okpaw ) THEN
          !
          IF ( ionode ) THEN
@@ -120,7 +478,7 @@ MODULE io_rho_xml
             CLOSE( UNIT = iunpaw, STATUS = 'KEEP' )
          ENDIF
          !
-      END IF 
+      END IF
       !
       RETURN
     END SUBROUTINE write_scf
@@ -131,6 +489,10 @@ MODULE io_rho_xml
       USE paw_variables,    ONLY : okpaw
       USE ldaU,             ONLY : lda_plus_u, starting_ns, hub_back, &
                                    lda_plus_u_kind, nsg
+      ! by LSH
+      USE ldaV,             ONLY : lda_plus_v, lacbn0, acbn0_type, &
+                                   ehub_u, ehub_v
+      ! by LSH
       USE noncollin_module, ONLY : noncolin, domag
       USE gvect,            ONLY : ig_l2g
       USE xc_lib,           ONLY : xclib_dft_is
@@ -148,6 +510,9 @@ MODULE io_rho_xml
       CHARACTER(LEN=256) :: dirname
       LOGICAL :: lexist
       INTEGER :: nspin_, iunocc, iunpaw, ierr
+      ! by LSH
+      INTEGER :: iunoccv
+      ! by LSH
       INTEGER, EXTERNAL :: find_free_unit
 
       dirname = restart_dir ( )
@@ -270,7 +635,210 @@ MODULE io_rho_xml
          !
       END IF
       !
+      ! by LSH
+      IF ( lda_plus_v ) THEN
+         !
+         ! The occupations ns also need to be read in order to build up
+         ! the potential
+         !
+         CALL read_ehub_ns( rho )
+         CALL read_ehub_uv
+         !
+      ENDIF
+      ! by LSH
+      !
       RETURN
     END SUBROUTINE read_scf
     !
+    ! by LSH
+    SUBROUTINE read_ehub_ns( rho )
+      !
+      USE scf,              ONLY : scf_type
+      USE ldaV,             ONLY : lda_plus_v, lacbn0, acbn0_type
+      USE noncollin_module, ONLY : noncolin
+      USE io_files,         ONLY : restart_dir
+      USE io_global,        ONLY : ionode, ionode_id, stdout
+      USE mp_images,        ONLY : intra_image_comm
+      USE mp,               ONLY : mp_bcast, mp_sum
+      !
+      IMPLICIT NONE
+
+      TYPE(scf_type), INTENT(INOUT) :: rho
+
+      CHARACTER(LEN=256)            :: dirname
+      LOGICAL                       :: lexist
+      INTEGER                       :: iunoccv, ierr
+      INTEGER, EXTERNAL             :: find_free_unit
+
+      dirname = restart_dir ( )
+      !
+      iunoccv = find_free_unit ()
+      !
+      IF ( ionode ) THEN
+         !
+         OPEN (UNIT = iunoccv, FILE = TRIM(dirname)//'occupation_uv.txt', FORM = 'FORMATTED', STATUS = 'old', IOSTAT = ierr )
+         !
+         IF ( noncolin ) THEN
+            !
+            IF ( lacbn0 ) THEN
+               IF ( acbn0_type == 1 ) THEN
+                  READ ( UNIT = iunoccv, FMT = *, IOSTAT = ierr ) rho%na0_nc
+               ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                  READ ( UNIT = iunoccv, FMT = *, IOSTAT = ierr ) rho%ne0_nc
+               ENDIF
+            ELSE
+               READ ( UNIT = iunoccv, FMT = *, IOSTAT = ierr ) rho%ne0_nc
+            ENDIF
+            !
+         ELSE
+            !
+            IF ( lacbn0 ) THEN
+               IF ( acbn0_type == 1 ) THEN
+                  READ ( UNIT = iunoccv, FMT = *, IOSTAT = ierr ) rho%na0
+               ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                  READ ( UNIT = iunoccv, FMT = *, IOSTAT = ierr ) rho%ne0
+               ENDIF
+            ELSE
+               READ( UNIT = iunoccv, FMT = *, IOSTAT = ierr ) rho%ne0
+            ENDIF
+            !
+         ENDIF
+         !
+      ENDIF
+      !
+      CALL mp_bcast(ierr, ionode_id, intra_image_comm)
+      !
+      IF ( ierr/=0 ) CALL errore('read_scf', 'Reading occupation matrices ns', 1)
+      !
+      IF ( ionode ) THEN
+         CLOSE ( UNIT = iunoccv, STATUS = 'KEEP' )
+      ELSE
+         !
+         IF ( noncolin ) THEN
+            !
+            IF ( lacbn0 ) THEN
+               IF ( acbn0_type == 1 ) THEN
+                  rho%na0_nc = 0.D0
+               ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                  rho%ne0_nc = 0.D0
+               ENDIF
+            ELSE
+               rho%ne0_nc = 0.D0
+            ENDIF
+            !
+         ELSE
+            !
+            IF ( lacbn0 ) THEN
+               IF ( acbn0_type == 1 ) THEN
+                  rho%na0 = 0.D0
+               ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                  rho%ne0 = 0.D0
+               ENDIF
+            ELSE
+               rho%ne0 = 0.D0
+            ENDIF
+            !
+         ENDIF
+         !
+      ENDIF
+      !
+      IF ( noncolin ) THEN
+         !
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               CALL mp_sum(rho%na0_nc, intra_image_comm)
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               CALL mp_sum(rho%ne0_nc, intra_image_comm)
+            ENDIF
+         ELSE
+            CALL mp_sum(rho%ne0_nc, intra_image_comm)
+         ENDIF
+         !
+      ELSE
+         !
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               CALL mp_sum(rho%na0, intra_image_comm)
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               CALL mp_sum(rho%ne0, intra_image_comm)
+            ENDIF
+         ELSE
+            CALL mp_sum(rho%ne0, intra_image_comm)
+         ENDIF
+         !
+      ENDIF
+      !
+      RETURN
+      !
+    END SUBROUTINE read_ehub_ns
+      !
+    SUBROUTINE read_ehub_uv
+      !
+      USE ldaV,             ONLY : lda_plus_v, lacbn0, acbn0_type, &
+                                   ehub_u, ehub_v
+      USE io_files,         ONLY : restart_dir
+      USE io_global,        ONLY : ionode, ionode_id, stdout
+      USE mp_images,        ONLY : intra_image_comm
+      USE mp,               ONLY : mp_bcast, mp_sum
+      !
+      IMPLICIT NONE
+
+      CHARACTER(LEN=256)            :: dirname
+      LOGICAL                       :: lexist
+      INTEGER                       :: iunoccv, ierr
+      INTEGER, EXTERNAL             :: find_free_unit
+
+      dirname = restart_dir ( )
+      !
+      iunoccv = find_free_unit ()
+      !
+      IF ( ionode ) THEN
+         !
+         OPEN (UNIT = iunoccv, FILE = TRIM(dirname)//'ehub_uv.txt', FORM = 'FORMATTED', STATUS = 'old', IOSTAT = ierr )
+         !
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               READ ( UNIT = iunoccv, FMT = *, iostat = ierr ) ehub_u
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               READ ( UNIT = iunoccv, FMT = *, iostat = ierr ) ehub_v
+            ENDIF
+         ELSE
+            READ( UNIT = iunoccv, FMT = *, iostat = ierr ) ehub_v
+         ENDIF
+         !
+      ENDIF
+      !
+      CALL mp_bcast(ierr, ionode_id, intra_image_comm)
+      !
+      IF ( ierr/=0 ) CALL errore('read_scf', 'Reading Hubbard U or V', 1)
+      !
+      IF ( ionode ) THEN
+          CLOSE ( UNIT = iunoccv, STATUS = 'KEEP' )
+      ELSE
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               ehub_u = 0.D0
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               ehub_v = 0.D0
+            ENDIF
+         ELSE
+            ehub_v = 0.D0
+         ENDIF
+      ENDIF
+      !
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            CALL mp_sum(ehub_u, intra_image_comm)
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            CALL mp_sum(ehub_v, intra_image_comm)
+         ENDIF
+      ELSE
+         CALL mp_sum(ehub_v, intra_image_comm)
+      ENDIF
+      !
+      RETURN
+      !
+    END SUBROUTINE read_ehub_uv
+      !
+      ! by LSH
 END MODULE io_rho_xml
diff --git a/PW/src/ldaV.f90 b/PW/src/ldaV.f90
new file mode 100644
index 000000000..97e23e9d3
--- /dev/null
+++ b/PW/src/ldaV.f90
@@ -0,0 +1,734 @@
+MODULE ldaV
+
+  USE constants,  ONLY : rytoev
+  USE kinds,      ONLY : DP
+  USE parameters, ONLY : ntypx
+  USE basis,      ONLY : natomwfc
+  USE ions_base,  ONLY : nat, ntyp => nsp, ityp
+  USE uspp_param, ONLY : upf
+  USE io_global,  ONLY : stdout
+
+  SAVE
+
+  COMPLEX(DP), ALLOCATABLE ::   &
+    wfcv(:,:),                  & ! atomic wavefunctions having V correction
+    ! WIY
+    d_spin_ldav(:,:,:)            ! the rotations in spin space for all symmetries
+    ! WIY
+
+  REAL(DP) ::                   &
+    ehubene,                    & ! Hubbard contribution to total energy
+    ehubene_old,                &
+    dehubene,                   &
+    ehub_nn_distance,           & ! considered as the nearest neighbors
+                                  ! if the distance is less than "ehub_nn_distance"
+    ehub_conv_thr,              &
+    ehub_mixing
+
+  REAL(DP), ALLOCATABLE ::      &
+    ehub_v(:,:,:,:,:),          & ! Hubbard inter-site interaction energy V
+                                  ! ehub_v(na1, na2, m1, m2, ncells)
+                                  ! na1, na2: atom indices
+                                  ! m1, m2: orbital indices
+                                  ! ncells: nearest-neighbor cell indices
+    ehub_u(:,:,:),              & ! ehub_u(na, m1, m2)
+    ehub_v_diff(:,:,:,:,:),     &
+    ehub_u_diff(:,:,:),         &
+    ehub_nn_leng(:,:,:,:,:),    &
+    ehub_nn_leng_all(:,:,:,:,:) 
+
+  INTEGER ::                    &
+    nwfcv,                      & ! total # of atomic wavefunctions having V correction
+    ehub_lm(ntypx),             & ! sum of angular momenta of V-corrected orbitals of each types
+    ehub_lm_max,                & ! maximum value of "Hubbard_lm"
+    ehub_l_choice(ntypx,6),     &
+    ehub_l_choice_inp(ntypx,6), &
+    remove_ehub_u(ntypx,6),     &
+    remove_ehub_v(ntypx,6),     &
+    acbn0_type,                 & ! 1: Hubbard, 2: extended Hubbard, 3: orbital-dependent extended Hubbard
+    ehub_nn_dim(3),             &
+    ehub_nnnc
+
+  INTEGER, ALLOCATABLE ::       &
+    ofst(:), ofstv(:),          & ! offset of atomic wavfunctions used for projections
+    ehub_nn_vect(:,:,:,:,:),    & ! nearest neighbor(1) or not(0)
+                                  ! ex) ehub_nn_vect(a, b, c, na1, na2)
+                                  ! a, b, c: cell indices
+                                  ! na1: atom located at home unit cell
+                                  ! na2: atom located at (a,b,c) cell
+    ehub_l(:,:),                &
+    counter_lm(:,:)               ! counter for calculating occupation number in noncollinear calculations
+
+  INTEGER, PARAMETER ::         &
+    ehub_csize = 10
+
+  LOGICAL ::                    &
+    lda_plus_v,                 & ! .TRUE. if extended Hubbard model calculation is performed
+    lacbn0,                     & ! .TRUE. if ACBN0 functional is used
+    pot_fix,                    & ! .TRUE. for fixed Hubbard potential calculation
+    read_ehub_ns_file = .FALSE.,&
+    read_ehub_uv_file = .FALSE.,&
+    stop_acbn0        = .FALSE.
+
+CONTAINS
+
+  SUBROUTINE init_lda_plus_v( noncolin, nspin )
+ 
+    IMPLICIT NONE
+ 
+    LOGICAL, INTENT(IN) :: noncolin
+
+    INTEGER, INTENT(IN) :: nspin
+ 
+    LOGICAL             :: neq
+
+    INTEGER             :: na1, na2, nt1, nt2, m1, m2
+    INTEGER             :: nw, na, nt, m, l, j, n, counter, counter_
+    INTEGER             :: n1, n2, n3, nnc, ics
+    INTEGER             :: nmax1, nmax2, nmax3
+    INTEGER             :: l_choice(ntypx,6)
+    INTEGER, PARAMETER  :: l_wfc = 6 ! 1 = s, 2 = p, 3 = d, 4 = f, 5 = d for semicore
+
+    REAL(DP), PARAMETER :: eps = 1.0D-2
+    REAL(DP), PARAMETER :: eps2 = 1.0D-6
+
+    CHARACTER(LEN=2)    :: orbital
+    CHARACTER(LEN=1)    :: spdf(0:3) = ['S','P','D','F']
+
+    IF ( .NOT. lda_plus_v ) THEN
+       ehub_lm_max = 0
+       RETURN
+    ENDIF
+    !
+    IF ( nspin == 1 ) &
+       CALL errore('init_lda_plus_v', 'nspin == 1 is not supported yet', 1)
+    ! WIY
+    ! Following Do loops for checking pp is scalar or
+    ! full relativistic.
+    ! Full relativistic pp is not working on calculations
+    ! without lspinorb = .true. in case of eACBN0 calculation.
+    !
+    DO nt = 1, ntyp
+        !
+        DO nw = upf(nt)%nwfc, 1, -1
+            !
+            orbital = trim(upf(nt)%els(nw))
+            !
+            l = upf(nt)%lchi(nw)
+            !
+            IF(spdf(l) /= orbital(2:)) THEN
+                CALL errore('init_lda_plus_v', 'Full relativistic pp can be used with lspinorb = .true. in case of eACBN0 calculation.', 1)
+            ENDIF
+            !
+        ENDDO
+    ENDDO
+    !
+    IF ( noncolin ) THEN
+       IF ( .NOT. ALLOCATED (d_spin_ldav) ) ALLOCATE( d_spin_ldav(2,2,48))
+       CALL comp_dspinldav()
+    ENDIF
+    ! WIY
+    ! ... reset ehub_l_choice
+    !
+    l_choice(:,:) = 0
+    !
+    ! WIY
+    DO nt = 1, ntyp
+      !
+      DO nw = 1, l_wfc
+         !
+         n = 0
+         !
+         IF ( nw == 3 ) THEN ! 3 is for d orbital
+            !
+            DO na = upf(nt)%nwfc, 1, -1
+               !
+               IF ( upf(nt)%lchi(na) /= nw-1 ) CYCLE
+               !
+               orbital = trim(upf(nt)%els(na)) ! label in PP_CHI
+               !
+               IF ( n < ICHAR(orbital(1:1)) ) THEN
+                  !
+                  n = ICHAR(orbital(1:1))
+                  !
+                  counter_ = na
+                  !
+               ENDIF
+               !
+            ENDDO
+            !
+            IF ( ehub_l_choice(nt,nw) == 1) THEN
+            !    
+                IF ( noncolin ) THEN
+                    l_choice(nt,nw) = counter_
+                ELSE
+                    l_choice(nt,counter_) = 1
+                ENDIF
+            !
+            ENDIF
+            !
+         !ENDIF
+         !!
+         ELSEIF ( ehub_l_choice(nt,nw) == 1 .AND. nw <= 4 .AND. nw /= 3 ) THEN
+            !
+            DO na = upf(nt)%nwfc, 1, -1
+               !
+               IF ( upf(nt)%lchi(na) /= nw-1 ) CYCLE !.OR. nw == 3 ) CYCLE
+               !
+               orbital = trim(upf(nt)%els(na)) ! label in PP_CHI
+               !
+               IF ( n < ICHAR(orbital(1:1)) ) THEN
+                  !
+                  n = ICHAR(orbital(1:1))
+                  !
+                  counter = na
+                  !
+               ENDIF
+               !
+            ENDDO
+            !
+            !IF ( nw == 3 ) counter = counter_
+            !
+            IF ( noncolin ) THEN
+               l_choice(nt,nw) = counter
+            ELSE
+               l_choice(nt,counter) = 1
+            ENDIF
+            !
+            ! ... if valence d & semicore d are coexisted in pseudofile, for
+            ! ... semicore d orbital -> ehub_l_choice(type,5)
+            !
+         ELSEIF ( ehub_l_choice(nt,nw) == 1 .AND. nw == 5 ) THEN
+            !
+            DO na = upf(nt)%nwfc, 1, -1
+               !
+               IF ( upf(nt)%lchi(na) /= nw-3 ) CYCLE
+               !
+               orbital = trim(upf(nt)%els(na))
+               !
+               IF ( n < ICHAR(orbital(1:1)) ) THEN
+                  !
+                  n = ICHAR(orbital(1:1))
+                  !
+                  IF ( na /= counter_ ) counter = na
+                  !
+               ENDIF
+               !
+            ENDDO
+            !
+            IF ( noncolin ) THEN
+               l_choice(nt,nw) = counter
+            ELSE
+               l_choice(nt,counter) = 1
+            ENDIF
+            !
+         ENDIF
+         !
+      ENDDO
+      !
+    ENDDO
+    !
+    ehub_l_choice_inp(:,:) = ehub_l_choice(:,:)
+    ehub_l_choice(:,:) = l_choice(:,:)
+    ! ... ehub_lm max
+    !
+    ehub_lm_max = -1
+    !
+    ehub_lm(:) = 0
+    !
+    DO nt = 1, ntyp
+       !
+       DO nw = 1, upf(nt)%nwfc
+          !
+          l = upf(nt)%lchi(nw)
+          !
+          IF ( noncolin ) THEN
+            IF ( upf(nt)%oc(nw) >= 0.0_DP .AND. ehub_l_choice(nt, l+1) == nw ) THEN
+               ! Below part is for the noncollinear ACBN0 functionals.
+               !IF ( upf(nt)%has_so ) THEN
+               !   ! j = l-1/2, degeneracy 2*l
+               !   ehub_lm(nt) = ehub_lm(nt) + 2*l
+               !   ! j = l+1/2, degeneracy 2*l+2
+               !   IF ( ABS( upf(nt)%jchi(nw)-l-0.5_DP) < eps2 ) &
+               !   & ehub_lm(nt) = ehub_lm(nt) + 2
+               !   !
+               !   IF ( (nw-1 > 0) .AND. ( TRIM(upf(nt)%els(nw)) == TRIM(upf(nt)%els(nw-1)))) THEN
+               !      ! 
+               !      ehub_lm(nt) = ehub_lm(nt) + 2*l
+               !      !
+               !      IF ( ABS( upf(nt)%jchi(nw-1)-l-0.5_DP) < eps2 ) &
+               !      & ehub_lm(nt) = ehub_lm(nt) + 2
+               !      !
+               !   ENDIF                     
+               !ELSE
+               !   ehub_lm(nt) = ehub_lm(nt) + 2*(2*l+1)
+               !ENDIF 
+               !
+               ehub_lm(nt) = ehub_lm(nt) + 2*l + 1
+            ENDIF            
+          ELSE 
+            IF ( upf(nt)%oc(nw) >= 0.0_DP .AND. ehub_l_choice(nt,nw) == 1 ) THEN
+               !
+               ehub_lm(nt) = ehub_lm(nt) + 2*l + 1
+               !
+            ENDIF
+          ENDIF
+          !
+       ENDDO
+       !
+       ehub_lm_max = MAX(ehub_lm_max, ehub_lm(nt))
+       !
+    ENDDO
+    !
+    ! ... ehub_l
+    !
+    IF ( .NOT. ALLOCATED(ehub_l) ) ALLOCATE ( ehub_l(ehub_lm_max, ntyp) ) ; ehub_l(:,:) = 0
+    !
+    DO nt = 1, ntyp
+       !
+       counter = 1
+       !
+       DO nw = 1, upf(nt)%nwfc
+          !
+          l = upf(nt)%lchi(nw)
+          !
+          IF ( noncolin ) THEN
+            IF ( upf(nt)%oc(nw) >= 0.0_DP .AND. ehub_l_choice(nt, l+1) == nw ) THEN
+               ! Below part is for the noncollinear ACBN0 functionals.
+               !IF ( upf(nt)%has_so ) THEN
+               !   !
+               !   IF ( ABS( upf(nt)%jchi(nw)-l-0.5_DP) < eps2 ) THEN
+               !      ! j = l+1/2, degeneracy 2*l+2
+               !      DO m = counter, counter + 2*l + 2
+               !         ehub_l(m,nt) = l+1
+               !      ENDDO
+               !      !
+               !      counter = counter + 2*l + 2
+               !      !
+               !   ELSE
+               !      ! j = l-1/2, degeneracy 2*l
+               !      DO m = counter, counter + 2*l 
+               !         ehub_l(m,nt) = l+1
+               !      ENDDO
+               !      !
+               !      counter = counter 2*l
+               !      !
+               !   ENDIF
+               !   !
+               !   IF ( (nw-1 > 0) .AND. ( TRIM(upf(nt)%els(nw)) == TRIM(upf(nt)%els(nw-1)))) THEN
+               !      !
+               !      IF ( ABS( upf(nt)%jchi(nw-1)-l-0.5_DP) < eps2 ) THEN
+               !         ! j = l+1/2, degeneracy 2*l+2
+               !         DO m = counter, counter + 2*l + 2
+               !            ehub_l(m,nt) = l+1
+               !         ENDDO
+               !         !
+               !         counter = counter + 2*l + 2
+               !         !
+               !      ELSE
+               !         ! j = l-1/2, degeneracy 2*l
+               !         DO m = counter, counter + 2*l 
+               !            ehub_l(m,nt) = l+1
+               !         ENDDO
+               !         !
+               !         counter = counter + 2*l 
+               !         !
+               !      ENDIF
+               !      !
+               !   ENDIF
+               !ELSE 
+               !   !
+               !   DO m = counter, counter + 2*(2*l + 1)
+               !      ehub_l(m,nt) = l + 1
+               !   ENDDO
+               !   !
+               !   counter = counter + 2*(2*l + 1)
+               !   !
+               !ENDIF 
+               !
+               DO m = counter, counter + 2*l
+                  ehub_l(m,nt) = l + 1
+               ENDDO 
+               !
+               counter = counter + 2*l + 1
+               !
+            ENDIF
+            !
+          ELSE
+            !
+            IF ( upf(nt)%oc(nw) >= 0.0_DP .AND. ehub_l_choice(nt,nw) == 1 ) THEN
+               !
+               DO m = counter, counter + 2*l
+                  ehub_l(m,nt) = l + 1
+               ENDDO
+               !
+               counter = counter + 2*l + 1
+               !
+            ENDIF
+            !
+          ENDIF
+       ENDDO
+       !
+    ENDDO
+    !
+    ! WIY
+    IF (noncolin) THEN
+      !
+      IF ( .NOT. ALLOCATED(counter_lm) ) ALLOCATE ( counter_lm(ehub_lm_max,ntyp) ); counter_lm(:,:) = 0
+      !
+      DO nt = 1, ntyp
+         !
+         DO m = 2, ehub_lm(nt)
+            !
+            counter_lm(m,nt) = counter_lm(m-1,nt)
+            !
+            IF (ehub_l(m,nt) /= ehub_l(m-1,nt)) &
+            counter_lm(m,nt) = counter_lm(m,nt) + 2*(ehub_l(m-1,nt)-1)+1
+            !
+         ENDDO
+         !
+      ENDDO
+      !
+    ENDIF
+    ! WIY
+    IF ( ehub_lm_max == 0 ) CALL errore('init_lda_plus_v', 'set ehub_l_choice', 1)
+    !
+    ! ... ofstv
+    !
+    IF ( .NOT. ALLOCATED(ofst) ) ALLOCATE ( ofst(nat) )
+    !
+    CALL offset_atom_wfc_v(.false., ofst, nwfcv)
+    !
+    IF ( nwfcv .NE. natomwfc ) &
+       CALL errore('offset_atom_wfc_v', 'wrong number of wavefunctions', 1)
+    !
+    IF ( .NOT. ALLOCATED(ofstv) ) ALLOCATE ( ofstv(nat) )
+    !
+    CALL offset_atom_wfc_v(.true., ofstv, nwfcv)
+    !
+    ics = ehub_csize + 1
+    !
+    IF ( .NOT. lacbn0 .OR. .NOT. acbn0_type == 1 ) THEN
+       !
+       ! ... ehub_nn_vect, ehub_nn_leng
+       !
+       IF ( .NOT. ALLOCATED(ehub_nn_vect) ) &
+          ALLOCATE ( ehub_nn_vect(2*ehub_csize+1,2*ehub_csize+1,2*ehub_csize+1,nat,nat) )
+       IF ( .NOT. ALLOCATED(ehub_nn_leng) ) &
+          ALLOCATE ( ehub_nn_leng(2*ehub_csize+1,2*ehub_csize+1,2*ehub_csize+1,nat,nat) )
+       IF ( .NOT. ALLOCATED(ehub_nn_leng_all) ) &
+          ALLOCATE ( ehub_nn_leng_all(2*ehub_csize+1,2*ehub_csize+1,2*ehub_csize+1,nat,nat) )
+       !
+       CALL hubbard_nns()
+       !
+       IF (MAXVAL(ehub_nn_dim(:)) > 10) &
+          CALL errore('hubbard_nns', 'reduce the ehub_nn_distance (ehub_nn_dim > 10)', 1)
+       !
+       ! Print the nearest neighbors vectors
+       !
+       WRITE ( stdout,'(a)' ) '     -----------------------------------------------------------'
+       WRITE ( stdout,'(a)' ) '     List of the nearest neighbors for inter-site interactions V'
+       WRITE ( stdout,'(a)' ) '     -----------------------------------------------------------'
+       !
+       DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+       DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+       DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+          !
+          DO na1 = 1, nat
+          DO na2 = 1, nat
+             !
+             IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+             !
+             WRITE ( stdout,'(a,i2,a,i2,a,3i6)' ) &
+                   '     atom 1: ', na1, ',  atom 2: ', na2, ',',  n1, n2, n3
+          ENDDO ! na2
+          ENDDO ! na1
+          !
+       ENDDO ! n3
+       ENDDO ! n2
+       ENDDO ! n1
+       !
+       WRITE( stdout,'(a)' ) ' '
+       !
+    ENDIF
+    !
+    IF ( lacbn0 .AND. stop_acbn0 ) THEN
+       IF ( acbn0_type == 1 ) THEN
+          ALLOCATE ( ehub_u_diff(nat,ehub_lm_max,ehub_lm_max) )
+          ehub_u_diff = 1000.0_DP
+       ELSE
+          ALLOCATE ( ehub_v_diff(nat,nat,ehub_lm_max,ehub_lm_max,ehub_nnnc) )
+          ehub_v_diff = 1000.0_DP
+       ENDIF
+    ENDIF
+    !
+    IF ( lda_plus_v .AND. .NOT.lacbn0 .AND. .NOT.read_ehub_ns_file .AND. .NOT.read_ehub_uv_file ) THEN
+       !
+       ! ... initialize U & V values
+       !
+       !
+       ! Set U for same type of atoms
+       !
+       na1 = 1
+       neq = .false.
+       !
+       DO nt1 = 1, ntyp
+          DO na2 = na1, nat
+             !
+             IF ( nt1 == ityp(na2) ) THEN
+                !
+                DO m1 = 1, ehub_lm(nt1)
+                DO m2 = 1, ehub_lm(nt1)
+                   ehub_v(na2,na2,m1,m2,1) = ehub_v(na1,na1,m1,m2,1)
+                ENDDO
+                ENDDO
+                !
+             ELSE
+                !
+                IF (.not. neq) THEN
+                   na = na2
+                   neq = .true.
+                ENDIF
+                !
+             ENDIF
+             !
+          ENDDO
+          !
+          na1 = na
+          neq = .false.
+          !
+       ENDDO
+       !
+       ! Hermiticity of Hubbard interaction parameters U & V (in the unit cell)
+       !
+       DO na1 = 1, nat
+          nt1 = ityp(na1)
+          !
+       DO na2 = na1, nat
+          nt2 = ityp(na2)
+          !
+          DO m1 = 1, ehub_lm(nt1)
+          DO m2 = 1, ehub_lm(nt2)
+             ehub_v(na2,na1,m2,m1,1) = ehub_v(na1,na2,m1,m2,1)
+          ENDDO
+          ENDDO
+          !
+       ENDDO
+       ENDDO
+       !
+       ! Find the first nearest neighbors within adjacent negibor cells
+       ! and set the inter-site interaction parameters V
+       !
+       nnc = 2
+       !
+       DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+       DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+       DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+          !
+          IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+          !
+          DO na1 = 1, nat
+             nt1 = ityp(na1)
+             !
+          DO na2 = 1, nat
+             nt2 = ityp(na2)
+             !
+             IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+             !
+             IF ( (ehub_nn_leng_all(n1+ics,n2+ics,n3+ics,na1,na2) - MINVAL(ehub_nn_leng(:,:,:,na1,na2))) > eps .OR. na1 == na2 ) CYCLE
+             !
+             DO m1 = 1, ehub_lm(nt1)
+             DO m2 = 1, ehub_lm(nt2)
+                ehub_v(na1,na2,m1,m2,nnc) = ehub_v(na1,na2,m1,m2,1)
+             ENDDO ! m2
+             ENDDO ! m1
+             !
+          ENDDO ! na2
+          ENDDO ! na1
+          !
+          IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+          !
+       ENDDO ! n3
+       ENDDO ! n2
+       ENDDO ! n1
+       !
+       DO na1 = 1, nat
+       DO na2 = 1, nat
+          IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) &
+             ehub_v(na1,na2,:,:,1) = 0.0_DP
+       ENDDO
+       ENDDO
+       !
+    ENDIF
+    !
+  END SUBROUTINE init_lda_plus_v
+  !
+  SUBROUTINE deallocate_ldaV(flag)
+
+  LOGICAL, INTENT (IN) :: flag
+
+  IF ( flag ) THEN
+     IF ( ALLOCATED(ofst) )             DEALLOCATE ( ofst )
+     IF ( ALLOCATED(ofstv) )            DEALLOCATE ( ofstv )
+     IF ( ALLOCATED(ehub_nn_vect) )     DEALLOCATE ( ehub_nn_vect )
+     IF ( ALLOCATED(ehub_nn_leng) )     DEALLOCATE ( ehub_nn_leng )
+     IF ( ALLOCATED(ehub_nn_leng_all) ) DEALLOCATE ( ehub_nn_leng_all ) 
+     IF ( ALLOCATED(ehub_v) )           DEALLOCATE ( ehub_v )
+     IF ( ALLOCATED(ehub_u) )           DEALLOCATE ( ehub_u )
+     IF ( ALLOCATED(ehub_l) )           DEALLOCATE ( ehub_l )
+     IF ( ALLOCATED(ehub_v_diff) )      DEALLOCATE ( ehub_v_diff )
+     IF ( ALLOCATED(ehub_u_diff) )      DEALLOCATE ( ehub_u_diff )
+     IF ( ALLOCATED(d_spin_ldav) )      DEALLOCATE ( d_spin_ldav )
+  ENDIF
+  IF (ALLOCATED(wfcv)) DEALLOCATE (wfcv)
+ 
+
+  END SUBROUTINE deallocate_ldaV
+
+
+  SUBROUTINE copy_v_wfc( swfcatom, noncolin )
+  !
+  !  Copy (orthogonalized) atomic wavefunctions "swfcatom"
+  !  having a extended Hubbard correction to array "wfcv"
+  !
+  IMPLICIT NONE
+
+  COMPLEX(DP), INTENT(IN)           :: swfcatom(:,:)
+  LOGICAL    , INTENT(IN), OPTIONAL :: noncolin
+  INTEGER                           :: na, nt, m1, m2
+
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     m1 = 1
+     m2 = ehub_lm(nt)
+     !
+     IF ( PRESENT(noncolin) ) THEN
+        IF ( noncolin ) m2 = 2*m2
+     ENDIF
+     !
+     wfcv(:,ofstv(na)+m1:ofstv(na)+m2) = swfcatom(:,ofst(na)+m1:ofst(na)+m2)
+     !
+  ENDDO
+
+  END SUBROUTINE copy_v_wfc
+
+
+  SUBROUTINE write_ehub_uv
+
+  IMPLICIT NONE
+
+  INTEGER :: na, na1, na2
+  INTEGER :: nt, nt1, nt2
+  INTEGER :: m1, m2
+  INTEGER :: n1, n2, n3, nnc, ics
+
+  IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+     !
+     ! Write U matrix
+     !
+     WRITE ( stdout,'(a)' ) '                          '
+     WRITE ( stdout,'(a)' ) '     ---------------------'
+     WRITE ( stdout,'(a)' ) '     U[atom i, #orb, #orb]'
+     WRITE ( stdout,'(a)' ) '     ---------------------'
+ 
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        WRITE ( stdout,'(3(a,i2),a)' ) &
+              '     [ ', na, ', ', 2*MAXVAL(ehub_l(:,nt))-1, ', ', 2*MAXVAL(ehub_l(:,nt))-1, '  ]'
+        !
+        DO m1 = 1, ehub_lm(nt)
+           WRITE ( stdout,'(4x,16f9.4)' ) &
+                 (ehub_u(na,m1,m2) * rytoev, m2 = 1, ehub_lm(nt))
+        ENDDO
+        !
+        WRITE ( stdout,* ) ''
+        !
+     ENDDO ! na
+     !
+  ELSE
+     !
+     ! Write V matrices
+     !
+     WRITE ( stdout,'(a)' ) '                                        '
+     WRITE ( stdout,'(a)' ) '     -----------------------------------'
+     WRITE ( stdout,'(a)' ) '     V[atom i, atom j, #orb(i), #orb(j)]'
+     WRITE ( stdout,'(a)' ) '     -----------------------------------'
+     !
+     ics = ehub_csize + 1
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        WRITE ( stdout,'(4(a,i2),a)' ) &
+              '     [ ', na1, ', ', na2, ', ', ehub_lm(nt1), ', ', ehub_lm(nt2), '  ]'
+        !
+        WRITE ( stdout,'(a,i2,2i6,a)' ) '     [ ', 0, 0, 0, '  ]'
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           WRITE ( stdout,'(4x,16f9.4)' ) &
+                 (ehub_v(na1,na2,m1,m2,1) * rytoev, m2 = 1, ehub_lm(nt2))
+        ENDDO
+        !
+        WRITE ( stdout,* ) ''
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     nnc = 2
+     !
+     DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+     DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+     DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+        !
+        IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           IF ( ehub_lm(nt2) == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           WRITE ( stdout,'(4(a,i2),a)' ) &
+                 '     [ ', na1, ', ', na2, ', ', ehub_lm(nt1), ', ', ehub_lm(nt2), '  ]'
+           !
+           WRITE ( stdout,'(a,i2,2i6,a)' ) '     [ ', n1, n2, n3, '  ]'
+           !
+           DO m1 = 1, ehub_lm(nt1)
+              WRITE ( stdout,'(4x,16f9.4)' ) &
+                    (ehub_v(na1,na2,m1,m2,nnc) * rytoev, m2 = 1, ehub_lm(nt2))
+           ENDDO
+           !
+           WRITE ( stdout,* ) ''
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+        IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+  ENDIF
+
+  END SUBROUTINE write_ehub_uv
+  
+END MODULE ldaV
diff --git a/PW/src/memory_report.f90 b/PW/src/memory_report.f90
index 500d51bcb..f4a7fdfe1 100644
--- a/PW/src/memory_report.f90
+++ b/PW/src/memory_report.f90
@@ -43,6 +43,9 @@ SUBROUTINE memory_report()
   USE atom,      ONLY : rgrid
   USE xc_lib,    ONLY : xclib_dft_is
   USE ldaU,      ONLY : lda_plus_u, Hubbard_projectors, nwfcU
+  ! by LSH
+  USE ldaV,      ONLY : lda_plus_v, nwfcv
+  ! by LSH
   USE fixed_occ, ONLY : one_atom_occupations
   USE wannier_new,ONLY: use_wannier
   USE lsda_mod,  ONLY : nspin
@@ -123,6 +126,14 @@ SUBROUTINE memory_report()
      IF ( iverbosity > 0 ) WRITE( stdout, 1013 ) 'U proj. (w. buff.)', add/MB
      ram = ram + add
   END IF
+  ! by LSH
+  IF ( lda_plus_v .AND. Hubbard_projectors .NE. 'pseudo' ) THEN
+     add = complex_size * nwfcv * npol * npwx_l * nk ! also buffer 
+     IF ( iverbosity > 0 ) WRITE( stdout, 1013 ) 'V proj.', add/nk/MB
+     IF ( iverbosity > 0 ) WRITE( stdout, 1013 ) 'V proj. (w. buff.)', add/MB
+     ram = ram + add
+  END IF
+  ! by LSH
   !
   ! hybrid functionals
   IF ( xclib_dft_is('hybrid') ) THEN
diff --git a/PW/src/mix_rho.f90 b/PW/src/mix_rho.f90
index 5f4e4960a..264d24da8 100644
--- a/PW/src/mix_rho.f90
+++ b/PW/src/mix_rho.f90
@@ -44,6 +44,9 @@ SUBROUTINE mix_rho( input_rhout, rhoin, alphamix, dr2, tr2_min, iter, n_iter,&
   USE gcscf_module,   ONLY : lgcscf, gcscf_gh, gcscf_mu, gcscf_eps
   USE ldaU,           ONLY : lda_plus_u, lda_plus_u_kind, ldim_u, &
                              max_num_neighbors, nsg, nsgnew
+  ! by LSH
+  USE ldaV,          ONLY : lacbn0, dehubene, ehub_conv_thr
+  ! by LSH
   USE buffers,        ONLY : open_buffer, close_buffer, get_buffer, save_buffer
 #if defined (__OSCDFT)
   USE plugin_flags,     ONLY : use_oscdft
@@ -159,7 +162,13 @@ SUBROUTINE mix_rho( input_rhout, rhoin, alphamix, dr2, tr2_min, iter, n_iter,&
   !
   IF (dr2 < 0.0_DP) CALL errore('mix_rho','negative dr2',1)
   !
-  conv = ( dr2 < tr2 )
+  ! by LSH
+  IF ( lacbn0 ) THEN
+     conv = ( dr2 < tr2 .AND. dehubene < ehub_conv_thr )
+  ELSE
+     conv = ( dr2 < tr2 )
+     dehubene = -1.0_DP
+  ENDIF
   !
   IF ( lgcscf ) THEN
      !
@@ -170,7 +179,8 @@ SUBROUTINE mix_rho( input_rhout, rhoin, alphamix, dr2, tr2_min, iter, n_iter,&
   IF (use_oscdft) CALL oscdft_mix_rho(oscdft_ctx, conv)
 #endif
   !
-  IF ( conv .OR. dr2 < tr2_min ) THEN
+  IF ( conv .OR. dr2 < tr2_min .AND. dehubene < ehub_conv_thr ) THEN
+  ! by LSH
      !
      ! ... if convergence is achieved or if the self-consistency error (dr2) is
      ! ... smaller than the estimated error due to diagonalization (tr2_min),
diff --git a/PW/src/new_ns_v.f90 b/PW/src/new_ns_v.f90
new file mode 100644
index 000000000..2afecd6cb
--- /dev/null
+++ b/PW/src/new_ns_v.f90
@@ -0,0 +1,6751 @@
+!
+! Copyright (C) 2001-2020 Quantum ESPRESSO group
+! This file is distributed under the terms of the
+! GNU General Public License. See the file `License'
+! in the root directory of the present distribution,
+! or http://www.gnu.org/copyleft/gpl.txt .
+!
+!
+!-----------------------------------------------------------------------
+SUBROUTINE new_ns_v(ns)
+
+  USE kinds,                ONLY : DP
+  USE constants,            ONLY : tpi
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+  USE cell_base,            ONLY : at
+  USE klist,                ONLY : nks, ngk, xk
+  USE ldaV,                 ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                                   ehub_nn_vect, ehub_nn_dim,    &
+                                   ehub_nnnc, ehub_csize, wfcv,  &
+                                   nwfcv, ofstv
+  USE ldaU,                 ONLY : Hubbard_projectors
+  USE lsda_mod,             ONLY : lsda, current_spin, nspin, isk
+  USE wvfct,                ONLY : nbnd, npwx, wg
+  USE control_flags,        ONLY : gamma_only
+  USE io_global,            ONLY : stdout
+  USE wavefunctions,        ONLY : evc
+  USE io_files,             ONLY : nwordwfc, iunwfc, nwordwfcv, iunhubv
+  USE buffers,              ONLY : get_buffer
+  USE mp_pools,             ONLY : inter_pool_comm
+  USE mp,                   ONLY : mp_sum
+  USE becmod,               ONLY : bec_type, calbec,  &
+                                   allocate_bec_type, &
+                                   deallocate_bec_type
+  USE uspp_param,           ONLY : upf
+
+  IMPLICIT NONE
+
+  REAL(DP), INTENT(OUT) :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+
+  TYPE occmat_5
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:,:)
+  END TYPE occmat_5
+
+  TYPE(bec_type)        :: proj
+
+  COMPlEX(DP)           :: kphase
+
+  REAL(DP)              :: arg
+
+  TYPE(occmat_5)        :: n(ehub_nnnc)
+
+  INTEGER               :: ik, ibnd, is, i, npw
+  INTEGER               :: na1, na2, nt1, nt2
+  INTEGER               :: m1, m2, m3, m4
+  INTEGER               :: n1, n2, n3, nnc, ics
+
+  CALL start_clock('new_ns_v')
+  !
+  CALL allocate_bec_type(nwfcv, nbnd, proj)
+  !
+  DO i = 1, ehub_nnnc
+     ALLOCATE ( n(i)%O(ehub_lm_max,ehub_lm_max,nspin,nat,nat) ) ; n(i)%O = 0.0_DP
+  ENDDO
+  !
+  ics = ehub_csize + 1
+  !
+  DO ik = 1, nks
+     !
+     IF ( lsda ) current_spin = isk(ik)
+     npw = ngk(ik)
+     !
+     ! projection < wfcv | evc >
+     !
+     IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)     
+     IF ( Hubbard_projectors == 'pseudo' ) THEN
+        CALL errore('new_ns_v', 'Hubbard_projectors = pseudo is not supported', 1)
+     ELSE
+        IF ( nks > 1 ) CALL get_buffer(wfcv, nwordwfcv, iunhubv, ik)
+        CALL calbec(npw, wfcv, evc, proj)
+     ENDIF
+     !
+     ! calculate the occupation matrices n
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 n(1)%O(m1,m2,current_spin,na1,na2) = &
+                 n(1)%O(m1,m2,current_spin,na1,na2) + &
+                                        wg(ibnd,ik) * &
+                         proj%r(ofstv(na2)+m2,ibnd) * &
+                         proj%r(ofstv(na1)+m1,ibnd)
+              ENDDO
+           ELSE
+              DO ibnd = 1, nbnd
+                 n(1)%O(m1,m2,current_spin,na1,na2) = &
+                 n(1)%O(m1,m2,current_spin,na1,na2) + &
+                                        wg(ibnd,ik) * &
+                    DBLE(proj%k(ofstv(na2)+m2,ibnd) * &
+                   CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+              ENDDO
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           n(1)%O(m2,m1,current_spin,na2,na1) = n(1)%O(m1,m2,current_spin,na1,na2)
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     nnc = 2
+     !
+     DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+     DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+     DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+        !
+        IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+        !
+        arg = tpi * (                                              &
+         xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+         xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+         xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+        !
+        kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           IF ( ehub_lm(nt2) == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           DO m1 = 1, ehub_lm(nt1)
+           DO m2 = 1, ehub_lm(nt2)
+              !
+              IF ( gamma_only ) THEN
+                 DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                 DBLE(kphase*wg(ibnd,ik) * &
+                              proj%r(ofstv(na2)+m2,ibnd) * &
+                              proj%r(ofstv(na1)+m1,ibnd))
+                 ENDDO ! ibnd
+              ELSE
+                 DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                 DBLE(kphase*wg(ibnd,ik) * &
+                              proj%k(ofstv(na2)+m2,ibnd) * &
+                        CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                 ENDDO ! ibnd
+              ENDIF
+              !
+           ENDDO ! m2
+           ENDDO ! m1
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+        IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+     !
+  ENDDO ! ik
+  !
+  CALL deallocate_bec_type(proj)
+  !
+  DO i = 1, ehub_nnnc
+     CALL mp_sum(n(i)%O, inter_pool_comm)
+  ENDDO
+  !
+  DO i = 1, ehub_nnnc
+     IF ( nspin == 1 ) n(i)%O = 0.5_DP * n(i)%O
+  ENDDO
+  !
+  CALL symmetrize_n5(n)
+  !
+  ns = 0.0_DP
+  !
+  DO i = 1, ehub_nnnc
+     ns(:,:,:,:,:,i) = n(i)%O(:,:,:,:,:)
+     DEALLOCATE ( n(i)%O )
+  ENDDO
+  !
+  CALL stop_clock('new_ns_v')
+  !
+  RETURN
+  !
+END SUBROUTINE new_ns_v
+
+
+SUBROUTINE new_ns_a0(ns)
+
+  USE kinds,                ONLY : DP
+  USE constants,            ONLY : rytoev
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp, tau
+  USE cell_base,            ONLY : at, alat
+  USE klist,                ONLY : nks, ngk, xk
+  USE ldaV,                 ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                                   ehub_mixing, ehub_u, wfcv,    &
+                                   nwfcv, ofstv, remove_ehub_u,  &
+                                   write_ehub_uv
+  USE lsda_mod,             ONLY : lsda, current_spin, nspin, isk
+  USE wvfct,                ONLY : nbnd, wg
+  USE io_global,            ONLY : stdout
+  USE control_flags,        ONLY : gamma_only
+  USE wavefunctions,        ONLY : evc
+  USE io_files,             ONLY : nwordwfc, iunwfc, nwordwfcv, iunhubv
+  USE buffers,              ONLY : get_buffer
+  USE mp_pools,             ONLY : inter_pool_comm
+  USE mp,                   ONLY : mp_sum
+  USE becmod,               ONLY : bec_type, calbec,  &
+                                   allocate_bec_type, &
+                                   deallocate_bec_type
+  USE uspp_param,           ONLY : upf
+
+  IMPLICIT NONE
+
+  REAL(DP),    INTENT(OUT) :: ns(ehub_lm_max,ehub_lm_max,nspin,nat)
+
+  TYPE hubbard_ene_3
+     REAL(DP), ALLOCATABLE :: U(:,:,:)
+     REAL(DP), ALLOCATABLE :: J(:,:,:)
+  END TYPE hubbard_ene_3
+
+  TYPE occmat_4
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:)
+  END TYPE occmat_4
+
+  TYPE(bec_type)           :: proj
+
+  TYPE(hubbard_ene_3)      :: A0, HF
+
+  TYPE(occmat_4)           :: num(nbnd), n, p
+
+  REAL(DP),    ALLOCATABLE :: ehub_u_(:,:,:)
+
+  REAL(DP), EXTERNAL       :: compute_eri
+  REAL(DP)                 :: c1(6), c2(6), c3(6), c4(6)
+
+  INTEGER                  :: i, ik, ibnd, is, npw
+  INTEGER                  :: na, nt, l, m
+  INTEGER                  :: na1, na2
+  INTEGER                  :: nt1, nt2
+  INTEGER                  :: m1, m2, m3, m4
+  INTEGER                  :: l1, l2, l3, l4
+
+  CALL start_clock('new_ns_a0')
+  !
+  CALL allocate_bec_type(nwfcv, nbnd, proj)
+  !
+  ALLOCATE ( n%O(ehub_lm_max,ehub_lm_max,nspin,nat) ) ; n%O = 0.0_DP
+  ALLOCATE ( p%O(ehub_lm_max,ehub_lm_max,nspin,nat) ) ; p%O = 0.0_DP
+  ALLOCATE ( A0%U(4,4,nat), A0%J(4,4,nat) )
+  ALLOCATE ( HF%U(4,4,nat), HF%J(4,4,nat) )
+  !
+  DO ik = 1, nks
+     !
+     IF ( lsda ) current_spin = isk(ik)
+     npw = ngk(ik)
+     !
+     ! projection < wfcv | evc >
+     !
+     IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+     IF ( nks > 1 ) CALL get_buffer(wfcv, nwordwfcv, iunhubv, ik)
+     CALL calbec(npw, wfcv, evc, proj)
+     !
+     ! calculate the occupation matrices n
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt)
+        DO m2 = 1, ehub_lm(nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 n%O(m1,m2,current_spin,na) = &
+                 n%O(m1,m2,current_spin,na) + &
+                                wg(ibnd,ik) * &
+                  proj%r(ofstv(na)+m2,ibnd) * &
+                  proj%r(ofstv(na)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 n%O(m1,m2,current_spin,na) = &
+                 n%O(m1,m2,current_spin,na) + &
+                                wg(ibnd,ik) * &
+             DBLE(proj%k(ofstv(na)+m2,ibnd) * &
+            CONJG(proj%k(ofstv(na)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na
+     !
+     ! calculate the renormalized occupations N(ACBN0)
+     !
+     DO i = 1, nbnd
+        ALLOCATE ( num(i)%O(4,4,nspin,ntyp) ) ; num(i)%O = 0.0_DP
+        ALLOCATE ( num(i)%T(4,4,nspin,ntyp) ) ; num(i)%T = 0.0_DP
+     ENDDO
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m = 1, ehub_lm(nt)
+           !
+           l = ehub_l(m,nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 num(ibnd)%O(l,l,current_spin,nt) = &
+                 num(ibnd)%O(l,l,current_spin,nt) + &
+                         proj%r(ofstv(na)+m,ibnd) * &
+                         proj%r(ofstv(na)+m,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 num(ibnd)%O(l,l,current_spin,nt) = &
+                 num(ibnd)%O(l,l,current_spin,nt) + &
+                    DBLE(proj%k(ofstv(na)+m,ibnd) * &
+                   CONJG(proj%k(ofstv(na)+m,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m
+        !
+     ENDDO ! na
+     !
+     DO i = 1, nbnd
+        !
+        DO nt1 = 1, ntyp
+        DO nt2 = 1, ntyp
+           !
+           IF ( upf(nt1)%psd /= upf(nt2)%psd ) CYCLE
+           !
+           num(i)%T(:,:,:,nt1) = num(i)%T(:,:,:,nt1) &
+                               + num(i)%O(:,:,:,nt2)
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+     ENDDO ! i
+     !
+     DO i = 1, nbnd
+        num(i)%O = num(i)%T
+        DEALLOCATE ( num(i)%T )
+     ENDDO
+     !
+     ! calculate the renormalized occupation matrices P(ACBN0)
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt)
+           !
+           l1 = ehub_l(m1,nt)
+           !
+        DO m2 = 1, ehub_lm(nt)
+           !
+           l2 = ehub_l(m2,nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 p%O(m1,m2,current_spin,na) = &
+                 p%O(m1,m2,current_spin,na) + &
+                         num(ibnd)%O(l1,l2,   &
+                           current_spin,nt) * &
+                                wg(ibnd,ik) * &
+                  proj%r(ofstv(na)+m2,ibnd) * &
+                  proj%r(ofstv(na)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 p%O(m1,m2,current_spin,na) = &
+                 p%O(m1,m2,current_spin,na) + &
+                         num(ibnd)%O(l1,l2,   &
+                           current_spin,nt) * &
+                                wg(ibnd,ik) * &
+             DBLE(proj%k(ofstv(na)+m2,ibnd) * &
+            CONJG(proj%k(ofstv(na)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na
+     !
+     DO i = 1, nbnd
+        DEALLOCATE ( num(i)%O )
+     ENDDO
+
+  ENDDO ! ik
+
+  CALL deallocate_bec_type(proj)
+
+  CALL mp_sum(n%O, inter_pool_comm)
+  CALL mp_sum(p%O, inter_pool_comm)
+
+  IF ( nspin == 1 ) n%O = 0.5_DP * n%O
+  !
+  CALL symmetrize_n4(n)
+  !
+  ns = 0.0_DP
+  !
+  ns = n%O
+  !
+  DEALLOCATE (n%O)
+  !
+  IF ( nspin == 1 ) p%O = 0.5_DP * p%O
+  !
+  CALL symmetrize_n4(p)
+  !
+  ! calculate ACBN0 U & J
+  !
+  A0%U = 0.0_DP ; A0%J = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     l1 = 0
+     DO m1 = 1, ehub_lm(nt)
+        CALL orberi(ehub_l(m1,nt), l1)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m1,nt), c1)
+        !
+     l2 = 0
+     DO m2 = 1, ehub_lm(nt)
+        CALL orberi(ehub_l(m2,nt), l2)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m2,nt), c2)
+        !
+     l3 = 0
+     DO m3 = 1, ehub_lm(nt)
+        IF ( ehub_l(m3,nt) /= ehub_l(m1,nt) ) CYCLE
+        CALL orberi(ehub_l(m3,nt), l3)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m3,nt), c3)
+        !
+     l4 = 0
+     DO m4 = 1, ehub_lm(nt)
+        IF ( ehub_l(m4,nt) /= ehub_l(m2,nt) ) CYCLE
+        CALL orberi(ehub_l(m4,nt), l4)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m4,nt), c4)
+        !
+        IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+              A0%U(ehub_l(m1,nt),ehub_l(m2,nt),na)  = &
+              A0%U(ehub_l(m1,nt),ehub_l(m2,nt),na)  + &
+                  (p%O(m3,m1,1,na)*p%O(m4,m2,2,na)  + &
+                   p%O(m3,m1,2,na)*p%O(m4,m2,1,na)) * &
+                          compute_eri(l3,l1,l4,l2,    &
+                    tau(:,na)*alat,tau(:,na)*alat,    &
+                    tau(:,na)*alat,tau(:,na)*alat,    &
+                                      c3,c1,c4,c2)
+        ELSE
+              A0%U(ehub_l(m1,nt),ehub_l(m2,nt),na)  = &
+              A0%U(ehub_l(m1,nt),ehub_l(m2,nt),na)  + &
+                  (p%O(m3,m1,1,na)*p%O(m4,m2,1,na)  + &
+                   p%O(m3,m1,2,na)*p%O(m4,m2,2,na)  + &
+                   p%O(m3,m1,1,na)*p%O(m4,m2,2,na)  + &
+                   p%O(m3,m1,2,na)*p%O(m4,m2,1,na)) * &
+                          compute_eri(l3,l1,l4,l2,    &
+                    tau(:,na)*alat,tau(:,na)*alat,    &
+                    tau(:,na)*alat,tau(:,na)*alat,    &
+                                      c3,c1,c4,c2)
+              A0%J(ehub_l(m1,nt),ehub_l(m2,nt),na)  = &
+              A0%J(ehub_l(m1,nt),ehub_l(m2,nt),na)  + &
+                  (p%O(m3,m1,1,na)*p%O(m4,m2,1,na)  + &
+                   p%O(m3,m1,2,na)*p%O(m4,m2,2,na)) * &
+                          compute_eri(l3,l2,l4,l1,    &
+                    tau(:,na)*alat,tau(:,na)*alat,    &
+                    tau(:,na)*alat,tau(:,na)*alat,    &
+                                      c3,c2,c4,c1)
+        ENDIF
+        !
+     ENDDO ! m4
+     ENDDO ! m3
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  DEALLOCATE (p%O)
+  !
+  HF%U = 0.0_DP ; HF%J = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt)
+     DO m2 = 1, ehub_lm(nt)
+        !
+        IF ( m1 == m2 ) THEN
+             HF%U(ehub_l(m1,nt),ehub_l(m2,nt),na) = &
+             HF%U(ehub_l(m1,nt),ehub_l(m2,nt),na) + &
+                    ns(m1,m1,1,na)*ns(m2,m2,2,na) + &
+                    ns(m1,m1,2,na)*ns(m2,m2,1,na)
+        ELSE
+             HF%U(ehub_l(m1,nt),ehub_l(m2,nt),na) = &
+             HF%U(ehub_l(m1,nt),ehub_l(m2,nt),na) + &
+                    ns(m1,m1,1,na)*ns(m2,m2,1,na) + &
+                    ns(m1,m1,2,na)*ns(m2,m2,2,na) + &
+                    ns(m1,m1,1,na)*ns(m2,m2,2,na) + &
+                    ns(m1,m1,2,na)*ns(m2,m2,1,na)
+ 
+             HF%J(ehub_l(m1,nt),ehub_l(m2,nt),na) = &
+             HF%J(ehub_l(m1,nt),ehub_l(m2,nt),na) + &
+                    ns(m1,m1,1,na)*ns(m2,m2,1,na) + &
+                    ns(m1,m1,2,na)*ns(m2,m2,2,na)
+        ENDIF
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  ALLOCATE (ehub_u_(nat,ehub_lm_max,ehub_lm_max)) ; ehub_u_ = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt)
+     DO m2 = 1, ehub_lm(nt)
+        !
+        IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+           ehub_u_(na,m1,m2) =                          &
+                 A0%U(ehub_l(m1,nt),ehub_l(m2,nt),na) / &
+                 HF%U(ehub_l(m1,nt),ehub_l(m2,nt),na) * &
+                      remove_ehub_u(nt,ehub_l(m1,nt)) * &
+                      remove_ehub_u(nt,ehub_l(m2,nt))
+        ELSE
+           ehub_u_(na,m1,m2) =                          &
+                (A0%U(ehub_l(m1,nt),ehub_l(m2,nt),na) / &
+                 HF%U(ehub_l(m1,nt),ehub_l(m2,nt),na) - &
+                 A0%J(ehub_l(m1,nt),ehub_l(m2,nt),na) / &
+                 HF%J(ehub_l(m1,nt),ehub_l(m2,nt),na))* &
+                      remove_ehub_u(nt,ehub_l(m1,nt)) * &
+                      remove_ehub_u(nt,ehub_l(m2,nt))
+        ENDIF
+        !
+        ehub_u(na,m1,m2) =                               &
+              (1.0_DP - ehub_mixing)*ehub_u (na,m1,m2) + &
+              (         ehub_mixing)*ehub_u_(na,m1,m2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = m1, ehub_lm(nt1)
+        !
+        ehub_u(na1,m1,m2) = 0.5D0 * (ehub_u(na1,m1,m2) + &
+                                     ehub_u(na1,m2,m1))
+        !
+        ehub_u(na1,m2,m1) = ehub_u(na1,m1,m2)
+        !
+     ENDDO
+     ENDDO
+     !
+  ENDDO
+  !
+  DEALLOCATE ( ehub_u_ )
+  DEALLOCATE ( A0%U, A0%J )
+  DEALLOCATE ( HF%U, HF%J )
+
+  CALL write_ehub_uv
+
+  CALL stop_clock('new_ns_a0')
+
+  RETURN
+
+END SUBROUTINE new_ns_a0
+
+
+SUBROUTINE new_ns_e0_1(ns)
+
+  USE kinds,                ONLY : DP
+  USE constants,            ONLY : tpi, rytoev
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp, tau
+  USE cell_base,            ONLY : at, alat
+  USE klist,                ONLY : nks, ngk, xk
+  USE ldaV,                 ONLY : ehub_lm_max, ehub_lm, ehub_l,                      &
+                                   ehub_nn_vect, ehub_nn_leng, ehub_nn_dim,           &
+                                   ehub_csize, ehub_nnnc, ehub_mixing, ehub_conv_thr, &
+                                   ehub_v, ehub_v_diff, remove_ehub_u, write_ehub_uv, &
+                                   wfcv, nwfcv, ofstv, stop_acbn0
+  USE lsda_mod,             ONLY : lsda, current_spin, nspin, isk
+  USE wvfct,                ONLY : nbnd, npwx, wg
+  USE io_global,            ONLY : stdout
+  USE control_flags,        ONLY : gamma_only
+  USE wavefunctions,        ONLY : evc
+  USE io_files,             ONLY : nwordwfc, iunwfc, nwordwfcv, iunhubv
+  USE buffers,              ONLY : get_buffer
+  USE mp_pools,             ONLY : inter_pool_comm
+  USE mp,                   ONLY : mp_sum
+  USE becmod,               ONLY : bec_type, calbec,  &
+                                   allocate_bec_type, &
+                                   deallocate_bec_type
+  USE uspp_param,           ONLY : upf
+
+  IMPLICIT NONE
+
+  REAL(DP), INTENT(OUT)    :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+
+  TYPE hubbard_ene_4
+     REAL(DP), ALLOCATABLE :: U(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: V(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: J(:,:,:,:)
+  END TYPE hubbard_ene_4
+
+  TYPE occmat_4
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:)
+  END TYPE occmat_4
+
+  TYPE occmat_5
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:,:)
+  END TYPE occmat_5
+
+  TYPE(bec_type)           :: proj
+
+  TYPE(hubbard_ene_4)      :: E0(ehub_nnnc)
+  TYPE(hubbard_ene_4)      :: HF(ehub_nnnc)
+
+  TYPE(occmat_5)           :: n(ehub_nnnc)
+  TYPE(occmat_5)           :: p(ehub_nnnc)
+  TYPE(occmat_5)           :: num(nbnd)
+
+  TYPE(occmat_4)           :: dm0
+  TYPE(occmat_4)           :: dm1(ntyp,4)
+
+  COMPLEX(DP)              :: kphase
+
+  REAL(DP), ALLOCATABLE    :: ehub_v_(:,:,:,:)
+
+  REAL(DP)                 :: arg
+  REAL(DP)                 :: ntau(3,nat)
+  REAL(DP)                 :: compute_eri
+  REAL(DP)                 :: c1(6), c2(6), c3(6), c4(6)
+
+  INTEGER                  :: npw, nw
+  INTEGER                  :: i, ik, ibnd, is, ix
+  INTEGER                  :: na, nt, m, l
+  INTEGER                  :: na1, na2
+  INTEGER                  :: nt1, nt2
+  INTEGER                  :: m1, m2, m3, m4
+  INTEGER                  :: l1, l2, l3, l4
+  INTEGER                  :: n1, n2, n3
+  INTEGER                  :: nnc, ics
+
+  CALL start_clock('new_ns_e0_#1')
+
+  IF ( stop_acbn0 ) THEN
+     !
+     IF ( MAXVAL(ehub_v_diff(:,:,:,:,:)) < SQRT(ehub_conv_thr) ) THEN
+        CALL new_ns_v(ns)
+        GOTO 1
+     ENDIF
+     !
+     ehub_v_diff = 0.0_DP
+     !
+  ENDIF
+
+  CALL allocate_bec_type(nwfcv, nbnd, proj)
+  !
+  ALLOCATE ( dm0%O(ehub_lm_max,ehub_lm_max,nspin,nat) ) ; dm0%O = 0.0_DP
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        ALLOCATE ( dm1(nt,l)%O(ehub_lm_max,ehub_lm_max,nspin,nat) ) ; dm1(nt,l)%O = 0.0_DP
+     ENDDO
+  ENDDO
+  !
+  DO i = 1, ehub_nnnc
+     ALLOCATE ( n(i)%O(ehub_lm_max,ehub_lm_max,nspin,nat,nat) ) ; n(i)%O = 0.0_DP
+     ALLOCATE ( p(i)%O(ehub_lm_max,ehub_lm_max,nspin,nat,nat) ) ; p(i)%O = 0.0_DP
+     ALLOCATE ( E0(i)%V(4,4,nat,nat), E0(i)%J(4,4,nat,nat) )
+     ALLOCATE ( HF(i)%V(4,4,nat,nat), HF(i)%J(4,4,nat,nat) )
+  ENDDO
+
+  ics = ehub_csize + 1
+  !
+  DO ik = 1, nks
+     !
+     IF ( lsda ) current_spin = isk(ik)
+     npw = ngk(ik)
+     !
+     ! projection < wfcv | evc >
+     !
+     IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+     IF ( nks > 1 ) CALL get_buffer(wfcv, nwordwfcv, iunhubv, ik)
+     CALL calbec(npw, wfcv, evc, proj)
+     !
+     ! calculate the occupation matrices n
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2 ) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 n(1)%O(m1,m2,current_spin,na1,na2) = &
+                 n(1)%O(m1,m2,current_spin,na1,na2) + &
+                                        wg(ibnd,ik) * &
+                         proj%r(ofstv(na2)+m2,ibnd) * &
+                         proj%r(ofstv(na1)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 n(1)%O(m1,m2,current_spin,na1,na2) = &
+                 n(1)%O(m1,m2,current_spin,na1,na2) + &
+                                        wg(ibnd,ik) * &
+                    DBLE(proj%k(ofstv(na2)+m2,ibnd) * &
+                   CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           n(1)%O(m2,m1,current_spin,na2,na1) = n(1)%O(m1,m2,current_spin,na1,na2)
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     nnc = 2
+     !
+     DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+     DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+     DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+        !
+        IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+        !
+        arg = tpi * (                                              &
+         xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+         xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+         xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+        !
+        kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           IF ( ehub_lm(nt2) == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           DO m1 = 1, ehub_lm(nt1)
+           DO m2 = 1, ehub_lm(nt2)
+              !
+              IF ( gamma_only ) THEN
+                 DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                             wg(ibnd,ik) * &
+                              proj%r(ofstv(na2)+m2,ibnd) * &
+                              proj%r(ofstv(na1)+m1,ibnd)
+                 ENDDO ! ibnd
+              ELSE
+                 DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                             wg(ibnd,ik) * &
+                                           DBLE((kphase) * &
+                              proj%k(ofstv(na2)+m2,ibnd) * &
+                        CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                 ENDDO ! ibnd
+              ENDIF
+              !
+           ENDDO ! m2
+           ENDDO ! m1
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+        IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+     !
+     ! calculate the renormalized occupations N(ACBN0)
+     !
+     DO i = 1, nbnd
+        ALLOCATE ( num(i)%O(4,4,nspin,ntyp,ntyp) ) ; num(i)%O = 0.0_DP
+        ALLOCATE ( num(i)%T(4,4,nspin,ntyp,ntyp) ) ; num(i)%T = 0.0_DP
+     ENDDO
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m = 1, ehub_lm(nt)
+           !
+           l = ehub_l(m,nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 num(ibnd)%O(l,l,current_spin,nt,nt) = &
+                 num(ibnd)%O(l,l,current_spin,nt,nt) + &
+                            proj%r(ofstv(na)+m,ibnd) * &
+                            proj%r(ofstv(na)+m,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 num(ibnd)%O(l,l,current_spin,nt,nt) = &
+                 num(ibnd)%O(l,l,current_spin,nt,nt) + &
+                       DBLE(proj%k(ofstv(na)+m,ibnd) * &
+                      CONJG(proj%k(ofstv(na)+m,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m
+        !
+     ENDDO ! na
+     !
+     DO ibnd = 1, nbnd
+        !
+        DO nt1 = 1, ntyp
+        DO nt2 = 1, ntyp
+           !
+           IF ( upf(nt1)%psd /= upf(nt2)%psd ) CYCLE
+           !
+           num(ibnd)%T(:,:,:,nt1,nt1) = num(ibnd)%T(:,:,:,nt1,nt1) + &
+                                        num(ibnd)%O(:,:,:,nt2,nt2)
+           !
+        ENDDO ! nt2
+        ENDDO ! nt1
+        !
+     ENDDO ! ibnd
+     !
+     DO ibnd = 1, nbnd
+        !
+        DO nt1 = 1, ntyp
+        DO nt2 = 1, ntyp
+           !
+           DO l1 = 1, 4
+           DO l2 = 1, 4
+              !
+              ! Our definition
+              num(ibnd)%T(l1,l2,:,nt1,nt2) = num(ibnd)%T(l1,l1,:,nt1,nt1) + &
+                                             num(ibnd)%T(l2,l2,:,nt2,nt2)
+              !
+              IF ( upf(nt1)%psd == upf(nt2)%psd )                           &
+              num(ibnd)%T(l1,l2,:,nt1,nt2) = num(ibnd)%T(l1,l2,:,nt1,nt2) / &
+                                             2.0_DP
+              !
+              ! The definition of Nicolas Tancogne-Dejean & Angel Rubio
+!             num(ibnd)%T(l1,l2,:,nt1,nt2) = SQRT(num(ibnd)%T(l1,l1,:,nt1,nt1) * &
+!                                                 num(ibnd)%T(l2,l2,:,nt2,nt2))
+              !
+           ENDDO ! l2
+           ENDDO ! l1
+           !
+        ENDDO ! nt2
+        ENDDO ! nt1
+        !
+     ENDDO ! ibnd
+     !
+     DO ibnd = 1, nbnd
+        num(ibnd)%O = num(ibnd)%T
+        DEALLOCATE ( num(ibnd)%T )
+     ENDDO
+     !
+     ! calculate the renormalized occupation matrices P(ACBN0)
+     !
+     ! 1) P^II (dm0, dm1)
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt)
+           !
+           l1 = ehub_l(m1,nt)
+           !
+        DO m2 = 1, ehub_lm(nt)
+           !
+           l2 = ehub_l(m2,nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 dm0%O(m1,m2,current_spin,na) = &
+                 dm0%O(m1,m2,current_spin,na) + &
+                           num(ibnd)%O(l1,l2,   &
+                          current_spin,nt,nt) * &
+                                  wg(ibnd,ik) * &
+                    proj%r(ofstv(na)+m2,ibnd) * &
+                    proj%r(ofstv(na)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 dm0%O(m1,m2,current_spin,na) = &
+                 dm0%O(m1,m2,current_spin,na) + &
+                           num(ibnd)%O(l1,l2,   &
+                          current_spin,nt,nt) * &
+                                  wg(ibnd,ik) * &
+               DBLE(proj%k(ofstv(na)+m2,ibnd) * &
+              CONJG(proj%k(ofstv(na)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na
+
+     DO nt = 1, ntyp
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO l = 1, 4
+           !
+           DO na1 = 1, nat
+              nt1 = ityp(na1)
+              !
+              IF ( ehub_lm(nt1) == 0 ) CYCLE
+              !
+              DO m1 = 1, ehub_lm(nt1)
+              DO m2 = 1, ehub_lm(nt1)
+                 !
+                 IF ( gamma_only ) THEN
+                    DO ibnd = 1, nbnd
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) = &
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) + &
+                             num(ibnd)%O(ehub_l(m1,nt1),l,   &
+                                      current_spin,nt1,nt) * &
+                                               wg(ibnd,ik) * &
+                                proj%r(ofstv(na1)+m2,ibnd) * &
+                                proj%r(ofstv(na1)+m1,ibnd)
+                    ENDDO ! ibnd
+                 ELSE
+                    DO ibnd = 1, nbnd
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) = &
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) + &
+                             num(ibnd)%O(ehub_l(m1,nt1),l,   &
+                                      current_spin,nt1,nt) * &
+                                               wg(ibnd,ik) * &
+                           DBLE(proj%k(ofstv(na1)+m2,ibnd) * &
+                          CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                    ENDDO ! ibnd
+                 ENDIF
+                 !
+              ENDDO ! m2
+              ENDDO ! m1
+              !
+           ENDDO ! na1
+           !
+        ENDDO ! l
+        !
+     ENDDO ! nt
+     !
+     ! 2) P^IJ
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           l1 = ehub_l(m1,nt1)
+           !
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           l2 = ehub_l(m2,nt2)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                   p(1)%O(m1,m2,current_spin,na1,na2) = &
+                   p(1)%O(m1,m2,current_spin,na1,na2) + &
+                                   num(ibnd)%O(l1,l2,   &
+                                current_spin,nt1,nt2) * &
+                                          wg(ibnd,ik) * &
+                           proj%r(ofstv(na2)+m2,ibnd) * &
+                           proj%r(ofstv(na1)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                   p(1)%O(m1,m2,current_spin,na1,na2) = &
+                   p(1)%O(m1,m2,current_spin,na1,na2) + &
+                                   num(ibnd)%O(l1,l2,   &
+                                current_spin,nt1,nt2) * &
+                                          wg(ibnd,ik) * &
+                      DBLE(proj%k(ofstv(na2)+m2,ibnd) * &
+                     CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           p(1)%O(m2,m1,current_spin,na2,na1) = p(1)%O(m1,m2,current_spin,na1,na2)
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     nnc = 2
+     !
+     DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+     DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+     DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+        !
+        IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+        !
+        arg = tpi * (                                              &
+         xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+         xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+         xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+        !
+        kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           IF ( ehub_lm(nt2) == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           DO m1 = 1, ehub_lm(nt1)
+              !
+              l1 = ehub_l(m1,nt1)
+              !
+           DO m2 = 1, ehub_lm(nt2)
+              !
+              l2 = ehub_l(m2,nt2)
+              !
+              IF ( gamma_only ) THEN
+                 DO ibnd = 1, nbnd
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                      num(ibnd)%O(l1,l2,   &
+                                   current_spin,nt1,nt2) * &
+                                             wg(ibnd,ik) * &
+                              proj%r(ofstv(na2)+m2,ibnd) * &
+                              proj%r(ofstv(na1)+m1,ibnd)
+                 ENDDO ! ibnd
+              ELSE
+                 DO ibnd = 1, nbnd
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                      num(ibnd)%O(l1,l2,   &
+                                   current_spin,nt1,nt2) * &
+                                             wg(ibnd,ik) * &
+                                           DBLE((kphase) * &
+                              proj%k(ofstv(na2)+m2,ibnd) * &
+                        CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                 ENDDO ! ibnd
+              ENDIF
+              !
+           ENDDO ! m2
+           ENDDO ! m1
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+        IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+     !
+     DO i = 1, nbnd
+        DEALLOCATE ( num(i)%O )
+     ENDDO
+
+  ENDDO ! ik
+
+  CALL deallocate_bec_type(proj)
+
+  CALL mp_sum(dm0%O, inter_pool_comm)
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        CALL mp_sum(dm1(nt,l)%O, inter_pool_comm)
+     ENDDO
+  ENDDO
+  !
+  DO i = 1, ehub_nnnc
+     CALL mp_sum(n(i)%O, inter_pool_comm)
+     CALL mp_sum(p(i)%O, inter_pool_comm)
+  ENDDO
+
+  DO i = 1, ehub_nnnc
+     IF ( nspin == 1 ) n(i)%O = 0.5_DP * n(i)%O
+  ENDDO
+  !
+  CALL symmetrize_n5(n)
+  !
+  ns = 0.0_DP
+  !
+  DO i = 1, ehub_nnnc
+     ns(:,:,:,:,:,i) = n(i)%O(:,:,:,:,:)
+     DEALLOCATE ( n(i)%O )
+  ENDDO
+  !
+  IF ( nspin == 1 ) dm0%O = 0.5_DP * dm0%O
+  !
+  CALL symmetrize_n4(dm0)
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        IF ( nspin == 1 ) dm1(nt,l)%O = 0.5_DP * dm1(nt,l)%O
+     ENDDO
+  ENDDO
+  !
+  CALL symmetrize_n4m(dm1)
+  !
+  DO i = 1, ehub_nnnc
+     IF ( nspin == 1 ) p(i)%O = 0.5_DP * p(i)%O
+  ENDDO
+  !
+  CALL symmetrize_n5(p)
+  !
+  ! on-site interaction: U_ij^II
+  !
+  E0(1)%V = 0.0_DP ; E0(1)%J = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     l1 = 0
+     DO m1 = 1, ehub_lm(nt)
+        CALL orberi(ehub_l(m1,nt), l1)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m1,nt), c1)
+        !
+     l2 = 0
+     DO m2 = 1, ehub_lm(nt)
+        CALL orberi(ehub_l(m2,nt), l2)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m2,nt), c2)
+        !
+     l3 = 0
+     DO m3 = 1, ehub_lm(nt)
+        IF ( ehub_l(m3,nt) /= ehub_l(m1,nt) ) CYCLE
+        CALL orberi(ehub_l(m3,nt), l3)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m3,nt), c3)
+        !
+     l4 = 0
+     DO m4 = 1, ehub_lm(nt)
+        IF ( ehub_l(m4,nt) /= ehub_l(m2,nt) ) CYCLE
+        CALL orberi(ehub_l(m4,nt), l4)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m4,nt), c4)
+        !
+        IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+                 (dm0%O(m3,m1,1,na)*dm0%O(m4,m2,2,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,1,na)) * &
+                             compute_eri(l3,l1,l4,l2,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                                         c3,c1,c4,c2)
+        ELSE
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+                 (dm0%O(m3,m1,1,na)*dm0%O(m4,m2,1,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,2,na)  + &
+                  dm0%O(m3,m1,1,na)*dm0%O(m4,m2,2,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,1,na)) * &
+                             compute_eri(l3,l1,l4,l2,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                                         c3,c1,c4,c2)
+
+           E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+           E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+                 (dm0%O(m3,m1,1,na)*dm0%O(m4,m2,1,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,2,na)) * &
+                             compute_eri(l3,l2,l4,l1,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                                         c3,c2,c4,c1)
+        ENDIF
+        !
+     ENDDO ! m4
+     ENDDO ! m3
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  HF(1)%V = 0.0_DP ; HF(1)%J = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt)
+     DO m2 = 1, ehub_lm(nt)
+        !
+        IF ( m1 == m2 ) THEN
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,2,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,1,na,na,1)
+        ELSE
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,1,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,2,na,na,1) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,2,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,1,na,na,1)
+
+            HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+            HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,1,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,2,na,na,1)
+        ENDIF
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  ALLOCATE ( ehub_v_(nat,nat,ehub_lm_max,ehub_lm_max) ) ; ehub_v_ = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt)
+     DO m2 = 1, ehub_lm(nt)
+        !
+        IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+           ehub_v_(na,na,m1,m2) =                           &
+               E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) / &
+               HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) * &
+                          remove_ehub_u(nt,ehub_l(m1,nt)) * &
+                          remove_ehub_u(nt,ehub_l(m2,nt))
+        ELSE
+           ehub_v_(na,na,m1,m2) =                            &
+              (E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  / &
+               HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  - &
+               E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  / &
+               HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)) * &
+                          remove_ehub_u(nt,ehub_l(m1,nt))  * &
+                          remove_ehub_u(nt,ehub_l(m2,nt))
+        ENDIF
+        !
+        IF ( stop_acbn0 ) ehub_v_diff(na,na,m1,m2,1) = ABS( ehub_v (na,na,m1,m2,1) &
+                                                     -      ehub_v_(na,na,m1,m2  ) )
+        !
+        ehub_v(na,na,m1,m2,1)                                 &
+            = (1.0_DP - ehub_mixing)*ehub_v (na,na,m1,m2,1) + &
+              (         ehub_mixing)*ehub_v_(na,na,m1,m2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+
+  !
+  ! inter-site interaction: U_ij^IJ (I /= J)
+  !
+  ! ... in the unit cell
+  !
+  E0(1)%V = 0.0_DP
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     l1 = 0
+     DO m1 = 1, ehub_lm(nt1)
+        CALL orberi(ehub_l(m1,nt1), l1)
+        CALL pao_3g(upf(nt1)%psd, ehub_l(m1,nt1), c1)
+        !
+     l2 = 0
+     DO m2 = 1, ehub_lm(nt2)
+        CALL orberi(ehub_l(m2,nt2), l2)
+        CALL pao_3g(upf(nt2)%psd, ehub_l(m2,nt2), c2)
+        !
+     l3 = 0
+     DO m3 = 1, ehub_lm(nt1)
+        IF ( ehub_l(m3,nt1) /= ehub_l(m1,nt1) ) CYCLE
+        CALL orberi(ehub_l(m3,nt1), l3)
+        CALL pao_3g(upf(nt1)%psd, ehub_l(m3,nt1), c3)
+        !
+     l4 = 0
+     DO m4 = 1, ehub_lm(nt2)
+        IF ( ehub_l(m4,nt2) /= ehub_l(m2,nt2) ) CYCLE
+        CALL orberi(ehub_l(m4,nt2), l4)
+        CALL pao_3g(upf(nt2)%psd, ehub_l(m4,nt2), c4)
+        !
+        E0(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  = &
+        E0(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  + &
+               (dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  + &
+                dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  - &
+                               p(1)%O(m3,m2,1,na1,na2)  * &
+                               p(1)%O(m4,m1,1,na2,na1)  - &
+                               p(1)%O(m3,m2,2,na1,na2)  * &
+                               p(1)%O(m4,m1,2,na2,na1)) * &
+                              compute_eri(l3,l1,l4,l2,    &
+                      tau(:,na1)*alat,tau(:,na1)*alat,    &
+                      tau(:,na2)*alat,tau(:,na2)*alat,    &
+                                          c3,c1,c4,c2)
+        !
+     ENDDO ! m4
+     ENDDO ! m3
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        E0(1)%V(ehub_l(m2,nt2),ehub_l(m1,nt1),na2,na1) = E0(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  HF(1)%V = 0.0_DP
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        HF(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2) = &
+        HF(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2) + &
+         ns(m1,m1,1,na1,na1,1) * ns(m2,m2,1,na2,na2,1) + &
+         ns(m1,m1,2,na1,na1,1) * ns(m2,m2,2,na2,na2,1) + &
+         ns(m1,m1,1,na1,na1,1) * ns(m2,m2,2,na2,na2,1) + &
+         ns(m1,m1,2,na1,na1,1) * ns(m2,m2,1,na2,na2,1) - &
+         ns(m1,m2,1,na1,na2,1) * ns(m2,m1,1,na2,na1,1) - &
+         ns(m1,m2,2,na1,na2,1) * ns(m2,m1,2,na2,na1,1)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        HF(1)%V(ehub_l(m2,nt2),ehub_l(m1,nt1),na2,na1) = HF(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = 1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+        !
+        l1 = ehub_l(m1,nt1)
+        !
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        l2 = ehub_l(m2,nt2)
+        !
+        ehub_v_(na1,na2,m1,m2) = &
+               (E0(1)%V(l1,l2,na1,na2) / HF(1)%V(l1,l2,na1,na2)) / 2.0_DP
+        !
+        IF ( stop_acbn0 ) ehub_v_diff(na1,na2,m1,m2,1) = ABS( ehub_v (na1,na2,m1,m2,1) &
+                                                       -      ehub_v_(na1,na2,m1,m2  ) )
+        !
+        ehub_v(na1,na2,m1,m2,1)                                 &
+            = (1.0_DP - ehub_mixing)*ehub_v (na1,na2,m1,m2,1) + &
+              (         ehub_mixing)*ehub_v_(na1,na2,m1,m2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  ! ... out of the unit cell
+  !
+  DO i = 2, ehub_nnnc
+     E0(i)%V = 0.0_DP
+  ENDDO
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO ix = 1, 3
+           ntau(ix,na2) = n1 * at(ix,1) + n2 * at(ix,2) + n3 * at(ix,3) + tau(ix,na2)
+        ENDDO
+        !
+        l1 = 0
+        DO m1 = 1, ehub_lm(nt1)
+           CALL orberi(ehub_l(m1,nt1), l1)
+           CALL pao_3g(upf(nt1)%psd, ehub_l(m1,nt1), c1)
+           !
+        l2 = 0
+        DO m2 = 1, ehub_lm(nt2)
+           CALL orberi(ehub_l(m2,nt2), l2)
+           CALL pao_3g(upf(nt2)%psd, ehub_l(m2,nt2), c2)
+           !
+        l3 = 0
+        DO m3 = 1, ehub_lm(nt1)
+           IF ( ehub_l(m3,nt1) /= ehub_l(m1,nt1) ) CYCLE
+           CALL orberi(ehub_l(m3,nt1), l3)
+           CALL pao_3g(upf(nt1)%psd, ehub_l(m3,nt1), c3)
+           !
+        l4 = 0
+        DO m4 = 1, ehub_lm(nt2)
+           IF ( ehub_l(m4,nt2) /= ehub_l(m2,nt2) ) CYCLE
+           CALL orberi(ehub_l(m4,nt2), l4)
+           CALL pao_3g(upf(nt2)%psd, ehub_l(m4,nt2), c4)
+           !
+           E0(nnc)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  = &
+           E0(nnc)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  + &
+                    (dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                     dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  + &
+                     dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                     dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                     dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                     dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                     dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                     dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  - &
+                                  p(nnc)%O(m3,m2,1,na1,na2)  * &
+                                  p(nnc)%O(m1,m4,1,na1,na2)  - &
+                                  p(nnc)%O(m3,m2,2,na1,na2)  * &
+                                  p(nnc)%O(m1,m4,2,na1,na2)) * &
+                                   compute_eri(l3,l1,l4,l2,    &
+                          tau(:,na1)*alat, tau(:,na1)*alat,    &
+                         ntau(:,na2)*alat,ntau(:,na2)*alat,    &
+                                               c3,c1,c4,c2)
+           !
+        ENDDO ! m4
+        ENDDO ! m3
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  DEALLOCATE ( dm0%O )
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        DEALLOCATE ( dm1(nt,l)%O )
+     ENDDO
+  ENDDO
+  !
+  DO i = 2, ehub_nnnc
+     HF(i)%V = 0.0_DP
+  ENDDO
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           l1 = ehub_l(m1,nt1)
+           !
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           l2 = ehub_l(m2,nt2)
+           !
+           HF(nnc)%V(l1,l2,na1,na2) = HF(nnc)%V(l1,l2,na1,na2) + &
+               ns(m1,m1,1,na1,na1,  1)*ns(m2,m2,1,na2,na2,  1) + &
+               ns(m1,m1,2,na1,na1,  1)*ns(m2,m2,2,na2,na2,  1) + &
+               ns(m1,m1,1,na1,na1,  1)*ns(m2,m2,2,na2,na2,  1) + &
+               ns(m1,m1,2,na1,na1,  1)*ns(m2,m2,1,na2,na2,  1) - &
+               ns(m1,m2,1,na1,na2,nnc)*ns(m1,m2,1,na1,na2,nnc) - &
+               ns(m1,m2,2,na1,na2,nnc)*ns(m1,m2,2,na1,na2,nnc)
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           l1 = ehub_l(m1,nt1)
+           !
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           l2 = ehub_l(m2,nt2)
+           !
+           ehub_v_(na1,na2,m1,m2) = &
+                  (E0(nnc)%V(l1,l2,na1,na2) / HF(nnc)%V(l1,l2,na1,na2)) / 2.0_DP
+           !
+           IF ( stop_acbn0 ) ehub_v_diff(na1,na2,m1,m2,nnc) = ABS( ehub_v (na1,na2,m1,m2,nnc) &
+                                                            -      ehub_v_(na1,na2,m1,m2    ) )
+           !
+           ehub_v(na1,na2,m1,m2,nnc) =                               &
+                 (1.0_DP - ehub_mixing)*ehub_v (na1,na2,m1,m2,nnc) + &
+                 (         ehub_mixing)*ehub_v_(na1,na2,m1,m2    )
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  DEALLOCATE ( ehub_v_ )
+  !
+  DO i = 1, ehub_nnnc
+     DEALLOCATE ( E0(i)%V, E0(i)%J )
+     DEALLOCATE ( HF(i)%V, HF(i)%J )
+  ENDDO
+  !
+  ! Hermiticity of Hubbard parameters U & V
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        ehub_v(na1,na2,m1,m2,1) = 0.5D0 * (ehub_v(na1,na2,m1,m2,1) + &
+                                           ehub_v(na2,na1,m2,m1,1))
+        !
+        ehub_v(na2,na1,m2,m1,1) = ehub_v(na1,na2,m1,m2,1)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+  DO na2 = 1, nat
+     IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) &
+        ehub_v(na1,na2,:,:,1) = 0.0_DP
+  ENDDO ! na2
+  ENDDO ! na1
+
+1 CALL write_ehub_uv
+
+  CALL stop_clock('new_ns_e0_#1')
+
+  RETURN
+
+END SUBROUTINE new_ns_e0_1
+
+
+SUBROUTINE new_ns_e0_2(ns)
+
+  USE kinds,                ONLY : DP
+  USE constants,            ONLY : tpi, rytoev
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp, tau
+  USE cell_base,            ONLY : at, alat
+  USE klist,                ONLY : nks, ngk, xk
+  USE ldaV,                 ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                                   ehub_nn_vect, ehub_nn_leng,   &
+                                   ehub_nn_dim, ehub_csize,      &
+                                   ehub_nnnc, ehub_mixing,       &
+                                   ehub_v, remove_ehub_u,        &
+                                   wfcv, nwfcv, ofstv,           &
+                                   write_ehub_uv
+  USE lsda_mod,             ONLY : lsda, current_spin, nspin, isk
+  USE wvfct,                ONLY : nbnd, npwx, wg
+  USE io_global,            ONLY : stdout
+  USE control_flags,        ONLY : gamma_only
+  USE wavefunctions,        ONLY : evc
+  USE io_files,             ONLY : nwordwfc, iunwfc, nwordwfcv, iunhubv
+  USE buffers,              ONLY : get_buffer
+  USE mp_pools,             ONLY : inter_pool_comm
+  USE mp,                   ONLY : mp_sum
+  USE becmod,               ONLY : bec_type, calbec,  &
+                                   allocate_bec_type, &
+                                   deallocate_bec_type
+  USE uspp_param,           ONLY : upf
+
+  IMPLICIT NONE
+
+  REAL(DP), INTENT(OUT)    :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+
+  TYPE hubbard_ene_4
+     REAL(DP), ALLOCATABLE :: U(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: V(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: J(:,:,:,:)
+  END TYPE hubbard_ene_4
+
+  TYPE occmat_4
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:)
+  END TYPE occmat_4
+
+  TYPE occmat_5
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:,:)
+  END TYPE occmat_5
+
+  TYPE(bec_type)           :: proj
+
+  TYPE(hubbard_ene_4)      :: E0(ehub_nnnc)
+  TYPE(hubbard_ene_4)      :: HF(ehub_nnnc)
+
+  TYPE(occmat_5)           :: n(ehub_nnnc)
+  TYPE(occmat_5)           :: p(ehub_nnnc)
+  TYPE(occmat_5)           :: num(nbnd)
+
+  TYPE(occmat_4)           :: dm0
+  TYPE(occmat_4)           :: dm1(ntyp,4)
+
+  COMPLEX(DP)              :: kphase
+
+  REAL(DP), ALLOCATABLE    :: ehub_v_(:,:,:,:)
+
+  REAL(DP)                 :: arg
+  REAL(DP)                 :: ntau(3,nat)
+  REAL(DP)                 :: compute_eri
+  REAL(DP)                 :: c1(6), c2(6), c3(6), c4(6)
+
+  INTEGER                  :: npw, nw
+  INTEGER                  :: i, ik, ibnd, is, ix
+  INTEGER                  :: na, nt, m, l
+  INTEGER                  :: na1, na2
+  INTEGER                  :: nt1, nt2
+  INTEGER                  :: m1, m2, m3, m4
+  INTEGER                  :: l1, l2, l3, l4
+  INTEGER                  :: n1, n2, n3
+  INTEGER                  :: nnc, ics
+
+  CALL start_clock('new_ns_e0_#2')
+
+  CALL allocate_bec_type(nwfcv, nbnd, proj)
+  !
+  ALLOCATE ( dm0%O(ehub_lm_max,ehub_lm_max,nspin,nat) ) ; dm0%O = 0.0_DP
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        ALLOCATE ( dm1(nt,l)%O(ehub_lm_max,ehub_lm_max,nspin,nat) ) ; dm1(nt,l)%O = 0.0_DP
+     ENDDO
+  ENDDO
+  !
+  DO i = 1, ehub_nnnc
+     ALLOCATE ( n(i)%O(ehub_lm_max,ehub_lm_max,nspin,nat,nat) ) ; n(i)%O = 0.0_DP
+     ALLOCATE ( p(i)%O(ehub_lm_max,ehub_lm_max,nspin,nat,nat) ) ; p(i)%O = 0.0_DP
+     ALLOCATE ( E0(i)%V(ehub_lm_max,ehub_lm_max,nat,nat) )
+     ALLOCATE ( E0(i)%J(ehub_lm_max,ehub_lm_max,nat,nat) )
+     ALLOCATE ( HF(i)%V(ehub_lm_max,ehub_lm_max,nat,nat) )
+     ALLOCATE ( HF(i)%J(ehub_lm_max,ehub_lm_max,nat,nat) )
+  ENDDO
+
+  ics = ehub_csize + 1
+  !
+  DO ik = 1, nks
+     !
+     IF ( lsda ) current_spin = isk(ik)
+     npw = ngk(ik)
+     !
+     ! projection < wfcv | evc >
+     !
+     IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+     IF ( nks > 1 ) CALL get_buffer(wfcv, nwordwfcv, iunhubv, ik)
+     CALL calbec(npw, wfcv, evc, proj)
+     !
+     ! calculate the occupation matrices n
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2 ) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 n(1)%O(m1,m2,current_spin,na1,na2) = &
+                 n(1)%O(m1,m2,current_spin,na1,na2) + &
+                                        wg(ibnd,ik) * &
+                         proj%r(ofstv(na2)+m2,ibnd) * &
+                         proj%r(ofstv(na1)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 n(1)%O(m1,m2,current_spin,na1,na2) = &
+                 n(1)%O(m1,m2,current_spin,na1,na2) + &
+                                        wg(ibnd,ik) * &
+                    DBLE(proj%k(ofstv(na2)+m2,ibnd) * &
+                   CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           n(1)%O(m2,m1,current_spin,na2,na1) = n(1)%O(m1,m2,current_spin,na1,na2)
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     nnc = 2
+     !
+     DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+     DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+     DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+        !
+        IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+        !
+        arg = tpi * (                                              &
+         xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+         xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+         xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+        !
+        kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           IF ( ehub_lm(nt2) == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           DO m1 = 1, ehub_lm(nt1)
+           DO m2 = 1, ehub_lm(nt2)
+              !
+              IF ( gamma_only ) THEN
+                 DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                             wg(ibnd,ik) * &
+                              proj%r(ofstv(na2)+m2,ibnd) * &
+                              proj%r(ofstv(na1)+m1,ibnd)
+                 ENDDO ! ibnd
+              ELSE
+                 DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    n(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                             wg(ibnd,ik) * &
+                                           DBLE((kphase) * &
+                              proj%k(ofstv(na2)+m2,ibnd) * &
+                        CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                 ENDDO ! ibnd
+              ENDIF
+              !
+           ENDDO ! m2
+           ENDDO ! m1
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+        IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+     !
+     ! calculate the renormalized occupations N(ACBN0)
+     !
+     DO i = 1, nbnd
+        ALLOCATE ( num(i)%O(4,4,nspin,ntyp,ntyp) ) ; num(i)%O = 0.0_DP
+        ALLOCATE ( num(i)%T(4,4,nspin,ntyp,ntyp) ) ; num(i)%T = 0.0_DP
+     ENDDO
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m = 1, ehub_lm(nt)
+           !
+           l = ehub_l(m,nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 num(ibnd)%O(l,l,current_spin,nt,nt) = &
+                 num(ibnd)%O(l,l,current_spin,nt,nt) + &
+                            proj%r(ofstv(na)+m,ibnd) * &
+                            proj%r(ofstv(na)+m,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 num(ibnd)%O(l,l,current_spin,nt,nt) = &
+                 num(ibnd)%O(l,l,current_spin,nt,nt) + &
+                       DBLE(proj%k(ofstv(na)+m,ibnd) * &
+                      CONJG(proj%k(ofstv(na)+m,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m
+        !
+     ENDDO ! na
+     !
+     DO ibnd = 1, nbnd
+        !
+        DO nt1 = 1, ntyp
+        DO nt2 = 1, ntyp
+           !
+           IF ( upf(nt1)%psd /= upf(nt2)%psd ) CYCLE
+           !
+           num(ibnd)%T(:,:,current_spin,nt1,nt1) = &
+           num(ibnd)%T(:,:,current_spin,nt1,nt1) + &
+           num(ibnd)%O(:,:,current_spin,nt2,nt2)
+           !
+        ENDDO ! nt2
+        ENDDO ! nt1
+        !
+     ENDDO ! ibnd
+     !
+     DO ibnd = 1, nbnd
+        !
+        DO nt1 = 1, ntyp
+        DO nt2 = 1, ntyp
+           !
+           DO l1 = 1, 4
+           DO l2 = 1, 4
+              !
+              num(ibnd)%T(l1,l2,current_spin,nt1,nt2) = &
+              num(ibnd)%T(l1,l1,current_spin,nt1,nt1) + &
+              num(ibnd)%T(l2,l2,current_spin,nt2,nt2)
+              !
+              IF ( upf(nt1)%psd == upf(nt2)%psd )       &
+              num(ibnd)%T(l1,l2,current_spin,nt1,nt2) = &
+              num(ibnd)%T(l1,l2,current_spin,nt1,nt2) / 2.0_DP
+              !
+           ENDDO ! l2
+           ENDDO ! l1
+           !
+        ENDDO ! nt2
+        ENDDO ! nt1
+        !
+     ENDDO ! ibnd
+     !
+     DO ibnd = 1, nbnd
+        !
+        num(ibnd)%O = num(ibnd)%T
+        !
+        DEALLOCATE ( num(ibnd)%T )
+        !
+     ENDDO
+     !
+     ! calculate the renormalized occupation matrices P(ACBN0)
+     !
+     ! 1) P^II (dm0, dm1)
+     !
+     DO na = 1, nat
+        nt = ityp(na)
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt)
+           !
+           l1 = ehub_l(m1,nt)
+           !
+        DO m2 = 1, ehub_lm(nt)
+           !
+           l2 = ehub_l(m2,nt)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                 dm0%O(m1,m2,current_spin,na) = &
+                 dm0%O(m1,m2,current_spin,na) + &
+                           num(ibnd)%O(l1,l2,   &
+                          current_spin,nt,nt) * &
+                                  wg(ibnd,ik) * &
+                    proj%r(ofstv(na)+m2,ibnd) * &
+                    proj%r(ofstv(na)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                 dm0%O(m1,m2,current_spin,na) = &
+                 dm0%O(m1,m2,current_spin,na) + &
+                           num(ibnd)%O(l1,l2,   &
+                          current_spin,nt,nt) * &
+                                  wg(ibnd,ik) * &
+               DBLE(proj%k(ofstv(na)+m2,ibnd) * &
+              CONJG(proj%k(ofstv(na)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na
+
+     DO nt = 1, ntyp
+        !
+        IF ( ehub_lm(nt) == 0 ) CYCLE
+        !
+        DO l = 1, 4
+           !
+           DO na1 = 1, nat
+              nt1 = ityp(na1)
+              !
+              IF ( ehub_lm(nt1) == 0 ) CYCLE
+              !
+              DO m1 = 1, ehub_lm(nt1)
+              DO m2 = 1, ehub_lm(nt1)
+                 !
+                 IF ( gamma_only ) THEN
+                    DO ibnd = 1, nbnd
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) = &
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) + &
+                             num(ibnd)%O(ehub_l(m1,nt1),l,   &
+                                      current_spin,nt1,nt) * &
+                                               wg(ibnd,ik) * &
+                                proj%r(ofstv(na1)+m2,ibnd) * &
+                                proj%r(ofstv(na1)+m1,ibnd)
+                    ENDDO ! ibnd
+                 ELSE
+                    DO ibnd = 1, nbnd
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) = &
+                       dm1(nt,l)%O(m1,m2,current_spin,na1) + &
+                             num(ibnd)%O(ehub_l(m1,nt1),l,   &
+                                      current_spin,nt1,nt) * &
+                                               wg(ibnd,ik) * &
+                           DBLE(proj%k(ofstv(na1)+m2,ibnd) * &
+                          CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                    ENDDO ! ibnd
+                 ENDIF
+                 !
+              ENDDO ! m2
+              ENDDO ! m1
+              !
+           ENDDO ! na1
+           !
+        ENDDO ! l
+        !
+     ENDDO ! nt
+     !
+     ! 2) P^IJ
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           l1 = ehub_l(m1,nt1)
+           !
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           l2 = ehub_l(m2,nt2)
+           !
+           IF ( gamma_only ) THEN
+              DO ibnd = 1, nbnd
+                   p(1)%O(m1,m2,current_spin,na1,na2) = &
+                   p(1)%O(m1,m2,current_spin,na1,na2) + &
+                                   num(ibnd)%O(l1,l2,   &
+                                current_spin,nt1,nt2) * &
+                                          wg(ibnd,ik) * &
+                           proj%r(ofstv(na2)+m2,ibnd) * &
+                           proj%r(ofstv(na1)+m1,ibnd)
+              ENDDO ! ibnd
+           ELSE
+              DO ibnd = 1, nbnd
+                   p(1)%O(m1,m2,current_spin,na1,na2) = &
+                   p(1)%O(m1,m2,current_spin,na1,na2) + &
+                                   num(ibnd)%O(l1,l2,   &
+                                current_spin,nt1,nt2) * &
+                                          wg(ibnd,ik) * &
+                      DBLE(proj%k(ofstv(na2)+m2,ibnd) * &
+                     CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+              ENDDO ! ibnd
+           ENDIF
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = na1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           p(1)%O(m2,m1,current_spin,na2,na1) = p(1)%O(m1,m2,current_spin,na1,na2)
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     nnc = 2
+     !
+     DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+     DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+     DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+        !
+        IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+        !
+        arg = tpi * (                                              &
+         xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+         xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+         xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+        !
+        kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           IF ( ehub_lm(nt2) == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           DO m1 = 1, ehub_lm(nt1)
+              !
+              l1 = ehub_l(m1,nt1)
+              !
+           DO m2 = 1, ehub_lm(nt2)
+              !
+              l2 = ehub_l(m2,nt2)
+              !
+              IF ( gamma_only ) THEN
+                 DO ibnd = 1, nbnd
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                      num(ibnd)%O(l1,l2,   &
+                                   current_spin,nt1,nt2) * &
+                                             wg(ibnd,ik) * &
+                              proj%r(ofstv(na2)+m2,ibnd) * &
+                              proj%r(ofstv(na1)+m1,ibnd)
+                 ENDDO ! ibnd
+              ELSE
+                 DO ibnd = 1, nbnd
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) = &
+                    p(nnc)%O(m1,m2,current_spin,na1,na2) + &
+                                      num(ibnd)%O(l1,l2,   &
+                                   current_spin,nt1,nt2) * &
+                                             wg(ibnd,ik) * &
+                                           DBLE((kphase) * &
+                              proj%k(ofstv(na2)+m2,ibnd) * &
+                        CONJG(proj%k(ofstv(na1)+m1,ibnd)))
+                 ENDDO ! ibnd
+              ENDIF
+              !
+           ENDDO ! m2
+           ENDDO ! m1
+           !
+        ENDDO ! na2
+        ENDDO ! na1
+        !
+        IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+        !
+     ENDDO ! n3
+     ENDDO ! n2
+     ENDDO ! n1
+     !
+     DO i = 1, nbnd
+        DEALLOCATE ( num(i)%O )
+     ENDDO
+
+  ENDDO ! ik
+
+  CALL deallocate_bec_type(proj)
+
+  CALL mp_sum(dm0%O, inter_pool_comm)
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        CALL mp_sum(dm1(nt,l)%O, inter_pool_comm)
+     ENDDO
+  ENDDO
+  !
+  DO i = 1, ehub_nnnc
+     CALL mp_sum(n(i)%O, inter_pool_comm)
+     CALL mp_sum(p(i)%O, inter_pool_comm)
+  ENDDO
+
+  DO i = 1, ehub_nnnc
+     IF ( nspin == 1 ) n(i)%O = 0.5_DP * n(i)%O
+  ENDDO
+  !
+  CALL symmetrize_n5(n)
+  !
+  ns = 0.0_DP
+  !
+  DO i = 1, ehub_nnnc
+     ns(:,:,:,:,:,i) = n(i)%O(:,:,:,:,:)
+     DEALLOCATE ( n(i)%O )
+  ENDDO
+  !
+  IF ( nspin == 1 ) dm0%O = 0.5_DP * dm0%O
+  !
+  CALL symmetrize_n4(dm0)
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        IF ( nspin == 1 ) dm1(nt,l)%O = 0.5_DP * dm1(nt,l)%O
+     ENDDO
+  ENDDO
+  !
+  CALL symmetrize_n4m(dm1)
+  !
+  DO i = 1, ehub_nnnc
+     IF ( nspin == 1 ) p(i)%O = 0.5_DP * p(i)%O
+  ENDDO
+  !
+  CALL symmetrize_n5(p)
+
+  !
+  ! on-site interaction: U_ij^II
+  !
+  E0(1)%V = 0.0_DP ; E0(1)%J = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     l1 = 0
+     DO m1 = 1, ehub_lm(nt)
+        CALL orberi(ehub_l(m1,nt), l1)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m1,nt), c1)
+        !
+     l2 = 0
+     DO m2 = 1, ehub_lm(nt)
+        CALL orberi(ehub_l(m2,nt), l2)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m2,nt), c2)
+        !
+     l3 = 0
+     DO m3 = 1, ehub_lm(nt)
+        IF ( ehub_l(m3,nt) /= ehub_l(m1,nt) ) CYCLE
+        CALL orberi(ehub_l(m3,nt), l3)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m3,nt), c3)
+        !
+     l4 = 0
+     DO m4 = 1, ehub_lm(nt)
+        IF ( ehub_l(m4,nt) /= ehub_l(m2,nt) ) CYCLE
+        CALL orberi(ehub_l(m4,nt), l4)
+        CALL pao_3g(upf(nt)%psd, ehub_l(m4,nt), c4)
+        !
+        IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+                 (dm0%O(m3,m1,1,na)*dm0%O(m4,m2,2,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,1,na)) * &
+                             compute_eri(l3,l1,l4,l2,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                                         c3,c1,c4,c2)
+        ELSE
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+           E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+                 (dm0%O(m3,m1,1,na)*dm0%O(m4,m2,1,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,2,na)  + &
+                  dm0%O(m3,m1,1,na)*dm0%O(m4,m2,2,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,1,na)) * &
+                             compute_eri(l3,l1,l4,l2,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                                         c3,c1,c4,c2)
+
+           E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+           E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+                 (dm0%O(m3,m1,1,na)*dm0%O(m4,m2,1,na)  + &
+                  dm0%O(m3,m1,2,na)*dm0%O(m4,m2,2,na)) * &
+                             compute_eri(l3,l2,l4,l1,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                       tau(:,na)*alat,tau(:,na)*alat,    &
+                                         c3,c2,c4,c1)
+        ENDIF
+        !
+     ENDDO ! m4
+     ENDDO ! m3
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  HF(1)%V = 0.0_DP ; HF(1)%J = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt)
+     DO m2 = 1, ehub_lm(nt)
+        !
+        IF ( m1 == m2 ) THEN
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,2,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,1,na,na,1)
+        ELSE
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+            HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,1,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,2,na,na,1) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,2,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,1,na,na,1)
+
+            HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+            HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+             ns(m1,m1,1,na,na,1) * ns(m2,m2,1,na,na,1) + &
+             ns(m1,m1,2,na,na,1) * ns(m2,m2,2,na,na,1)
+        ENDIF
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+  !
+  ALLOCATE ( ehub_v_(nat,nat,ehub_lm_max,ehub_lm_max) ) ; ehub_v_ = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt)
+     DO m2 = 1, ehub_lm(nt)
+        !
+        IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+           ehub_v_(na,na,m1,m2) =                           &
+               E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) / &
+               HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) * &
+                          remove_ehub_u(nt,ehub_l(m1,nt)) * &
+                          remove_ehub_u(nt,ehub_l(m2,nt))
+        ELSE
+           ehub_v_(na,na,m1,m2) =                            &
+              (E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  / &
+               HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  - &
+               E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  / &
+               HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)) * &
+                          remove_ehub_u(nt,ehub_l(m1,nt))  * &
+                          remove_ehub_u(nt,ehub_l(m2,nt))
+        ENDIF
+        !
+        ehub_v(na,na,m1,m2,1)                                 &
+            = (1.0_DP - ehub_mixing)*ehub_v (na,na,m1,m2,1) + &
+              (         ehub_mixing)*ehub_v_(na,na,m1,m2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na
+
+  !
+  ! inter-site interaction: U_ij^IJ (I /= J)
+  !
+  ! ... in the unit cell
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     l1 = 0
+     DO m1 = 1, ehub_lm(nt1)
+        CALL orberi(ehub_l(m1,nt1), l1)
+        CALL pao_3g(upf(nt1)%psd, ehub_l(m1,nt1), c1)
+        !
+     l2 = 0
+     DO m2 = 1, ehub_lm(nt2)
+        CALL orberi(ehub_l(m2,nt2), l2)
+        CALL pao_3g(upf(nt2)%psd, ehub_l(m2,nt2), c2)
+        !
+     l3 = 0
+     DO m3 = 1, ehub_lm(nt1)
+        IF ( ehub_l(m3,nt1) /= ehub_l(m1,nt1) ) CYCLE
+        CALL orberi(ehub_l(m3,nt1), l3)
+        CALL pao_3g(upf(nt1)%psd, ehub_l(m3,nt1), c3)
+        !
+     l4 = 0
+     DO m4 = 1, ehub_lm(nt2)
+        IF ( ehub_l(m4,nt2) /= ehub_l(m2,nt2) ) CYCLE
+        CALL orberi(ehub_l(m4,nt2), l4)
+        CALL pao_3g(upf(nt2)%psd, ehub_l(m4,nt2), c4)
+        !
+        E0(1)%V(m1,m2,na1,na2) = E0(1)%V(m1,m2,na1,na2)  + &
+                (dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                 dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  + &
+                 dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                 dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                 dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                 dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                 dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                 dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  - &
+                                p(1)%O(m3,m2,1,na1,na2)  * &
+                                p(1)%O(m4,m1,1,na2,na1)  - &
+                                p(1)%O(m3,m2,2,na1,na2)  * &
+                                p(1)%O(m4,m1,2,na2,na1)) * &
+                               compute_eri(l3,l1,l4,l2,    &
+                       tau(:,na1)*alat,tau(:,na1)*alat,    &
+                       tau(:,na2)*alat,tau(:,na2)*alat,    &
+                                           c3,c1,c4,c2)
+        !
+     ENDDO ! m4
+     ENDDO ! m3
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        E0(1)%V(m2,m1,na2,na1) = E0(1)%V(m1,m2,na1,na2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  HF(1)%V = 0.0_DP
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        HF(1)%V(m1,m2,na1,na2) = HF(1)%V(m1,m2,na1,na2) + &
+         ns(m1,m1,1,na1,na1,1) * ns(m2,m2,1,na2,na2,1)  + &
+         ns(m1,m1,2,na1,na1,1) * ns(m2,m2,2,na2,na2,1)  + &
+         ns(m1,m1,1,na1,na1,1) * ns(m2,m2,2,na2,na2,1)  + &
+         ns(m1,m1,2,na1,na1,1) * ns(m2,m2,1,na2,na2,1)  - &
+         ns(m1,m2,1,na1,na2,1) * ns(m2,m1,1,na2,na1,1)  - &
+         ns(m1,m2,2,na1,na2,1) * ns(m2,m1,2,na2,na1,1)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        HF(1)%V(m2,m1,na2,na1) = HF(1)%V(m1,m2,na1,na2)
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = 1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+        !
+        l1 = ehub_l(m1,nt1)
+        !
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        l2 = ehub_l(m2,nt2)
+        !
+        ehub_v_(na1,na2,m1,m2) = &
+               (E0(1)%V(m1,m2,na1,na2) / HF(1)%V(m1,m2,na1,na2)) / 2.0_DP
+        !
+        ehub_v(na1,na2,m1,m2,1)                                 &
+            = (1.0_DP - ehub_mixing)*ehub_v (na1,na2,m1,m2,1) + &
+              (         ehub_mixing)*ehub_v_(na1,na2,m1,m2)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  ! ... out of the unit cell
+  !
+  DO i = 2, ehub_nnnc
+     E0(i)%V = 0.0_DP
+  ENDDO
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO ix = 1, 3
+           ntau(ix,na2) = n1 * at(ix,1) + n2 * at(ix,2) + n3 * at(ix,3) + tau(ix,na2)
+        ENDDO
+        !
+        l1 = 0
+        DO m1 = 1, ehub_lm(nt1)
+           CALL orberi(ehub_l(m1,nt1), l1)
+           CALL pao_3g(upf(nt1)%psd, ehub_l(m1,nt1), c1)
+           !
+        l2 = 0
+        DO m2 = 1, ehub_lm(nt2)
+           CALL orberi(ehub_l(m2,nt2), l2)
+           CALL pao_3g(upf(nt2)%psd, ehub_l(m2,nt2), c2)
+           !
+        l3 = 0
+        DO m3 = 1, ehub_lm(nt1)
+           IF ( ehub_l(m3,nt1) /= ehub_l(m1,nt1) ) CYCLE
+           CALL orberi(ehub_l(m3,nt1), l3)
+           CALL pao_3g(upf(nt1)%psd, ehub_l(m3,nt1), c3)
+           !
+        l4 = 0
+        DO m4 = 1, ehub_lm(nt2)
+           IF ( ehub_l(m4,nt2) /= ehub_l(m2,nt2) ) CYCLE
+           CALL orberi(ehub_l(m4,nt2), l4)
+           CALL pao_3g(upf(nt2)%psd, ehub_l(m4,nt2), c4)
+           !
+           E0(nnc)%V(m1,m2,na1,na2) = E0(nnc)%V(m1,m2,na1,na2)  + &
+                       (dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                        dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  + &
+                        dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                        dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                        dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,na1)  * &
+                        dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,na2)  + &
+                        dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,na1)  * &
+                        dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,na2)  - &
+                                     p(nnc)%O(m3,m2,1,na1,na2)  * &
+                                     p(nnc)%O(m1,m4,1,na1,na2)  - &
+                                     p(nnc)%O(m3,m2,2,na1,na2)  * &
+                                     p(nnc)%O(m1,m4,2,na1,na2)) * &
+                                      compute_eri(l3,l1,l4,l2,    &
+                             tau(:,na1)*alat, tau(:,na1)*alat,    &
+                            ntau(:,na2)*alat,ntau(:,na2)*alat,    &
+                                                  c3,c1,c4,c2)
+           !
+        ENDDO ! m4
+        ENDDO ! m3
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  DEALLOCATE ( dm0%O )
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        DEALLOCATE ( dm1(nt,l)%O )
+     ENDDO
+  ENDDO
+  !
+  DO i = 2, ehub_nnnc
+     HF(i)%V = 0.0_DP
+  ENDDO
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           l1 = ehub_l(m1,nt1)
+           !
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           l2 = ehub_l(m2,nt2)
+           !
+           HF(nnc)%V(m1,m2,na1,na2) = HF(nnc)%V(m1,m2,na1,na2) + &
+               ns(m1,m1,1,na1,na1,  1)*ns(m2,m2,1,na2,na2,  1) + &
+               ns(m1,m1,2,na1,na1,  1)*ns(m2,m2,2,na2,na2,  1) + &
+               ns(m1,m1,1,na1,na1,  1)*ns(m2,m2,2,na2,na2,  1) + &
+               ns(m1,m1,2,na1,na1,  1)*ns(m2,m2,1,na2,na2,  1) - &
+               ns(m1,m2,1,na1,na2,nnc)*ns(m1,m2,1,na1,na2,nnc) - &
+               ns(m1,m2,2,na1,na2,nnc)*ns(m1,m2,2,na1,na2,nnc)
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           l1 = ehub_l(m1,nt1)
+           !
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           l2 = ehub_l(m2,nt2)
+           !
+           ehub_v_(na1,na2,m1,m2) = &
+                  (E0(nnc)%V(m1,m2,na1,na2) / HF(nnc)%V(m1,m2,na1,na2)) / 2.0_DP
+           !
+           ehub_v(na1,na2,m1,m2,nnc) =                               &
+                 (1.0_DP - ehub_mixing)*ehub_v (na1,na2,m1,m2,nnc) + &
+                 (         ehub_mixing)*ehub_v_(na1,na2,m1,m2    )
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  DEALLOCATE ( ehub_v_ )
+  !
+  DO i = 1, ehub_nnnc
+     DEALLOCATE ( E0(i)%V, E0(i)%J )
+     DEALLOCATE ( HF(i)%V, HF(i)%J )
+  ENDDO
+  !
+  ! Hermiticity of Hubbard parameters U & V
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        ehub_v(na1,na2,m1,m2,1) = 0.5D0 * (ehub_v(na1,na2,m1,m2,1) + &
+                                           ehub_v(na2,na1,m2,m1,1))
+        !
+        ehub_v(na2,na1,m2,m1,1) = ehub_v(na1,na2,m1,m2,1)
+        !
+     ENDDO ! m2
+     ENDDO ! m1
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+  DO na2 = 1, nat
+     IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) &
+        ehub_v(na1,na2,:,:,1) = 0.0_DP
+  ENDDO ! na2
+  ENDDO ! na1
+
+  CALL write_ehub_uv
+
+  CALL stop_clock('new_ns_e0_#2')
+
+  RETURN
+
+END SUBROUTINE new_ns_e0_2
+
+
+SUBROUTINE symmetrize_n4( n )
+
+  USE kinds,                ONLY : DP
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+  USE ldaV,                 ONLY : ehub_lm, ehub_l, ehub_lm_max, &
+                                   ehub_nn_vect, ehub_nn_dim,    &
+                                   ehub_csize, ehub_nnnc
+  USE lsda_mod,             ONLY : nspin
+  USE symm_base,            ONLY : d1, d2, d3, nsym, irt
+
+  IMPLICIT NONE
+
+  TYPE occmat_4
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:)
+  END TYPE occmat_4
+
+  TYPE(occmat_4), INTENT(INOUT) :: n
+
+  INTEGER                       :: is, isym, l, m, nt
+  INTEGER                       :: na1, na2
+  INTEGER                       :: nt1, nt2
+  INTEGER                       :: m1, m2, m3, m4
+  INTEGER                       :: m1_, m2_, m3_, m4_
+  INTEGER                       :: temp, l_separation(5,ntyp)
+
+  ALLOCATE (n%T(ehub_lm_max,ehub_lm_max,nspin,nat)) ; n%T = 0.0_DP
+
+  DO nt = 1, ntyp
+     !
+     temp = ehub_l(1,nt)
+     l_separation(ehub_l(1,nt),nt) = 1
+     !
+     DO m = 2, ehub_lm(nt)
+        !
+        IF ( ehub_l(m,nt) /= temp ) THEN
+           temp = ehub_l(m,nt)
+           l_separation(ehub_l(m,nt),nt) = m
+        ENDIF
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  DO is = 1, nspin
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+           !
+        DO m2 = 1, ehub_lm(nt1)
+           m2_ = m2 - l_separation(ehub_l(m2,nt1),nt1) + 1
+           !
+           DO isym = 1, nsym
+              !
+              na2 = irt(isym, na1)
+              !
+              DO m3 = 1, ehub_lm(nt1)
+                 IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                 m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                 !
+              DO m4 = 1, ehub_lm(nt1)
+                 IF ( ehub_l(m2,nt1) /= ehub_l(m4,nt1) ) CYCLE
+                 m4_ = m4 - l_separation(ehub_l(m4,nt1),nt1) + 1
+                 !
+                 IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                        n%O(m3,m4,is,na2) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                        n%O(m3,m4,is,na2) * &
+                                         d1(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                        n%O(m3,m4,is,na2) * &
+                                         d2(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                        n%O(m3,m4,is,na2) * &
+                                         d3(m4_,m2_,isym) / &
+                                                   (nsym)
+  
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d1(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d1(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d1(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d1(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d2(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d1(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d3(m4_,m2_,isym) / &
+                                                   (nsym)
+
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d2(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d2(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d1(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d2(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d2(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d2(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d3(m4_,m2_,isym) / &
+                                                   (nsym)
+
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d3(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d3(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d1(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d3(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d2(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n%T(m1,m2,is,na1) = n%T(m1,m2,is,na1) + &
+                                         d3(m3_,m1_,isym) * &
+                                        n%O(m3,m4,is,na2) * &
+                                         d3(m4_,m2_,isym) / &
+                                                   (nsym)
+                 ELSE
+                    CALL errore('new_ns_v','angular momentum not implemented',1)
+                 ENDIF
+                 !
+              ENDDO ! m4
+              ENDDO ! m3
+              !
+           ENDDO ! isym
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        ! 
+     ENDDO ! na1
+     !
+  ENDDO ! is
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+     DO is = 1, nspin
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = m1, ehub_lm(nt1)
+           !
+           n%T(m1,m2,is,na1) = 0.5D0 * (n%T(m1,m2,is,na1) + &
+                                        n%T(m2,m1,is,na1))
+           !
+           n%T(m2,m1,is,na1) = n%T(m1,m2,is,na1)
+           !
+        ENDDO
+        ENDDO
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  n%O = n%T
+  DEALLOCATE (n%T)
+
+END SUBROUTINE symmetrize_n4
+
+
+SUBROUTINE symmetrize_n4m( n )
+
+  USE kinds,                ONLY : DP
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+  USE ldaV,                 ONLY : ehub_lm, ehub_l, ehub_lm_max, &
+                                   ehub_nn_vect, ehub_nn_dim,    &
+                                   ehub_csize, ehub_nnnc
+  USE lsda_mod,             ONLY : nspin
+  USE symm_base,            ONLY : d1, d2, d3, nsym, irt
+
+  IMPLICIT NONE
+
+  TYPE occmat_4
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:)
+  END TYPE occmat_4
+
+  TYPE(occmat_4), INTENT(INOUT) :: n(ntyp,4)
+
+  INTEGER                       :: is, isym, i, l, m, nt
+  INTEGER                       :: na1, na2
+  INTEGER                       :: nt1, nt2
+  INTEGER                       :: m1, m2, m3, m4
+  INTEGER                       :: m1_, m2_, m3_, m4_
+  INTEGER                       :: temp, l_separation(5,ntyp)
+
+  DO i = 1, ntyp
+     DO l = 1, 4
+        ALLOCATE (n(i,l)%T(ehub_lm_max,ehub_lm_max,nspin,nat)) ; n(i,l)%T = 0.0_DP
+     ENDDO
+  ENDDO
+  !
+  DO nt = 1, ntyp
+     !
+     temp = ehub_l(1,nt)
+     l_separation(ehub_l(1,nt),nt) = 1
+     !
+     DO m = 2, ehub_lm(nt)
+        !
+        IF ( ehub_l(m,nt) /= temp ) THEN
+           temp = ehub_l(m,nt)
+           l_separation(ehub_l(m,nt),nt) = m
+        ENDIF
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  DO nt = 1, ntyp
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO l = 1, 4
+        !
+        DO is = 1, nspin
+           !
+           DO na1 = 1, nat
+              nt1 = ityp(na1)
+              !
+              IF ( ehub_lm(nt1) == 0 ) CYCLE
+              !
+              DO m1 = 1, ehub_lm(nt1)
+                 m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+                 !
+              DO m2 = 1, ehub_lm(nt1)
+                 m2_ = m2 - l_separation(ehub_l(m2,nt1),nt1) + 1
+                 !
+                 DO isym = 1, nsym
+                    !
+                    na2 = irt(isym, na1)
+                    !
+                    DO m3 = 1, ehub_lm(nt1)
+                       IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                       m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                       !
+                    DO m4 = 1, ehub_lm(nt1)
+                       IF ( ehub_l(m2,nt1) /= ehub_l(m4,nt1) ) CYCLE
+                       m4_ = m4 - l_separation(ehub_l(m4,nt1),nt1) + 1
+                       !
+                       IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                    n(nt,l)%O(m3,m4,is,na2) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d1(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d2(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d3(m4_,m2_,isym) / &
+                                                                     (nsym)
+      
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d1(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d1(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d1(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d1(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d2(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d1(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d3(m4_,m2_,isym) / &
+                                                                     (nsym)
+
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d2(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d2(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d1(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d2(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d2(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d2(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d3(m4_,m2_,isym) / &
+                                                                     (nsym)
+
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d3(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d3(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d1(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d3(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d2(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                          n(nt,l)%T(m1,m2,is,na1) = n(nt,l)%T(m1,m2,is,na1) + &
+                                                           d3(m3_,m1_,isym) * &
+                                                    n(nt,l)%O(m3,m4,is,na2) * &
+                                                           d3(m4_,m2_,isym) / &
+                                                                     (nsym)
+                       ELSE
+                          CALL errore('new_ns_v','angular momentum not implemented',1)
+                       ENDIF
+                       !
+                    ENDDO ! m4
+                    ENDDO ! m3
+                    !
+                 ENDDO ! isym
+                 !
+              ENDDO ! m2
+              ENDDO ! m1
+              ! 
+           ENDDO ! na1
+           !
+        ENDDO ! is
+        !
+     ENDDO ! l
+     !
+  ENDDO ! nt
+  !
+  DO nt = 1, ntyp
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO l = 1, 4
+        !
+        DO na1 = 1, nat
+           nt1 = ityp(na1)
+           !
+           IF ( ehub_lm(nt1) == 0 ) CYCLE
+           !
+           DO is = 1, nspin
+              !
+              DO m1 = 1, ehub_lm(nt1)
+              DO m2 = m1, ehub_lm(nt1)
+                 !
+                 n(nt,l)%T(m1,m2,is,na1) = 0.5D0 * (n(nt,l)%T(m1,m2,is,na1) + &
+                                                    n(nt,l)%T(m2,m1,is,na1))
+                 !
+                 n(nt,l)%T(m2,m1,is,na1) = n(nt,l)%T(m1,m2,is,na1)
+                 !
+              ENDDO
+              ENDDO
+              !
+           ENDDO
+           !
+        ENDDO
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  DO nt = 1, ntyp
+     DO l = 1, 4
+        n(nt,l)%O = n(nt,l)%T
+        DEALLOCATE (n(nt,l)%T)
+     ENDDO
+  ENDDO
+
+END SUBROUTINE symmetrize_n4m
+
+
+SUBROUTINE symmetrize_n5( n )
+
+  USE kinds,                ONLY : DP
+  USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+  USE ldaV,                 ONLY : ehub_lm, ehub_l, ehub_lm_max, &
+                                   ehub_nn_vect, ehub_nn_dim,    &
+                                   ehub_csize, ehub_nnnc
+  USE lsda_mod,             ONLY : nspin
+  USE symm_base,            ONLY : d1, d2, d3, nsym, irt
+
+  IMPLICIT NONE
+
+  TYPE occmat_5
+     REAL(DP), ALLOCATABLE :: O(:,:,:,:,:)
+     REAL(DP), ALLOCATABLE :: T(:,:,:,:,:)
+  END TYPE occmat_5
+
+  TYPE(occmat_5), INTENT(INOUT) :: n(ehub_nnnc)
+
+  INTEGER                       :: is, isym, i, m, nt
+  INTEGER                       :: na1, na2, na3, na4
+  INTEGER                       :: nt1, nt2, nt3, nt4
+  INTEGER                       :: m1, m2, m3, m4
+  INTEGER                       :: m1_, m2_, m3_, m4_
+  INTEGER                       :: n0(3), n1, n2, n3
+  INTEGER                       :: nnc0, nnc, ics
+  INTEGER                       :: temp, l_separation(5,ntyp)
+
+  DO i = 1, ehub_nnnc
+     ALLOCATE (n(i)%T(ehub_lm_max,ehub_lm_max,nspin,nat,nat)) ; n(i)%T = 0.0_DP
+  ENDDO
+  !
+  DO nt = 1, ntyp
+     !
+     temp = ehub_l(1,nt)
+     l_separation(ehub_l(1,nt),nt) = 1
+     !
+     DO m = 2, ehub_lm(nt)
+        !
+        IF ( ehub_l(m,nt) /= temp ) THEN
+           temp = ehub_l(m,nt)
+           l_separation(ehub_l(m,nt),nt) = m
+        ENDIF
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  ics = ehub_csize + 1
+  !
+  DO is = 1, nspin
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+           !
+        DO m2 = 1, ehub_lm(nt1)
+           m2_ = m2 - l_separation(ehub_l(m2,nt1),nt1) + 1
+           !
+           DO isym = 1, nsym
+              !
+              na2 = irt(isym, na1)
+              !
+              DO m3 = 1, ehub_lm(nt1)
+                 IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                 m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                 !
+              DO m4 = 1, ehub_lm(nt1)
+                 IF ( ehub_l(m2,nt1) /= ehub_l(m4,nt1) ) CYCLE
+                 m4_ = m4 - l_separation(ehub_l(m4,nt1),nt1) + 1
+                 !
+                 IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                               n(1)%O(m3,m4,is,na2,na2) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d1(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d2(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d3(m4_,m2_,isym) / &
+                                                                 (nsym)
+
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d1(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d1(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d1(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d1(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d2(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d1(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d3(m4_,m2_,isym) / &
+                                                                 (nsym)
+
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d2(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d2(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d1(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d2(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d2(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d2(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d3(m4_,m2_,isym) / &
+                                                                 (nsym)
+
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d3(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d3(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d1(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d3(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d2(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                    n(1)%T(m1,m2,is,na1,na1) = n(1)%T(m1,m2,is,na1,na1) + &
+                                                       d3(m3_,m1_,isym) * &
+                                               n(1)%O(m3,m4,is,na2,na2) * &
+                                                       d3(m4_,m2_,isym) / &
+                                                                 (nsym)
+                 ELSE
+                    CALL errore('new_ns_v','angular momentum not implemented',1)
+                 ENDIF
+                 !
+              ENDDO ! m4
+              ENDDO ! m3
+              !
+           ENDDO ! isym
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        ! 
+     ENDDO ! na1
+     !
+  ENDDO ! is
+
+  DO is = 1, nspin
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+        DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+        DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+        DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+           !
+           n0(1) = n1 ; n0(2) = n2 ; n0(3) = n3
+           !
+           CALL hubbard_get_nnc(n0,nnc0)
+           !
+           DO na2 = 1, nat
+              nt2 = ityp(na2)
+              !
+              IF ( ehub_lm(nt2) == 0 ) CYCLE
+              !
+              IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+              !
+              DO m1 = 1, ehub_lm(nt1)
+                 m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+                 !
+              DO m2 = 1, ehub_lm(nt2)
+                 m2_ = m2 - l_separation(ehub_l(m2,nt2),nt2) + 1
+                 !
+                 DO isym = 1, nsym
+                    !
+                    CALL hubbard_symmetry(na1,na2,na3,na4,n0,nnc,isym)
+                    !
+                    DO m3 = 1, ehub_lm(nt1)
+                       IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                       m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                       !
+                    DO m4 = 1, ehub_lm(nt2)
+                       IF ( ehub_l(m2,nt2) /= ehub_l(m4,nt2) ) CYCLE
+                       m4_ = m4 - l_separation(ehub_l(m4,nt2),nt2) + 1
+                       !
+                       IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d1(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d2(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d3(m4_,m2_,isym) / &
+                                                                             (nsym)
+
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d1(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d1(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d1(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d1(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d2(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d1(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d3(m4_,m2_,isym) / &
+                                                                             (nsym)
+
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d2(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d2(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d1(m4_,m2_,isym) / &
+                                                                            (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d2(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d2(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d2(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d3(m4_,m2_,isym) / &
+                                                                             (nsym)
+
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d3(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d3(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d1(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d3(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d2(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                          n(nnc0)%T(m1,m2,is,na1,na2) = n(nnc0)%T(m1,m2,is,na1,na2) + &
+                                                                   d3(m3_,m1_,isym) * &
+                                                        n(nnc )%O(m3,m4,is,na3,na4) * &
+                                                                   d3(m4_,m2_,isym) / &
+                                                                             (nsym)
+                       ELSE
+                          CALL errore('new_ns_v','angular momentum not implemented',1)
+                       ENDIF
+                       !
+                    ENDDO ! m4
+                    ENDDO ! m3
+                    !
+                 ENDDO ! isym
+                 !
+              ENDDO ! m2
+              ENDDO ! m1
+              !
+           ENDDO ! na2
+           ! 
+        ENDDO ! n3
+        ENDDO ! n2
+        ENDDO ! n1
+        !
+     ENDDO ! na1
+     !
+  ENDDO ! is
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = na1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     DO m1 = 1, ehub_lm(nt1)
+     DO m2 = 1, ehub_lm(nt2)
+        !
+        DO is = 1, nspin
+           n(1)%T(m1,m2,is,na1,na2) = 0.5D0 * (n(1)%T(m1,m2,is,na1,na2) + &
+                                               n(1)%T(m2,m1,is,na2,na1))
+           !
+           n(1)%T(m2,m1,is,na2,na1) = n(1)%T(m1,m2,is,na1,na2)
+        ENDDO
+        !
+     ENDDO
+     ENDDO
+     !
+  ENDDO
+  ENDDO
+  !
+  DO na1 = 1, nat
+  DO na2 = 1, nat
+     !
+     DO is = 1, nspin
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) &
+           n(1)%T(:,:,is,na1,na2) = 0.0_DP
+     ENDDO
+     !
+  ENDDO
+  ENDDO
+  !
+  DO i = 1, ehub_nnnc
+     n(i)%O = n(i)%T
+     DEALLOCATE (n(i)%T)
+  ENDDO
+
+END SUBROUTINE symmetrize_n5
+
+
+SUBROUTINE orberi(ehub_l, eri_l)
+
+  ! ehub_l = 1: s orbital [eri_l = 1(s)]
+  ! ehub_l = 2: p orbital [eri_l = 2(pz), 3(px), 4(py)]
+  ! ehub_l = 3: d orbital [eri_l = 5(dz^2-r^2), 6(dxz), 7(dyz), 8(dx^2-y^2),
+  ! 9(dxy)]
+
+  IMPLICIT NONE
+
+  INTEGER, INTENT(IN)    :: ehub_l
+  INTEGER, INTENT(INOUT) :: eri_l
+
+  IF (ehub_l == 1) THEN
+     eri_l = 1
+  ELSEIF (ehub_l == 2) THEN
+     IF (eri_l == 2) THEN
+        eri_l = 3
+     ELSEIF (eri_l == 3) THEN
+        eri_l = 4
+     ELSE
+        eri_l = 2
+     ENDIF
+  ELSEIF (ehub_l == 3) THEN
+     IF (eri_l == 5) THEN
+        eri_l = 6
+     ELSEIF (eri_l == 6) THEN
+        eri_l = 7
+     ELSEIF (eri_l == 7) THEN
+        eri_l = 8
+     ELSEIF (eri_l == 8) THEN
+        eri_l = 9
+     ELSE
+        eri_l = 5
+     ENDIF
+  ENDIF
+
+  RETURN
+
+END SUBROUTINE orberi
+!
+SUBROUTINE new_ns_v_nc(ns)
+
+   USE kinds,                ONLY : DP
+   USE constants,            ONLY : tpi
+   USE ions_base,            ONLY : nat, ityp, tau, ntyp => nsp
+   USE cell_base,            ONLY : at
+   USE klist,                ONLY : nks, ngk, xk
+   USE ldaV,                 ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                                    ehub_nn_vect, ehub_nn_dim,    &
+                                    ehub_nnnc, ehub_csize, wfcv,  &
+                                    nwfcv, ofstv, counter_lm
+   USE ldaU,                 ONLY : Hubbard_projectors
+   USE lsda_mod,             ONLY : lsda, current_spin, nspin, isk
+   USE noncollin_module,     ONLY : npol, noncolin, domag, lspinorb
+   USE wvfct,                ONLY : nbnd, npwx, wg
+   USE io_global,            ONLY : stdout
+   USE wavefunctions,        ONLY : evc
+   USE io_files,             ONLY : nwordwfc, iunwfc, nwordwfcv, iunhubv
+   USE buffers,              ONLY : get_buffer
+   USE mp_pools,             ONLY : inter_pool_comm
+   USE mp,                   ONLY : mp_sum
+   USE mp_bands,             ONLY : intra_bgrp_comm
+   USE becmod,               ONLY : bec_type, calbec,  &
+                                    allocate_bec_type, &
+                                    deallocate_bec_type
+   USE uspp_param,           ONLY : upf
+ 
+   IMPLICIT NONE
+ 
+   COMPLEX(DP), INTENT(OUT) :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+ 
+   TYPE occmat_5_nc
+      COMPLEX(DP), ALLOCATABLE :: O(:,:,:,:,:,:)
+      COMPLEX(DP), ALLOCATABLE :: T(:,:,:,:,:,:)
+   END TYPE occmat_5_nc
+  
+   COMPlEX(DP)           :: kphase
+   COMPLEX(DP), ALLOCATABLE           :: proj(:,:)
+ 
+   REAL(DP)              :: arg, psum
+ 
+   TYPE(occmat_5_nc)        :: n(ehub_nnnc)
+ 
+   INTEGER               :: ik, ibnd, is1, is2, i, j, k, npw, npw_
+   INTEGER               :: na1, na2, nt1, nt2
+   INTEGER               :: m1, m2, m3, m4, m1_, m2_
+   INTEGER               :: n1, n2, n3, nnc, ics
+
+   LOGICAL               :: save_flag
+ 
+   CALL start_clock('new_ns_v_nc')
+   !
+   ALLOCATE( proj(nwfcv,nbnd))
+   !
+   proj(:,:) = (0.0_DP,0.0_DP)
+   !
+   DO i = 1, ehub_nnnc
+      ALLOCATE ( n(i)%O(ehub_lm_max,ehub_lm_max,npol,npol,nat,nat) ) ; n(i)%O = 0.0_DP
+   ENDDO
+   !
+   ics = ehub_csize + 1
+   !
+   DO ik = 1, nks
+      !
+      npw = ngk(ik)
+      npw_ = npwx * npol
+      !
+      ! projection < wfcv | evc >
+      !
+      IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)     
+      IF ( Hubbard_projectors == 'pseudo' ) THEN
+         CALL errore('new_ns_v_nc', 'Hubbard_projectors = pseudo is not supported', 1)
+      ELSE
+         IF ( nks > 1 ) CALL get_buffer(wfcv, nwordwfcv, iunhubv, ik)
+         !
+         ! Refer to "projwave" in projwfc.f90
+         !
+         CALL calbec(npw_, wfcv, evc, proj)
+      ENDIF
+      !
+      ! WIY
+      !
+      !
+      ! calculate the occupation matrices n
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = na1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+            !
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            DO is1 = 1, npol
+            DO is2 = 1, npol
+               !
+               DO ibnd = 1, nbnd
+                n(1)%O(m1,m2,is1,is2,na1,na2) = &
+                n(1)%O(m1,m2,is1,is2,na1,na2) + &
+                                    wg(ibnd,ik) * &
+                        proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd)* &
+                  CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))
+               ENDDO
+               !
+            ENDDO
+            ENDDO
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = na1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+            DO is1 = 1, npol
+            DO is2 = 1, npol
+                n(1)%O(m2,m1,is2,is1,na2,na1) = CONJG(n(1)%O(m1,m2,is1,is2,na1,na2))
+            ENDDO !is2
+            ENDDO !is1
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      nnc = 2
+      !
+      DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+      DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+      DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+         !
+         IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+         !
+         arg = tpi * (                                              &
+          xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+          xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+          xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+         !
+         kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+         !
+         DO na1 = 1, nat
+            nt1 = ityp(na1)
+            !
+            IF ( ehub_lm(nt1) == 0 ) CYCLE
+            !
+         DO na2 = 1, nat
+            nt2 = ityp(na2)
+            !
+            IF ( ehub_lm(nt2) == 0 ) CYCLE
+            IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+            !
+            DO m1 = 1, ehub_lm(nt1)
+               !
+            DO m2 = 1, ehub_lm(nt2)
+               !
+               DO is1 = 1, npol
+               DO is2 = 1, npol
+                  !
+                  DO ibnd = 1, nbnd
+                    n(nnc)%O(m1,m2,is1,is2,na1,na2) = &
+                    n(nnc)%O(m1,m2,is1,is2,na1,na2) + &
+                        kphase*wg(ibnd,ik) * &
+                        proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) * &
+                  CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))
+                  ENDDO ! ibnd
+                  !
+               ENDDO 
+               ENDDO
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            !
+         ENDDO ! na2
+         ENDDO ! na1
+         !
+         IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+         !
+      ENDDO ! n3
+      ENDDO ! n2
+      ENDDO ! n1
+      !
+   ENDDO ! ik
+   !
+   DO i = 1, ehub_nnnc
+      CALL mp_sum(n(i)%O, inter_pool_comm)
+   ENDDO
+   !
+   CALL symmetrize_n5_nc(n)
+   !
+   ns = 0.0_DP
+   !
+   DO i = 1, ehub_nnnc
+    !
+    DO is1 = 1, npol
+    DO is2 = 1, npol
+        j = npol*(is1-1) + is2
+        ns(:,:,j,:,:,i) = n(i)%O(:,:,is1,is2,:,:)
+    ENDDO
+    ENDDO
+    !
+   ENDDO ! i
+   !   
+   ! checking ns Hermitean
+   !
+   !! temp
+   !!DO i = 1, ehub_nnnc
+   !   DO na1 = 1, nat
+   !      nt1 = ityp(na1)
+   !      !
+   !      IF ( ehub_lm(nt1) == 0 ) CYCLE
+   !      !
+   !      DO na2 = 1, nat
+   !         nt2 = ityp(na2)
+   !         !
+   !         IF ( ehub_lm(nt2) == 0 ) CYCLE
+   !         !
+   !         !IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+   !         !
+   !         DO is1 = 1, npol
+   !         DO is2 = 1, npol
+   !            j = npol * (is1 - 1) + is2
+   !            k = is1 + npol * (is2 - 1)
+   !            DO m2 = 1, ehub_lm(nt2)
+   !            DO m1 = 1, ehub_lm(nt1)
+   !               !psum = ABS( ns(m1,m2,j,na1,na2,i) - CONJG(ns(m2,m1,k,na2,na1,i)))
+   !               !IF (psum > 1.d-10) CALL errore( 'new_ns_v_nc', 'non Hermitean matrix', 1)
+   !            ENDDO !m2
+   !            ENDDO !m1
+   !         ENDDO !is2
+   !         ENDDO !is1
+   !      ENDDO !na2
+   !   ENDDO !na1
+   !!ENDDO !i
+   !! temp
+   DO i = 1, ehub_nnnc
+      DEALLOCATE ( n(i)%O )
+   ENDDO
+   !
+   DEALLOCATE(proj)
+   !
+   CALL stop_clock('new_ns_v_nc')
+   !
+   RETURN
+   !
+END SUBROUTINE new_ns_v_nc
+!
+SUBROUTINE new_ns_e0_nc_1(ns)
+
+   USE kinds,                ONLY : DP
+   USE constants,            ONLY : tpi, rytoev
+   USE ions_base,            ONLY : nat, ityp, ntyp => nsp, tau
+   USE cell_base,            ONLY : at, alat
+   USE klist,                ONLY : nks, ngk, xk
+   USE ldaV,                 ONLY : ehub_lm_max, ehub_lm, ehub_l,                      &
+                                    ehub_nn_vect, ehub_nn_leng, ehub_nn_dim,           &
+                                    ehub_csize, ehub_nnnc, ehub_mixing, ehub_conv_thr, &
+                                    ehub_v, ehub_v_diff, remove_ehub_u, write_ehub_uv, &
+                                    wfcv, nwfcv, ofstv, stop_acbn0, counter_lm
+   USE lsda_mod,             ONLY : lsda, current_spin, nspin, isk
+   USE noncollin_module,     ONLY : npol, noncolin, domag, lspinorb
+   USE wvfct,                ONLY : nbnd, npwx, wg
+   USE io_global,            ONLY : stdout
+   USE control_flags,        ONLY : gamma_only
+   USE wavefunctions,        ONLY : evc
+   USE io_files,             ONLY : nwordwfc, iunwfc, nwordwfcv, iunhubv
+   USE buffers,              ONLY : get_buffer
+   USE mp_pools,             ONLY : inter_pool_comm
+   USE mp,                   ONLY : mp_sum
+   USE becmod,               ONLY : bec_type, calbec,  &
+                                    allocate_bec_type, &
+                                    deallocate_bec_type
+   USE uspp_param,           ONLY : upf
+ 
+   IMPLICIT NONE
+ 
+   COMPLEX(DP), INTENT(OUT)    :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+ 
+   TYPE hubbard_ene_4
+      REAL(DP), ALLOCATABLE :: U(:,:,:,:)
+      REAL(DP), ALLOCATABLE :: V(:,:,:,:)
+      REAL(DP), ALLOCATABLE :: J(:,:,:,:)
+   END TYPE hubbard_ene_4
+ 
+   TYPE occmat_4_nc
+      COMPLEX(DP), ALLOCATABLE :: O(:,:,:,:,:)
+      COMPLEX(DP), ALLOCATABLE :: T(:,:,:,:,:)
+   END TYPE occmat_4_nc
+ 
+   TYPE occmat_5_nc
+      COMPLEX(DP), ALLOCATABLE :: O(:,:,:,:,:,:)
+      COMPLEX(DP), ALLOCATABLE :: T(:,:,:,:,:,:)
+   END TYPE occmat_5_nc
+   
+   TYPE occmat_4
+      REAL(DP), ALLOCATABLE    :: O(:,:,:,:)
+      REAL(DP), ALLOCATABLE    :: T(:,:,:,:)
+   END TYPE occmat_4
+
+   COMPLEX(DP), ALLOCATABLE    :: proj(:,:)
+ 
+   TYPE(hubbard_ene_4)      :: E0(ehub_nnnc)
+   TYPE(hubbard_ene_4)      :: HF(ehub_nnnc)
+ 
+   TYPE(occmat_5_nc)           :: n(ehub_nnnc)
+   TYPE(occmat_5_nc)           :: p(ehub_nnnc)
+   ! temp 
+   TYPE(occmat_4)           :: num(nbnd)
+   ! temp
+   TYPE(occmat_4_nc)           :: dm0
+   TYPE(occmat_4_nc)           :: dm1(ntyp,4)
+ 
+   COMPLEX(DP)              :: kphase
+   COMPLEX(DP)              :: n11, n12, n21, n22
+ 
+   REAL(DP), ALLOCATABLE    :: ehub_v_(:,:,:,:)
+ 
+   REAL(DP)                 :: arg
+   REAL(DP)                 :: ntau(3,nat)
+   REAL(DP)                 :: compute_eri
+   REAL(DP)                 :: c1(6), c2(6), c3(6), c4(6)
+ 
+   INTEGER                  :: npw, nw, npw_
+   INTEGER                  :: i, j, ik, ibnd, is, ix
+   INTEGER                  :: na, nt, m, l
+   INTEGER                  :: na1, na2
+   INTEGER                  :: nt1, nt2
+   INTEGER                  :: m1, m2, m3, m4
+   INTEGER                  :: l1, l2, l3, l4
+   INTEGER                  :: n1, n2, n3
+   INTEGER                  :: nnc, ics
+   INTEGER                  :: is1, is2
+ 
+   CALL start_clock('new_ns_e0_nc')
+ 
+   IF ( stop_acbn0 ) THEN
+      !
+      IF ( MAXVAL(ehub_v_diff(:,:,:,:,:)) < SQRT(ehub_conv_thr) ) THEN
+         CALL new_ns_v_nc(ns)
+         GOTO 1
+      ENDIF
+      !
+      ehub_v_diff = 0.0_DP
+      !
+   ENDIF
+ 
+   ALLOCATE( proj(nwfcv,nbnd))
+   !
+   ALLOCATE ( dm0%O(ehub_lm_max,ehub_lm_max,npol,npol,nat) ) ; dm0%O = 0.0_DP
+   !
+   DO nt = 1, ntyp
+      DO l = 1, 4
+         ALLOCATE ( dm1(nt,l)%O(ehub_lm_max,ehub_lm_max,npol,npol,nat) ) ; dm1(nt,l)%O = 0.0_DP
+      ENDDO
+   ENDDO
+   !
+   DO i = 1, ehub_nnnc
+      ALLOCATE ( n(i)%O(ehub_lm_max,ehub_lm_max,npol,npol,nat,nat) ) ; n(i)%O = 0.0_DP
+      ALLOCATE ( p(i)%O(ehub_lm_max,ehub_lm_max,npol,npol,nat,nat) ) ; p(i)%O = 0.0_DP
+      ALLOCATE ( E0(i)%V(4,4,nat,nat), E0(i)%J(4,4,nat,nat) )
+      ALLOCATE ( HF(i)%V(4,4,nat,nat), HF(i)%J(4,4,nat,nat) )
+   ENDDO
+ 
+   ics = ehub_csize + 1
+   !
+   DO ik = 1, nks
+      !
+      npw = ngk(ik)
+      npw_ = npwx * npol
+      !
+      ! projection < wfcv | evc >
+      !
+      IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+      IF ( nks > 1 ) CALL get_buffer(wfcv, nwordwfcv, iunhubv, ik)
+      CALL calbec(npw_, wfcv, evc, proj)
+      !
+      ! calculate the occupation matrices n
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2 ) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            DO is1 = 1, npol
+            DO is2 = 1, npol
+               !
+               DO ibnd = 1, nbnd
+                  n(1)%O(m1,m2,is1,is2,na1,na2) = &
+                  n(1)%O(m1,m2,is1,is2,na1,na2) + &
+                                         wg(ibnd,ik) * &
+                     proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) * &
+               CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))
+               ENDDO ! ibnd
+               !
+            ENDDO
+            ENDDO
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      nnc = 2
+      !
+      DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+      DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+      DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+         !
+         IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+         !
+         arg = tpi * (                                              &
+          xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+          xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+          xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+         !
+         kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+         !
+         DO na1 = 1, nat
+            nt1 = ityp(na1)
+            !
+            IF ( ehub_lm(nt1) == 0 ) CYCLE
+            !
+         DO na2 = 1, nat
+            nt2 = ityp(na2)
+            !
+            IF ( ehub_lm(nt2) == 0 ) CYCLE
+            !
+            IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+            !
+            DO m1 = 1, ehub_lm(nt1)
+            DO m2 = 1, ehub_lm(nt2)
+               !
+               DO is1 = 1, npol
+               DO is2 = 1, npol
+                  !
+                  DO ibnd = 1, nbnd
+                     n(nnc)%O(m1,m2,is1,is2,na1,na2) = &
+                     n(nnc)%O(m1,m2,is1,is2,na1,na2) + &
+                           kphase*wg(ibnd,ik) * &
+                           proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) * &
+                     CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))
+                  ENDDO ! ibnd
+                  !
+               ENDDO ! is2
+               ENDDO ! is1
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            !
+         ENDDO ! na2
+         ENDDO ! na1
+         !
+         IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+         !
+      ENDDO ! n3
+      ENDDO ! n2
+      ENDDO ! n1
+      !
+      ! calculate the renormalized occupations N(ACBN0)
+      !
+      DO i = 1, nbnd
+         ALLOCATE ( num(i)%O(4,4,ntyp,ntyp) ) ; num(i)%O = 0.0_DP
+         ALLOCATE ( num(i)%T(4,4,ntyp,ntyp) ) ; num(i)%T = 0.0_DP
+      ENDDO
+      !
+      DO na = 1, nat
+         nt = ityp(na)
+         !
+         IF ( ehub_lm(nt) == 0 ) CYCLE
+         !
+         DO m = 1, ehub_lm(nt)
+            !
+            l = ehub_l(m,nt)
+            !
+            DO is1 = 1, npol
+            !DO is2 = 1, npol
+            !   !
+            !   DO ibnd = 1, nbnd
+            !      ! question: How to consider renormalization nubmer in
+            !      ! nonlinear case?
+            !      ! The definition of Nicolas Tancogne-Dejean & Angel Rubio
+            !      num(ibnd)%O(l,l,nt,nt) = &
+            !      num(ibnd)%O(l,l,nt,nt) + &
+            !       DBLE(proj(ofstv(na)+m+counter_lm(m,nt)+(2*(ehub_l(m,nt)-1)+1)*(is2-1),ibnd) * &
+            !      CONJG(proj(ofstv(na)+m+counter_lm(m,nt)+(2*(ehub_l(m,nt)-1)+1)*(is1-1),ibnd)))
+            !   ENDDO ! ibnd
+            !   !
+            !ENDDO ! is2
+            ! Consider total charge in each band.
+               !
+               DO ibnd = 1, nbnd
+                  num(ibnd)%O(l,l,nt,nt) = &
+                  num(ibnd)%O(l,l,nt,nt) + &
+                   DBLE(proj(ofstv(na)+m+counter_lm(m,nt)+(2*(ehub_l(m,nt)-1)+1)*(is1-1),ibnd) * &
+                  CONJG(proj(ofstv(na)+m+counter_lm(m,nt)+(2*(ehub_l(m,nt)-1)+1)*(is1-1),ibnd)))
+               ENDDO
+               !
+            ENDDO ! is1
+            !
+         ENDDO ! m
+         !
+      ENDDO ! na
+      !
+      DO ibnd = 1, nbnd
+         !
+         DO nt1 = 1, ntyp
+         DO nt2 = 1, ntyp
+            !
+            IF ( upf(nt1)%psd /= upf(nt2)%psd ) CYCLE
+            !
+            num(ibnd)%T(:,:,nt1,nt1) = num(ibnd)%T(:,:,nt1,nt1) + &
+                                           num(ibnd)%O(:,:,nt2,nt2)
+            !
+         ENDDO ! nt2
+         ENDDO ! nt1
+         !
+      ENDDO ! ibnd
+      !
+      DO ibnd = 1, nbnd
+         !
+         DO nt1 = 1, ntyp
+         DO nt2 = 1, ntyp
+            !
+            DO l1 = 1, 4
+            DO l2 = 1, 4
+               !
+               ! Our definition
+               num(ibnd)%T(l1,l2,nt1,nt2) = num(ibnd)%T(l1,l1,nt1,nt1) + &
+                                                num(ibnd)%T(l2,l2,nt2,nt2)
+               !
+               IF ( upf(nt1)%psd == upf(nt2)%psd )                       &
+               num(ibnd)%T(l1,l2,nt1,nt2) = num(ibnd)%T(l1,l2,nt1,nt2) / &
+                                                2.0_DP
+               !
+               ! The definition of Nicolas Tancogne-Dejean & Angel Rubio
+ !             num(ibnd)%T(l1,l2,:,nt1,nt2) = SQRT(num(ibnd)%T(l1,l1,:,nt1,nt1) * &
+ !                                                 num(ibnd)%T(l2,l2,:,nt2,nt2))
+               !
+            ENDDO ! l2
+            ENDDO ! l1
+            !
+         ENDDO ! nt2
+         ENDDO ! nt1
+         !
+      ENDDO ! ibnd
+      !
+      DO ibnd = 1, nbnd
+         num(ibnd)%O = num(ibnd)%T
+         DEALLOCATE ( num(ibnd)%T )
+      ENDDO
+      !
+      ! calculate the renormalized occupation matrices P(ACBN0)
+      !
+      ! 1) P^II (dm0, dm1)
+      !
+      DO na = 1, nat
+         nt = ityp(na)
+         !
+         IF ( ehub_lm(nt) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt)
+            !
+            l1 = ehub_l(m1,nt)
+            !
+         DO m2 = 1, ehub_lm(nt)
+            !
+            l2 = ehub_l(m2,nt)
+            !
+            DO is1 = 1, npol
+            DO is2 = 1, npol
+               !
+               DO ibnd = 1, nbnd
+                  dm0%O(m1,m2,is1,is2,na) = &
+                  dm0%O(m1,m2,is1,is2,na) + &
+                            num(ibnd)%O(l1,l2,nt,nt) * wg(ibnd,ik) * &
+                  proj(ofstv(na)+m2+counter_lm(m2,nt)+(2*(ehub_l(m2,nt)-1)+1)*(is2-1),ibnd) * &
+            CONJG(proj(ofstv(na)+m1+counter_lm(m1,nt)+(2*(ehub_l(m1,nt)-1)+1)*(is1-1),ibnd))
+               ENDDO ! ibnd
+               !
+            ENDDO ! is1
+            ENDDO ! is2
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na
+ 
+      DO nt = 1, ntyp
+         !
+         IF ( ehub_lm(nt) == 0 ) CYCLE
+         !
+         DO l = 1, 4
+            !
+            DO na1 = 1, nat
+               nt1 = ityp(na1)
+               !
+               IF ( ehub_lm(nt1) == 0 ) CYCLE
+               !
+               DO m1 = 1, ehub_lm(nt1)
+               DO m2 = 1, ehub_lm(nt1)
+                  !
+                  DO is1 = 1, npol
+                  DO is2 = 1, npol
+                     !
+                     DO ibnd = 1, nbnd
+                        dm1(nt,l)%O(m1,m2,is1,is2,na1) = &
+                        dm1(nt,l)%O(m1,m2,is1,is2,na1) + &
+                           num(ibnd)%O(ehub_l(m1,nt1),l,nt1,nt) * wg(ibnd,ik) * &
+                           proj(ofstv(na1)+m2+counter_lm(m2,nt1)+(2*(ehub_l(m2,nt1)-1)+1)*(is2-1),ibnd) * &
+                     CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))                           
+                     ENDDO ! ibnd
+                     !
+                  ENDDO !is1
+                  ENDDO !is2
+                  !
+               ENDDO ! m2
+               ENDDO ! m1
+               !
+            ENDDO ! na1
+            !
+         ENDDO ! l
+         !
+      ENDDO ! nt
+      !
+      ! 2) P^IJ
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+            !
+            l1 = ehub_l(m1,nt1)
+            !
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            l2 = ehub_l(m2,nt2)
+            !
+            DO is1 = 1, npol
+            DO is2 = 1, npol
+               !
+               DO ibnd = 1, nbnd
+                    p(1)%O(m1,m2,is1,is2,na1,na2) = &
+                    p(1)%O(m1,m2,is1,is2,na1,na2) + &
+                      num(ibnd)%O(l1,l2,nt1,nt2) * wg(ibnd,ik) * &
+                      proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) * &
+                CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd)) 
+               ENDDO ! ibnd
+               !
+            ENDDO
+            ENDDO
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      nnc = 2
+      !
+      DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+      DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+      DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+         !
+         IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+         !
+         arg = tpi * (                                              &
+          xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+          xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+          xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+         !
+         kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+         !
+         DO na1 = 1, nat
+            nt1 = ityp(na1)
+            !
+            IF ( ehub_lm(nt1) == 0 ) CYCLE
+            !
+         DO na2 = 1, nat
+            nt2 = ityp(na2)
+            !
+            IF ( ehub_lm(nt2) == 0 ) CYCLE
+            !
+            IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+            !
+            DO m1 = 1, ehub_lm(nt1)
+               !
+               l1 = ehub_l(m1,nt1)
+               !
+            DO m2 = 1, ehub_lm(nt2)
+               !
+               l2 = ehub_l(m2,nt2)
+               !
+               DO is1 = 1, npol
+               DO is2 = 1, npol
+                  !
+                  DO ibnd = 1, nbnd
+                     p(nnc)%O(m1,m2,is1,is2,na1,na2) = &
+                     p(nnc)%O(m1,m2,is1,is2,na1,na2) + &
+                         kphase * num(ibnd)%O(l1,l2,nt1,nt2) * wg(ibnd,ik) * &
+                         proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) * &
+                   CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))                          
+                  ENDDO ! ibnd
+                  !
+               ENDDO ! is1
+               ENDDO ! is2
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            !
+         ENDDO ! na2
+         ENDDO ! na1
+         !
+         IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+         !
+      ENDDO ! n3
+      ENDDO ! n2
+      ENDDO ! n1
+      !
+      DO i = 1, nbnd
+         DEALLOCATE ( num(i)%O )
+      ENDDO
+ 
+   ENDDO ! ik
+ 
+   CALL mp_sum(dm0%O, inter_pool_comm)
+   !
+   DO nt = 1, ntyp
+      DO l = 1, 4
+         CALL mp_sum(dm1(nt,l)%O, inter_pool_comm)
+      ENDDO
+   ENDDO
+   !
+   DO i = 1, ehub_nnnc
+      CALL mp_sum(n(i)%O, inter_pool_comm)
+      CALL mp_sum(p(i)%O, inter_pool_comm)
+   ENDDO
+   !
+   CALL symmetrize_n5_nc(n)
+   !
+   ns = 0.0_DP
+   !
+   DO i = 1, ehub_nnnc
+      DO is1 = 1, npol
+      DO is2 = 1, npol
+         j = npol*(is1-1) + is2
+         ns(:,:,j,:,:,i) = n(i)%O(:,:,is1,is2,:,:)
+      ENDDO
+      ENDDO 
+      !
+      DEALLOCATE ( n(i)%O )
+      !
+   ENDDO
+   !
+   DEALLOCATE(proj)
+   !
+   CALL symmetrize_n4_nc(dm0)
+   !
+   CALL symmetrize_n4m_nc(dm1)
+   !
+   CALL symmetrize_n5_nc(p)
+   !
+   ! on-site interaction: U_ij^II
+   !
+   E0(1)%V = 0.0_DP ; E0(1)%J = 0.0_DP
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      l1 = 0
+      DO m1 = 1, ehub_lm(nt)
+         CALL orberi(ehub_l(m1,nt), l1)
+         CALL pao_3g(upf(nt)%psd, ehub_l(m1,nt), c1)
+         !
+      l2 = 0
+      DO m2 = 1, ehub_lm(nt)
+         CALL orberi(ehub_l(m2,nt), l2)
+         CALL pao_3g(upf(nt)%psd, ehub_l(m2,nt), c2)
+         !
+      l3 = 0
+      DO m3 = 1, ehub_lm(nt)
+         IF ( ehub_l(m3,nt) /= ehub_l(m1,nt) ) CYCLE
+         CALL orberi(ehub_l(m3,nt), l3)
+         CALL pao_3g(upf(nt)%psd, ehub_l(m3,nt), c3)
+         !
+      l4 = 0
+      DO m4 = 1, ehub_lm(nt)
+         IF ( ehub_l(m4,nt) /= ehub_l(m2,nt) ) CYCLE
+         CALL orberi(ehub_l(m4,nt), l4)
+         CALL pao_3g(upf(nt)%psd, ehub_l(m4,nt), c4)
+         !
+         IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+            E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+            E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+          DBLE(dm0%O(m3,m1,1,1,na)*dm0%O(m4,m2,2,2,na)  + &
+               dm0%O(m3,m1,2,2,na)*dm0%O(m4,m2,1,1,na)) * &
+                              compute_eri(l3,l1,l4,l2,    &
+                        tau(:,na)*alat,tau(:,na)*alat,    &
+                        tau(:,na)*alat,tau(:,na)*alat,    &
+                                          c3,c1,c4,c2)
+         ELSE
+            E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+            E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+          DBLE(dm0%O(m3,m1,1,1,na)*dm0%O(m4,m2,1,1,na)  + &
+               dm0%O(m3,m1,2,2,na)*dm0%O(m4,m2,2,2,na)  + &
+               dm0%O(m3,m1,1,1,na)*dm0%O(m4,m2,2,2,na)  + &
+               dm0%O(m3,m1,2,2,na)*dm0%O(m4,m2,1,1,na)) * &
+                              compute_eri(l3,l1,l4,l2,    &
+                        tau(:,na)*alat,tau(:,na)*alat,    &
+                        tau(:,na)*alat,tau(:,na)*alat,    &
+                                          c3,c1,c4,c2)
+ 
+            E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  = &
+            E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  + &
+          DBLE(dm0%O(m3,m1,1,1,na)*dm0%O(m4,m2,1,1,na)  + &
+               dm0%O(m3,m1,2,2,na)*dm0%O(m4,m2,2,2,na)  + &
+               dm0%O(m3,m1,2,1,na)*dm0%O(m4,m2,1,2,na)  + &
+               dm0%O(m3,m1,1,2,na)*dm0%O(m4,m2,2,1,na)) * &
+                              compute_eri(l3,l2,l4,l1,    &
+                        tau(:,na)*alat,tau(:,na)*alat,    &
+                        tau(:,na)*alat,tau(:,na)*alat,    &
+                                          c3,c2,c4,c1)
+         ENDIF
+         !
+      ENDDO ! m4
+      ENDDO ! m3
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na
+   !
+   HF(1)%V = 0.0_DP ; HF(1)%J = 0.0_DP
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt)
+      DO m2 = 1, ehub_lm(nt)
+         !
+         IF ( m1 == m2 ) THEN
+             HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+             HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+         DBLE(ns(m1,m1,1,na,na,1) * ns(m2,m2,4,na,na,1) + &
+              ns(m1,m1,4,na,na,1) * ns(m2,m2,1,na,na,1) - &
+              ns(m1,m1,2,na,na,1) * ns(m2,m2,3,na,na,1) - &
+              ns(m1,m1,3,na,na,1) * ns(m2,m2,2,na,na,1))
+         ELSE
+             HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+             HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+         DBLE(ns(m1,m1,1,na,na,1) * ns(m2,m2,1,na,na,1) + &
+              ns(m1,m1,4,na,na,1) * ns(m2,m2,4,na,na,1) + &
+              ns(m1,m1,1,na,na,1) * ns(m2,m2,4,na,na,1) + &
+              ns(m1,m1,4,na,na,1) * ns(m2,m2,1,na,na,1))
+ 
+             HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na) = &
+             HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na) + &
+         DBLE(ns(m1,m1,1,na,na,1) * ns(m2,m2,1,na,na,1) + &
+              ns(m1,m1,4,na,na,1) * ns(m2,m2,4,na,na,1) + &
+              ns(m1,m1,2,na,na,1) * ns(m2,m2,3,na,na,1) + &
+              ns(m1,m1,3,na,na,1) * ns(m2,m2,2,na,na,1)) 
+         ENDIF
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na
+   !
+   ALLOCATE ( ehub_v_(nat,nat,ehub_lm_max,ehub_lm_max) ) ; ehub_v_ = 0.0_DP
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt)
+      DO m2 = 1, ehub_lm(nt)
+         !
+         IF ( ehub_l(m1,nt) == 1 .AND. ehub_l(m2,nt) == 1 ) THEN
+            ehub_v_(na,na,m1,m2) =                           &
+                E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) / &
+                HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na) * &
+                           remove_ehub_u(nt,ehub_l(m1,nt)) * &
+                           remove_ehub_u(nt,ehub_l(m2,nt))
+         ELSE
+            ehub_v_(na,na,m1,m2) =                            &
+               (E0(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  / &
+                HF(1)%V(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  - &
+                E0(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)  / &
+                HF(1)%J(ehub_l(m1,nt),ehub_l(m2,nt),na,na)) * &
+                           remove_ehub_u(nt,ehub_l(m1,nt))  * &
+                           remove_ehub_u(nt,ehub_l(m2,nt))
+         ENDIF
+         !
+         IF ( stop_acbn0 ) ehub_v_diff(na,na,m1,m2,1) = ABS( ehub_v (na,na,m1,m2,1) &
+                                                      -      ehub_v_(na,na,m1,m2  ) )
+         !
+         ehub_v(na,na,m1,m2,1)                                 &
+             = (1.0_DP - ehub_mixing)*ehub_v (na,na,m1,m2,1) + &
+               (         ehub_mixing)*ehub_v_(na,na,m1,m2)
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na
+ 
+   !
+   ! inter-site interaction: U_ij^IJ (I /= J)
+   !
+   ! ... in the unit cell
+   !
+   E0(1)%V = 0.0_DP
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = na1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      l1 = 0
+      DO m1 = 1, ehub_lm(nt1)
+         CALL orberi(ehub_l(m1,nt1), l1)
+         CALL pao_3g(upf(nt1)%psd, ehub_l(m1,nt1), c1)
+         !
+      l2 = 0
+      DO m2 = 1, ehub_lm(nt2)
+         CALL orberi(ehub_l(m2,nt2), l2)
+         CALL pao_3g(upf(nt2)%psd, ehub_l(m2,nt2), c2)
+         !
+      l3 = 0
+      DO m3 = 1, ehub_lm(nt1)
+         IF ( ehub_l(m3,nt1) /= ehub_l(m1,nt1) ) CYCLE
+         CALL orberi(ehub_l(m3,nt1), l3)
+         CALL pao_3g(upf(nt1)%psd, ehub_l(m3,nt1), c3)
+         !
+      l4 = 0
+      DO m4 = 1, ehub_lm(nt2)
+         IF ( ehub_l(m4,nt2) /= ehub_l(m2,nt2) ) CYCLE
+         CALL orberi(ehub_l(m4,nt2), l4)
+         CALL pao_3g(upf(nt2)%psd, ehub_l(m4,nt2), c4)
+         !
+         E0(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  = &
+         E0(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  + &
+          DBLE(dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,1,na1)  * &
+               dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,1,na2)  + &
+               dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,2,na1)  * &
+               dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,2,na2)  + &
+               dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,1,na1)  * &
+               dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,2,na2)  + &
+               dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,2,na1)  * &
+               dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,1,na2)  - &
+                              p(1)%O(m3,m2,1,1,na1,na2)  * &
+                        CONJG(p(1)%O(m1,m4,2,2,na1,na2))  - &
+                              p(1)%O(m3,m2,2,2,na1,na2)  * &
+                        CONJG(p(1)%O(m1,m4,1,1,na1,na2))  - &
+                              p(1)%O(m3,m2,1,2,na1,na2)  * &
+                        CONJG(p(1)%O(m1,m4,1,2,na1,na2))  - &
+                              p(1)%O(m3,m2,2,1,na1,na2)  * &
+                        CONJG(p(1)%O(m1,m4,2,1,na1,na2)))* &
+                               compute_eri(l3,l1,l4,l2,    &
+                       tau(:,na1)*alat,tau(:,na1)*alat,    &
+                       tau(:,na2)*alat,tau(:,na2)*alat,    &
+                                           c3,c1,c4,c2)
+         !
+      ENDDO ! m4
+      ENDDO ! m3
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = na1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         !
+         E0(1)%V(ehub_l(m2,nt2),ehub_l(m1,nt1),na2,na1) = E0(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   HF(1)%V = 0.0_DP
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = na1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         !
+         HF(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2) = &
+         HF(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2) + &
+     DBLE(ns(m1,m1,1,na1,na1,1) * ns(m2,m2,1,na2,na2,1) + &
+          ns(m1,m1,4,na1,na1,1) * ns(m2,m2,4,na2,na2,1) + &
+          ns(m1,m1,1,na1,na1,1) * ns(m2,m2,4,na2,na2,1) + &
+          ns(m1,m1,4,na1,na1,1) * ns(m2,m2,1,na2,na2,1) - &
+          ns(m1,m2,1,na1,na2,1) *CONJG(ns(m1,m2,4,na1,na2,1)) - &
+          ns(m1,m2,4,na1,na2,1) *CONJG(ns(m1,m2,1,na1,na2,1)) - &
+          ns(m1,m2,2,na1,na2,1) *CONJG(ns(m1,m2,2,na1,na2,1)) - &
+          ns(m1,m2,3,na1,na2,1) *CONJG(ns(m1,m2,3,na1,na2,1)))
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = na1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         HF(1)%V(ehub_l(m2,nt2),ehub_l(m1,nt1),na2,na1) = HF(1)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = 1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+         !
+         l1 = ehub_l(m1,nt1)
+         !
+      DO m2 = 1, ehub_lm(nt2)
+         !
+         l2 = ehub_l(m2,nt2)
+         !
+         ehub_v_(na1,na2,m1,m2) = &
+                (E0(1)%V(l1,l2,na1,na2) / HF(1)%V(l1,l2,na1,na2)) / 2.0_DP
+         !
+         IF ( stop_acbn0 ) ehub_v_diff(na1,na2,m1,m2,1) = ABS( ehub_v (na1,na2,m1,m2,1) &
+                                                        -      ehub_v_(na1,na2,m1,m2  ) )
+         !
+         ehub_v(na1,na2,m1,m2,1)                                 &
+             = (1.0_DP - ehub_mixing)*ehub_v (na1,na2,m1,m2,1) + &
+               (         ehub_mixing)*ehub_v_(na1,na2,m1,m2)
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   ! ... out of the unit cell
+   !
+   DO i = 2, ehub_nnnc
+      E0(i)%V = 0.0_DP
+   ENDDO
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         DO ix = 1, 3
+            ntau(ix,na2) = n1 * at(ix,1) + n2 * at(ix,2) + n3 * at(ix,3) + tau(ix,na2)
+         ENDDO
+         !
+         l1 = 0
+         DO m1 = 1, ehub_lm(nt1)
+            CALL orberi(ehub_l(m1,nt1), l1)
+            CALL pao_3g(upf(nt1)%psd, ehub_l(m1,nt1), c1)
+            !
+         l2 = 0
+         DO m2 = 1, ehub_lm(nt2)
+            CALL orberi(ehub_l(m2,nt2), l2)
+            CALL pao_3g(upf(nt2)%psd, ehub_l(m2,nt2), c2)
+            !
+         l3 = 0
+         DO m3 = 1, ehub_lm(nt1)
+            IF ( ehub_l(m3,nt1) /= ehub_l(m1,nt1) ) CYCLE
+            CALL orberi(ehub_l(m3,nt1), l3)
+            CALL pao_3g(upf(nt1)%psd, ehub_l(m3,nt1), c3)
+            !
+         l4 = 0
+         DO m4 = 1, ehub_lm(nt2)
+            IF ( ehub_l(m4,nt2) /= ehub_l(m2,nt2) ) CYCLE
+            CALL orberi(ehub_l(m4,nt2), l4)
+            CALL pao_3g(upf(nt2)%psd, ehub_l(m4,nt2), c4)
+            !
+            E0(nnc)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  = &
+            E0(nnc)%V(ehub_l(m1,nt1),ehub_l(m2,nt2),na1,na2)  + &
+                 DBLE(dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,1,na1)  * &
+                      dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,1,na2)  + &
+                      dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,2,na1)  * &
+                      dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,2,na2)  + &
+                      dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,1,1,na1)  * &
+                      dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,2,2,na2)  + &
+                      dm1(nt2,ehub_l(m2,nt2))%O(m3,m1,2,2,na1)  * &
+                      dm1(nt1,ehub_l(m1,nt1))%O(m4,m2,1,1,na2)  - &
+                                   p(nnc)%O(m3,m2,1,1,na1,na2)  * &
+                             CONJG(p(nnc)%O(m1,m4,2,2,na1,na2)) - &
+                                   p(nnc)%O(m3,m2,2,2,na1,na2)  * &
+                             CONJG(p(nnc)%O(m1,m4,1,1,na1,na2)) - &
+                                   p(nnc)%O(m3,m2,1,2,na1,na2)  * &
+                             CONJG(p(nnc)%O(m1,m4,1,2,na1,na2)) - &
+                                   p(nnc)%O(m3,m2,2,1,na1,na2)  * &
+                             CONJG(p(nnc)%O(m1,m4,2,1,na1,na2)))* &
+                                    compute_eri(l3,l1,l4,l2,    &
+                           tau(:,na1)*alat, tau(:,na1)*alat,    &
+                          ntau(:,na2)*alat,ntau(:,na2)*alat,    &
+                                                c3,c1,c4,c2)
+            !
+         ENDDO ! m4
+         ENDDO ! m3
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+   DEALLOCATE ( dm0%O )
+   !
+   DO nt = 1, ntyp
+      DO l = 1, 4
+         DEALLOCATE ( dm1(nt,l)%O )
+      ENDDO
+   ENDDO
+   !
+   DO i = 2, ehub_nnnc
+      HF(i)%V = 0.0_DP
+   ENDDO
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+            !
+            l1 = ehub_l(m1,nt1)
+            !
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            l2 = ehub_l(m2,nt2)
+            !
+            HF(nnc)%V(l1,l2,na1,na2) = HF(nnc)%V(l1,l2,na1,na2) + &
+           DBLE(ns(m1,m1,1,na1,na1,  1)*ns(m2,m2,1,na2,na2,  1) + &
+                ns(m1,m1,4,na1,na1,  1)*ns(m2,m2,4,na2,na2,  1) + &
+                ns(m1,m1,1,na1,na1,  1)*ns(m2,m2,4,na2,na2,  1) + &
+                ns(m1,m1,4,na1,na1,  1)*ns(m2,m2,1,na2,na2,  1) - &          
+                ns(m1,m2,1,na1,na2,nnc)*CONJG(ns(m1,m2,4,na1,na2,nnc)) - &
+                ns(m1,m2,4,na1,na2,nnc)*CONJG(ns(m1,m2,1,na1,na2,nnc)) - &
+                ns(m1,m2,2,na1,na2,nnc)*CONJG(ns(m1,m2,2,na1,na2,nnc)) - &
+                ns(m1,m2,3,na1,na2,nnc)*CONJG(ns(m1,m2,3,na1,na2,nnc)))
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+            !
+            l1 = ehub_l(m1,nt1)
+            !
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            l2 = ehub_l(m2,nt2)
+            !
+            ehub_v_(na1,na2,m1,m2) = &
+                   (E0(nnc)%V(l1,l2,na1,na2) / HF(nnc)%V(l1,l2,na1,na2)) / 2.0_DP
+            !
+            IF ( stop_acbn0 ) ehub_v_diff(na1,na2,m1,m2,nnc) = ABS( ehub_v (na1,na2,m1,m2,nnc) &
+                                                             -      ehub_v_(na1,na2,m1,m2    ) )
+            !
+            ehub_v(na1,na2,m1,m2,nnc) =                               &
+                  (1.0_DP - ehub_mixing)*ehub_v (na1,na2,m1,m2,nnc) + &
+                  (         ehub_mixing)*ehub_v_(na1,na2,m1,m2    )
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+   DEALLOCATE ( ehub_v_ )
+   !
+   DO i = 1, ehub_nnnc
+      DEALLOCATE ( E0(i)%V, E0(i)%J )
+      DEALLOCATE ( HF(i)%V, HF(i)%J )
+   ENDDO
+   !
+   ! Hermiticity of Hubbard parameters U & V
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = na1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         ehub_v(na1,na2,m1,m2,1) = 0.5D0 * (ehub_v(na1,na2,m1,m2,1) + &
+                                            ehub_v(na2,na1,m2,m1,1))
+         !
+         ehub_v(na2,na1,m2,m1,1) = ehub_v(na1,na2,m1,m2,1)
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+   DO na2 = 1, nat
+      IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) &
+         ehub_v(na1,na2,:,:,1) = 0.0_DP
+   ENDDO ! na2
+   ENDDO ! na1
+ 
+ 1 CALL write_ehub_uv
+ 
+   CALL stop_clock('new_ns_e0_nc')
+ 
+   RETURN
+ 
+END SUBROUTINE new_ns_e0_nc_1
+!
+SUBROUTINE symmetrize_n4_nc( n )
+
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+   USE ldaV,                 ONLY : ehub_lm, ehub_l, ehub_lm_max, &
+                                    ehub_nn_vect, ehub_nn_dim,    &
+                                    ehub_csize, ehub_nnnc, d_spin_ldav
+   USE lsda_mod,             ONLY : nspin
+   USE noncollin_module,     ONLY : npol
+   USE symm_base,            ONLY : d1, d2, d3, nsym, irt, time_reversal, t_rev, sr
+ 
+   IMPLICIT NONE
+ 
+   TYPE occmat_4_nc
+      COMPLEX(DP), ALLOCATABLE :: O(:,:,:,:,:)
+      COMPLEX(DP), ALLOCATABLE :: T(:,:,:,:,:)
+   END TYPE occmat_4_nc
+ 
+   TYPE(occmat_4_nc), INTENT(INOUT) :: n
+ 
+   INTEGER                       :: isym, l, m, nt
+   INTEGER                       :: na1, na2
+   INTEGER                       :: nt1, nt2
+   INTEGER                       :: m1, m2, m3, m4
+   INTEGER                       :: m1_, m2_, m3_, m4_
+   INTEGER                       :: temp, l_separation(5,ntyp)
+   integer                       :: is1, is2, is3, is4
+   COMPLEX(DP)                   :: s_spin(2,2)
+   COMPLEX(DP)                   :: n11, n12, n21, n22
+ 
+   ALLOCATE (n%T(ehub_lm_max,ehub_lm_max,npol,npol,nat)) ; n%T = 0.0_DP
+ 
+   DO nt = 1, ntyp
+      !
+      temp = ehub_l(1,nt)
+      l_separation(ehub_l(1,nt),nt) = 1
+      !
+      DO m = 2, ehub_lm(nt)
+         !
+         IF ( ehub_l(m,nt) /= temp ) THEN
+            temp = ehub_l(m,nt)
+            l_separation(ehub_l(m,nt),nt) = m
+         ENDIF
+         !
+      ENDDO
+      !
+   ENDDO
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+         m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+         !
+      DO m2 = 1, ehub_lm(nt1)
+         m2_ = m2 - l_separation(ehub_l(m2,nt1),nt1) + 1
+         !
+         DO is1 = 1, npol
+         DO is2 = 1, npol
+            !
+            DO isym = 1, nsym
+               !
+               CALL find_u(sr(:,:,isym), s_spin(:,:))
+               !
+               na2 = irt(isym, na1)
+               !
+               DO m3 = 1, ehub_lm(nt1)
+                  IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                  m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                  !
+               DO m4 = 1, ehub_lm(nt1)
+                  IF ( ehub_l(m2,nt1) /= ehub_l(m4,nt1) ) CYCLE
+                  m4_ = m4 - l_separation(ehub_l(m4,nt1),nt1) + 1
+                  !
+                  DO is3 = 1, npol
+                  DO is4 = 1, npol
+                  !
+                  IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))           
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))           
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))       
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))       
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF 
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                      CONJG(n%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n%T(m1,m2,is1,is2,na1) = n%T(m1,m2,is1,is2,na1) + &
+                                            d_spin_ldav(is3,is1,isym) * &
+                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                            n%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                      CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF 
+                  ELSE
+                     CALL errore('new_ns_v','angular momentum not implemented',1)
+                  ENDIF
+                  !
+                  ENDDO ! is4
+                  ENDDO ! is3
+                  !
+               ENDDO ! m4
+               ENDDO ! m3
+               !
+            ENDDO ! isym
+            !
+         ENDDO ! is2
+         ENDDO ! is1
+         ! 
+      ENDDO ! m2
+      ENDDO ! m1
+      ! 
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO is1 = 1, npol
+      DO is2 = 1, npol
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = m1, ehub_lm(nt1)
+            !
+            n%T(m1,m2,is1,is2,na1) = 0.5D0 * (n%T(m1,m2,is1,is2,na1) + &
+                                        CONJG(n%T(m2,m1,is2,is1,na1)))
+            !
+            n%T(m2,m1,is2,is1,na1) = CONJG(n%T(m1,m2,is1,is2,na1))
+            !
+         ENDDO
+         ENDDO
+         !
+      ENDDO ! is2
+      ENDDO ! is1
+      !
+   ENDDO
+   !
+   !IF ( time_reversal) THEN
+   !!
+   !n11 = 0.0_DP
+   !n12 = 0.0_DP
+   !n21 = 0.0_DP
+   !n22 = 0.0_DP
+   !!
+   !DO na1 = 1, nat
+   !   nt1 = ityp(na1)
+   !   !
+   !   IF (ehub_lm(nt1) == 0 ) CYCLE
+   !   !
+   !   DO m1 = 1, ehub_lm(nt1)
+   !   DO m2 = 1, ehub_lm(nt1)
+   !   !
+   !   n11 = n%T(m1,m2,1,1,na1)
+   !   n11 = n%T(m1,m2,1,2,na1)
+   !   n11 = n%T(m1,m2,2,1,na1)
+   !   n11 = n%T(m1,m2,2,2,na1)
+   !   !
+   !   n%T(m1,m2,1,1,na1) = 0.5_DP*(n11+CONJG(n22))
+   !   n%T(m1,m2,1,2,na1) = 0.5_DP*(n12-CONJG(n21))
+   !   n%T(m1,m2,2,1,na1) = -CONJG(n%T(m1,m2,1,2,na1))
+   !   n%T(m1,m2,2,2,na1) = CONJG(n%T(m1,m2,1,1,na1))
+   !   !
+   !   ENDDO ! m2
+   !   ENDDO ! m1
+   !   !
+   !ENDDO ! na1
+   !!
+   !ENDIF
+   !
+   n%O = n%T
+   DEALLOCATE (n%T)
+ 
+END SUBROUTINE symmetrize_n4_nc
+!
+SUBROUTINE symmetrize_n4m_nc( n )
+
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+   USE ldaV,                 ONLY : ehub_lm, ehub_l, ehub_lm_max, &
+                                    ehub_nn_vect, ehub_nn_dim,    &
+                                    ehub_csize, ehub_nnnc, d_spin_ldav
+   USE lsda_mod,             ONLY : nspin
+   USE noncollin_module,     ONLY : npol
+   USE symm_base,            ONLY : d1, d2, d3, nsym, irt, time_reversal, t_rev, sr
+ 
+   IMPLICIT NONE
+ 
+   TYPE occmat_4_nc
+      COMPLEX(DP), ALLOCATABLE :: O(:,:,:,:,:)
+      COMPLEX(DP), ALLOCATABLE :: T(:,:,:,:,:)
+   END TYPE occmat_4_nc
+ 
+   TYPE(occmat_4_nc), INTENT(INOUT) :: n(ntyp,4)
+ 
+   INTEGER                       :: isym, i, l, m, nt
+   INTEGER                       :: na1, na2
+   INTEGER                       :: nt1, nt2
+   INTEGER                       :: m1, m2, m3, m4
+   INTEGER                       :: m1_, m2_, m3_, m4_
+   INTEGER                       :: temp, l_separation(5,ntyp)
+   INTEGER                       :: is1, is2, is3, is4
+   COMPLEX(DP)                   :: s_spin(2,2)
+   COMPLEX(DP)                   :: n11, n12, n21, n22
+ 
+   DO i = 1, ntyp
+      DO l = 1, 4
+         ALLOCATE (n(i,l)%T(ehub_lm_max,ehub_lm_max,npol,npol,nat)) ; n(i,l)%T = 0.0_DP
+      ENDDO
+   ENDDO
+   !
+   DO nt = 1, ntyp
+      !
+      temp = ehub_l(1,nt)
+      l_separation(ehub_l(1,nt),nt) = 1
+      !
+      DO m = 2, ehub_lm(nt)
+         !
+         IF ( ehub_l(m,nt) /= temp ) THEN
+            temp = ehub_l(m,nt)
+            l_separation(ehub_l(m,nt),nt) = m
+         ENDIF
+         !
+      ENDDO
+      !
+   ENDDO
+   !
+   DO nt = 1, ntyp
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      DO l = 1, 4
+         !
+         DO na1 = 1, nat
+            nt1 = ityp(na1)
+            !
+            IF ( ehub_lm(nt1) == 0 ) CYCLE
+            !
+            DO m1 = 1, ehub_lm(nt1)
+               m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+               !
+            DO m2 = 1, ehub_lm(nt1)
+               m2_ = m2 - l_separation(ehub_l(m2,nt1),nt1) + 1
+               !
+               DO is1 = 1, npol
+               DO is2 = 1, npol
+                  !
+                  DO isym = 1, nsym
+                     !
+                     CALL find_u(sr(:,:,isym), s_spin(:,:))
+                     !
+                     na2 = irt(isym, na1)
+                     !
+                     DO m3 = 1, ehub_lm(nt1)
+                        IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                        m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                        !
+                     DO m4 = 1, ehub_lm(nt1)
+                        IF ( ehub_l(m2,nt1) /= ehub_l(m4,nt1) ) CYCLE
+                        m4_ = m4 - l_separation(ehub_l(m4,nt1),nt1) + 1
+                        !
+                        DO is3 = 1, npol
+                        DO is4 = 1, npol
+                        !
+                        IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))      
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))    
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF 
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF 
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF 
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF 
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF 
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF 
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(n(nt,l)%O(m3,m4,is3,is4,na2)) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nt,l)%T(m1,m2,is1,is2,na1) = n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                          d_spin_ldav(is3,is1,isym) * &
+                                                    cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &
+                                                          n(nt,l)%O(m3,m4,is3,is4,na2) / (nsym) * &
+                                                    cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) * &
+                                                    CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE
+                           CALL errore('new_ns_v','angular momentum not implemented',1)
+                        ENDIF
+                        !
+                        ENDDO ! is4
+                        ENDDO ! is3
+                        !
+                     ENDDO ! m4
+                     ENDDO ! m3
+                     !
+                  ENDDO ! isym
+                  !
+               ENDDO ! is2
+               ENDDO ! is1
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            ! 
+         ENDDO ! na1
+         !
+      ENDDO ! l
+      !
+   ENDDO ! nt
+   !
+   DO nt = 1, ntyp
+      !
+      IF ( ehub_lm(nt) == 0 ) CYCLE
+      !
+      DO l = 1, 4
+         !
+         DO na1 = 1, nat
+            nt1 = ityp(na1)
+            !
+            IF ( ehub_lm(nt1) == 0 ) CYCLE
+            !
+            DO is1 = 1, npol
+            DO is2 = 1, npol
+               !
+               DO m1 = 1, ehub_lm(nt1)
+               DO m2 = m1, ehub_lm(nt1)
+                  !
+                  n(nt,l)%T(m1,m2,is1,is2,na1) = 0.5D0 * (n(nt,l)%T(m1,m2,is1,is2,na1) + &
+                                                    CONJG(n(nt,l)%T(m2,m1,is2,is1,na1)))
+                  !
+                  n(nt,l)%T(m2,m1,is2,is1,na1) = CONJG(n(nt,l)%T(m1,m2,is1,is2,na1))
+                  !
+               ENDDO
+               ENDDO
+               !
+            ENDDO
+            ENDDO 
+            !
+         ENDDO
+         !
+      ENDDO
+      !
+   ENDDO
+   !
+   DO nt = 1, ntyp
+      DO l = 1, 4
+         n(nt,l)%O = n(nt,l)%T
+         DEALLOCATE (n(nt,l)%T)
+      ENDDO
+   ENDDO
+ 
+END SUBROUTINE symmetrize_n4m_nc
+!
+SUBROUTINE symmetrize_n5_nc( n )
+
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+   USE ldaV,                 ONLY : ehub_lm, ehub_l, ehub_lm_max, &
+                                    ehub_nn_vect, ehub_nn_dim,    &
+                                    ehub_csize, ehub_nnnc, d_spin_ldav
+   USE lsda_mod,             ONLY : nspin
+   USE noncollin_module,     ONLY : npol
+   USE symm_base,            ONLY : d1, d2, d3, nsym, irt, time_reversal, t_rev, sr
+ 
+   IMPLICIT NONE
+ 
+   TYPE occmat_5_nc
+      COMPLEX(DP), ALLOCATABLE :: O(:,:,:,:,:,:)
+      COMPLEX(DP), ALLOCATABLE :: T(:,:,:,:,:,:)
+   END TYPE occmat_5_nc
+ 
+   TYPE(occmat_5_nc), INTENT(INOUT) :: n(ehub_nnnc)
+ 
+   INTEGER                       :: isym, i, m, nt
+   INTEGER                       :: na1, na2, na3, na4
+   INTEGER                       :: nt1, nt2, nt3, nt4
+   INTEGER                       :: m1, m2, m3, m4
+   INTEGER                       :: m1_, m2_, m3_, m4_
+   INTEGER                       :: n0(3), n1, n2, n3
+   INTEGER                       :: nnc0, nnc, ics
+   INTEGER                       :: temp, l_separation(5,ntyp)
+   INTEGER                       :: is1, is2, is3, is4
+   COMPLEX(DP)                   :: s_spin(2,2)
+   COMPLEX(DP)                   :: n11, n12, n21, n22
+
+   DO i = 1, ehub_nnnc
+      ALLOCATE (n(i)%T(ehub_lm_max,ehub_lm_max,npol,npol,nat,nat)) ; n(i)%T = 0.0_DP
+   ENDDO
+   !
+   DO nt = 1, ntyp
+      !
+      temp = ehub_l(1,nt)
+      l_separation(ehub_l(1,nt),nt) = 1
+      !
+      DO m = 2, ehub_lm(nt)
+         !
+         IF ( ehub_l(m,nt) /= temp ) THEN
+            temp = ehub_l(m,nt)
+            l_separation(ehub_l(m,nt),nt) = m
+         ENDIF
+         !
+      ENDDO
+      !
+   ENDDO
+   !
+   ics = ehub_csize + 1
+   !
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+         m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+         !
+      DO m2 = 1, ehub_lm(nt1)
+         m2_ = m2 - l_separation(ehub_l(m2,nt1),nt1) + 1
+         !
+         DO is1 = 1, npol
+         DO is2 = 1, npol
+            DO isym = 1, nsym
+               !
+               CALL find_u(sr(:,:,isym), s_spin(:,:))
+               !
+               na2 = irt(isym, na1)
+               !
+               DO m3 = 1, ehub_lm(nt1)
+                  IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                  m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                  !
+               DO m4 = 1, ehub_lm(nt1)
+                  IF ( ehub_l(m2,nt1) /= ehub_l(m4,nt1) ) CYCLE
+                  m4_ = m4 - l_separation(ehub_l(m4,nt1),nt1) + 1
+                  !
+                  DO is3 = 1, npol
+                  DO is4 = 1, npol
+                  !
+                  ! Below routines are from new_ns_nc in new_ns.f90
+                  ! Or d_matrix_nc in d_matrix_nc.f90 in PP
+                  ! With time reversal symmetry: spin 1 -> 2*, 2 -> -1* 
+                  !
+                  IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &    
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &    
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &                  
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) * &                  
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG((n(1)%O(m3,m4,is3,is4,na2,na2))) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym)) 
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF 
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1 )THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF 
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 1 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 2 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 3 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt1) == 4 ) THEN
+                     IF (t_rev(isym) == 1) THEN
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                             CONJG(n(1)%O(m3,m4,is3,is4,na2,na2)) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ELSE
+                     n(1)%T(m1,m2,is1,is2,na1,na1) = n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                   d_spin_ldav(is3,is1,isym) *  &
+                                             cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                   n(1)%O(m3,m4,is3,is4,na2,na2) * &
+                                             cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                             CONJG(d_spin_ldav(is4,is2,isym))
+                     ENDIF
+                  ELSE
+                     CALL errore('new_ns_v','angular momentum not implemented',1)
+                  ENDIF
+                  !
+                  ENDDO ! is4
+                  ENDDO ! is3
+                  !
+               ENDDO ! m4
+               ENDDO ! m3
+               !
+            ENDDO ! isym
+         ENDDO ! is1
+         ENDDO ! is2
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      ! 
+   ENDDO ! na1
+      !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+      DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+      DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+      DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+         !
+         n0(1) = n1 ; n0(2) = n2 ; n0(3) = n3
+         !
+         CALL hubbard_get_nnc(n0,nnc0)
+         !
+         DO na2 = 1, nat
+            nt2 = ityp(na2)
+            !
+            IF ( ehub_lm(nt2) == 0 ) CYCLE
+            !
+            IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+            !
+            DO m1 = 1, ehub_lm(nt1)
+               m1_ = m1 - l_separation(ehub_l(m1,nt1),nt1) + 1
+               !
+            DO m2 = 1, ehub_lm(nt2)
+               m2_ = m2 - l_separation(ehub_l(m2,nt2),nt2) + 1
+               !
+               DO is1 = 1, npol
+               DO is2 = 1, npol
+                  !
+                  DO isym = 1, nsym
+                     !
+                     CALL find_u(sr(1,1,isym), s_spin)
+                     !
+                     CALL hubbard_symmetry(na1,na2,na3,na4,n0,nnc,isym)
+                     !
+                     DO m3 = 1, ehub_lm(nt1)
+                        IF ( ehub_l(m1,nt1) /= ehub_l(m3,nt1) ) CYCLE
+                        m3_ = m3 - l_separation(ehub_l(m3,nt1),nt1) + 1
+                        !
+                     DO m4 = 1, ehub_lm(nt2)
+                        IF ( ehub_l(m2,nt2) /= ehub_l(m4,nt2) ) CYCLE
+                        m4_ = m4 - l_separation(ehub_l(m4,nt2),nt2) + 1
+                        !
+                        DO is3 = 1, npol
+                        DO is4 = 1, npol
+                        !
+                        IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &                   
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &                   
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &                   
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &                   
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 1 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &                   
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) * &                   
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))  
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))  
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 2 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d1(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 3 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d2(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 1 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym))
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 2 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d1(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 3 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d2(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE IF ( ehub_l(m1,nt1) == 4 .AND. ehub_l(m2,nt2) == 4 ) THEN
+                           IF (t_rev(isym) == 1) THEN
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                      CONJG(n(nnc)%O(m3,m4,is3,is4,na3,na4)) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ELSE
+                           n(nnc0)%T(m1,m2,is1,is2,na1,na2) = n(nnc0)%T(m1,m2,is1,is2,na1,na2) + &
+                                                            d_spin_ldav(is3,is1,isym) *  &
+                                                      cmplx(d3(m3_,m1_,isym), 0.d0, kind=DP) * &                                                                      
+                                                            n(nnc)%O(m3,m4,is3,is4,na3,na4) * &
+                                                      cmplx(d3(m4_,m2_,isym), 0.d0, kind=DP) / (nsym) * &
+                                                      CONJG(d_spin_ldav(is4,is2,isym)) 
+                           ENDIF
+                        ELSE
+                           CALL errore('new_ns_v','angular momentum not implemented',1)
+                        ENDIF
+                        !
+                        ENDDO ! is4
+                        ENDDO ! is3
+                     !
+                     ENDDO ! m4
+                     ENDDO ! m3
+                  !
+                  ENDDO ! isym
+                  !
+               ENDDO ! is2
+               ENDDO ! is1
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            !
+         ENDDO ! na2
+         ! 
+      ENDDO ! n3
+      ENDDO ! n2
+      ENDDO ! n1
+      !
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   !DO na2 = na1, nat
+   !   nt2 = ityp(na2)
+   !   !
+   !   IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt1)
+         !
+         DO is1 = 1, npol
+         DO is2 = 1, npol
+            n(1)%T(m1,m2,is1,is2,na1,na1) = 0.5_DP * (n(1)%T(m1,m2,is1,is2,na1,na1) + &
+                                                CONJG(n(1)%T(m2,m1,is2,is1,na1,na1)))
+            !
+            n(1)%T(m2,m1,is2,is1,na1,na1) = CONJG(n(1)%T(m1,m2,is1,is2,na1,na1))
+         ENDDO
+         ENDDO
+         !
+      ENDDO
+      ENDDO
+      !
+   !ENDDO
+   ENDDO
+   !
+   IF ( time_reversal ) THEN
+   ! in a nonmagnetic case, considering the time reversal
+   !
+   DO i = 1, ehub_nnnc 
+      !
+      n11 = 0.0_DP
+      n12 = 0.0_DP
+      n21 = 0.0_DP
+      n22 = 0.0_DP
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         ! 
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+         !
+         n11 = n(i)%T(m1,m2,1,1,na1,na2)
+         n12 = n(i)%T(m1,m2,1,2,na1,na2)
+         n21 = n(i)%T(m1,m2,2,1,na1,na2)
+         n22 = n(i)%T(m1,m2,2,2,na1,na2)
+         !
+         n(i)%T(m1,m2,1,1,na1,na2) = 0.5_DP*(n11+CONJG(n22))
+         n(i)%T(m1,m2,1,2,na1,na2) = 0.5_DP*(n12-CONJG(n21))
+         n(i)%T(m1,m2,2,1,na1,na2) = -CONJG(n(i)%T(m1,m2,1,2,na1,na2))
+         n(i)%T(m1,m2,2,2,na1,na2) = CONJG(n(i)%T(m1,m2,1,1,na1,na2))
+         !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+   ENDDO ! ehub_nnnc
+   !
+   ENDIF
+   !
+   DO na1 = 1, nat
+   DO na2 = 1, nat
+      !
+      DO is1 = 1, npol
+      Do is2 = 1, npol
+         IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) &
+            n(1)%T(:,:,is1,is2,na1,na2) = 0.0_DP
+      ENDDO
+      ENDDO
+      !
+   ENDDO
+   ENDDO
+   !
+   DO i = 1, ehub_nnnc
+      n(i)%O = n(i)%T
+      DEALLOCATE (n(i)%T)
+   ENDDO
+ 
+END SUBROUTINE symmetrize_n5_nc
+!
+
+
diff --git a/PW/src/non_scf.f90 b/PW/src/non_scf.f90
index ac5af84a3..ca795b377 100644
--- a/PW/src/non_scf.f90
+++ b/PW/src/non_scf.f90
@@ -31,6 +31,9 @@ SUBROUTINE non_scf( )
   USE scf,                  ONLY : rho, rho_core, rhog_core, v, vltot, vrs, kedtau
   USE ener,                 ONLY : ehart, etxc, vtxc, epaw
   USE ldaU,                 ONLY : eth
+  ! by WIY
+  USE ldav,                 ONLY : ehubene
+  ! by WIY
   USE extfield,             ONLY : etotefield
   USE paw_onecenter,        ONLY : PAW_potential
   USE paw_variables,        ONLY : okpaw, ddd_paw
@@ -155,7 +158,9 @@ SUBROUTINE non_scf( )
      CALL exxinit(.false., nbnd)
      IF (use_ace) CALL aceinit ( .false. )
      CALL v_of_rho( rho, rho_core, rhog_core, &
-         ehart, etxc, vtxc, eth, etotefield, charge, v)
+         ! by WIY
+         ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v)
+         ! by WIY
      IF (okpaw) CALL PAW_potential(rho%bec, ddd_PAW, epaw,etot_cmp_paw)
      CALL set_vrs( vrs, vltot, v%of_r, kedtau, v%kin_r, dfftp%nnr, &
                    nspin, doublegrid )
diff --git a/PW/src/offset_atom_wfc.f90 b/PW/src/offset_atom_wfc.f90
index bebe054f3..641a167d8 100644
--- a/PW/src/offset_atom_wfc.f90
+++ b/PW/src/offset_atom_wfc.f90
@@ -141,7 +141,7 @@ SUBROUTINE offset_atom_wfc( hubbard_only, lflag, offset, counter )
                  IF (hubbard_wfc .OR. .NOT.hubbard_only) THEN
                     ! j = l-1/2, degeneracy 2l
                     counter = counter + 2*l
-                    ! j = l+1/2, degeneracy 2*l+2
+                     ! j = l+1/2, degeneracy 2*l+2
                     IF (ABS( upf(nt)%jchi(n)-l-0.5D0 ) < 1.D-6) &
                       counter = counter + 2
                  ENDIF
diff --git a/PW/src/offset_atom_wfc_v.f90 b/PW/src/offset_atom_wfc_v.f90
new file mode 100644
index 000000000..9f3d1ef7d
--- /dev/null
+++ b/PW/src/offset_atom_wfc_v.f90
@@ -0,0 +1,91 @@
+SUBROUTINE offset_atom_wfc_v( hubbard_only, offset, counter )
+  !
+  USE kinds,            ONLY : DP
+  USE uspp_param,       ONLY : upf
+  USE ions_base,        ONLY : nat, ityp
+  USE ldaV,             ONLY : ehub_l_choice
+  USE noncollin_module, ONLY : noncolin
+  !
+  IMPLICIT NONE
+  !
+  LOGICAL, INTENT(IN)  :: hubbard_only 
+  INTEGER, INTENT(OUT) :: offset(nat), counter
+  !
+  INTEGER  :: na, nt, nw, l
+  LOGICAL  :: hubbard_wfc
+  CHARACTER(LEN=2) :: s
+  !
+  offset(:) = -99
+  counter   =   0
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     ! WIY
+     WRITE(s,'(i2)') nt
+     IF ( ( ANY(ehub_l_choice(nt,:) >= 1) ) .AND. upf(nt)%nwfc < 1 ) THEN
+        CALL errore('offset_atom_wfc_v', 'no atomic wavefunctions in &
+               &pseudopotential file for species #' // s // new_line('a') // &
+               &'use a pseudopotential file with atomic wavefunctions!', 1)
+     ENDIF
+     ! WIY
+     !
+     DO nw = 1, upf(nt)%nwfc
+        !
+        IF ( upf(nt)%oc(nw) >= 0.D0 ) THEN
+           !
+           l = upf(nt)%lchi(nw)
+           !
+           ! WIY
+           IF ( noncolin ) THEN
+              !
+              hubbard_wfc = .FALSE.
+              !
+              IF ( ehub_l_choice(nt,l+1) == nw .OR. &
+                 ( ehub_l_choice(nt,l+1) == nw+1 .AND. l /= 0)) hubbard_wfc = .TRUE.
+              !
+              IF (upf(nt)%has_so ) THEN
+                 !
+                 ! offset to be set at the first occurrence of required l
+                 IF ( hubbard_wfc .AND. offset(na) == -99 ) &
+                  & offset(na) = counter
+                 !
+                 IF ( .NOT. hubbard_only .OR. hubbard_wfc ) THEN
+                    ! j = l-1/2, degeneracy 2l
+                    counter = counter + 2*l
+                    ! j = l+1/2, degeneracy 2*l+2
+                    IF (ABS( upf(nt)%jchi(nw)-l-0.5_DP ) < 1.D-6) &
+                    &  counter = counter + 2
+                    !
+                 ENDIF
+                 !
+              ELSE
+                 !
+                 IF ( ehub_l_choice(nt,l+1) == nw .AND. offset(na) == -99 ) &
+                  & offset(na) = counter
+                 !
+                 IF ( .NOT. hubbard_only .OR. ehub_l_choice(nt,l+1) == nw ) &
+                  & counter = counter + 2*( 2*l + 1 )
+                 !
+              ENDIF
+              !
+           ELSE
+              !
+              IF ( ehub_l_choice(nt,nw) == 1 .AND. offset(na) == -99 ) &
+               & offset(na) = counter
+              !
+              IF ( .NOT. hubbard_only .OR. ehub_l_choice(nt,nw) == 1 ) &
+               & counter = counter + 2*l + 1
+              !
+           ENDIF
+           ! WIY
+           !
+        ENDIF
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  RETURN
+
+END SUBROUTINE offset_atom_wfc_v
diff --git a/PW/src/openfil.f90 b/PW/src/openfil.f90
index 22b4f15c5..64dfecbd8 100644
--- a/PW/src/openfil.f90
+++ b/PW/src/openfil.f90
@@ -19,9 +19,15 @@ SUBROUTINE openfil()
   USE wvfct,            ONLY : nbnd, npwx
   USE fixed_occ,        ONLY : one_atom_occupations
   USE ldaU,             ONLY : lda_plus_U, Hubbard_projectors, nwfcU
+  ! by LSH
+  USE ldaV,             ONLY : lda_plus_v, nwfcv
+  ! by LSH
   USE io_files,         ONLY : prefix, iunpun, iunsat, &
                                iunhub, nwordwfcU, nwordwfc, nwordatwfc, &
-                               iunefield, iunefieldm, iunefieldp, seqopn
+                               ! by LSH
+                               iunefield, iunefieldm, iunefieldp, seqopn, &
+                               iunhubv, nwordwfcv
+                               ! by LSH
   USE noncollin_module, ONLY : npol
   USE bp,               ONLY : lelfield
   USE wannier_new,      ONLY : use_wannier
@@ -44,10 +50,17 @@ SUBROUTINE openfil()
   nwordwfc  = nbnd*npwx*npol
   nwordatwfc= npwx*natomwfc*npol
   nwordwfcU = npwx*nwfcU*npol
+  ! by LSH
+  nwordwfcv = npwx*nwfcv*npol
+  ! by LSH
   !
   IF ( lda_plus_u .AND. (Hubbard_projectors.NE.'pseudo') ) THEN
      CALL open_buffer( iunhub,  'hub',  nwordwfcU, io_level, exst )
   ENDIF
+  ! by LSH
+  IF ( lda_plus_v .AND. (Hubbard_projectors.NE.'pseudo') ) &
+     CALL open_buffer( iunhubv, 'hubv',  nwordwfcv, io_level, exst )
+  ! by LSH
   IF ( use_wannier .OR. one_atom_occupations ) &
      CALL open_buffer( iunsat, 'satwfc', nwordatwfc, io_level, exst )
   !
diff --git a/PW/src/orthoatwfc.f90 b/PW/src/orthoatwfc.f90
index b45040da0..6eb753a47 100644
--- a/PW/src/orthoatwfc.f90
+++ b/PW/src/orthoatwfc.f90
@@ -140,7 +140,6 @@ SUBROUTINE orthoUwfc(save_wfcatom)
   RETURN
   !
 END SUBROUTINE orthoUwfc
-!
 !-----------------------------------------------------------------------
 SUBROUTINE orthoUwfc_k (ik, lflag)
   !-----------------------------------------------------------------------
diff --git a/PW/src/orthoatwfc_v.f90 b/PW/src/orthoatwfc_v.f90
new file mode 100644
index 000000000..d51245c7d
--- /dev/null
+++ b/PW/src/orthoatwfc_v.f90
@@ -0,0 +1,185 @@
+! Refer to SUBROUTINE orthoUwfc in orhoatwfc.f90
+! by WIY 
+SUBROUTINE orthowfcv
+
+  USE kinds,            ONLY : DP
+  USE buffers,          ONLY : get_buffer, save_buffer
+  USE io_global,        ONLY : stdout
+  USE io_files,         ONLY : iunhubv, nwordwfcv
+  USE ions_base,        ONLY : nat
+  USE basis,            ONLY : natomwfc, swfcatom
+  USE klist,            ONLY : nks, xk, ngk, igk_k
+  USE ldaU,             ONLY : Hubbard_projectors
+  USE ldaV,             ONLY : wfcv, nwfcv, copy_v_wfc
+  USE wvfct,            ONLY : npwx
+  USE uspp,             ONLY : nkb, vkb
+  USE becmod,           ONLY : allocate_bec_type,   &
+                               deallocate_bec_type, &
+                               bec_type, becp, calbec
+  USE control_flags,    ONLY : gamma_only
+  USE noncollin_module, ONLY : noncolin, npol
+  USE mp_bands,         ONLY : use_bgrp_in_hpsi
+  USE uspp_init,        ONLY : init_us_2
+
+  IMPLICIT NONE
+
+  INTEGER :: ik, npw
+
+  LOGICAL :: orthogonalize_wfc, normalize_only, save_flag
+
+  COMPLEX(DP), ALLOCATABLE :: wfcatom(:,:)
+
+  ! by WIY
+  ! Since eACBN0 code uses ortho-atomic wfcs only, we impose Hubbard_projectors to 'ortho-atomic'
+  Hubbard_projectors = 'ortho-atomic'
+  ! by WIY
+
+  IF ( Hubbard_projectors=="ortho-atomic" ) THEN
+     orthogonalize_wfc = .TRUE.
+     normalize_only = .FALSE.
+     WRITE ( stdout,'(/5x,a,/)') 'Atomic wfcs used for DFT+U+V projectors are orthogonalized'
+     IF ( gamma_only ) CALL errore('orthoatwfcv', &
+          'Gamma-only calculation for this case not implemented', 1 )
+  ELSE
+     WRITE ( stdout,'(/5x,"Hubbard_projectors = ",a)') Hubbard_projectors
+     CALL errore ("orthoatwfcv"," This type of Hubbard projectors is not valid",1)
+  ENDIF
+  !
+  ALLOCATE ( wfcatom(npwx*npol, natomwfc), swfcatom(npwx*npol, natomwfc) )
+  !
+  save_flag = use_bgrp_in_hpsi ; use_bgrp_in_hpsi = .false.
+  !
+  ! Allocate the array becp = <beta|wfcatom>
+  CALL allocate_bec_type(nkb, natomwfc, becp)
+  !
+  DO ik = 1, nks
+     !
+     IF ( noncolin ) THEN
+       CALL atomic_wfc_v_nc(ik, wfcatom)
+       !CALL atomic_wfc_nc_updown_v(ik, wfcatom)
+     ELSE
+       CALL atomic_wfc(ik, wfcatom)
+     ENDIF
+     !
+     npw = ngk(ik)
+     !
+     CALL init_us_2(npw, igk_k(1,ik), xk(1,ik), vkb)
+     CALL calbec(npw, vkb, wfcatom, becp)
+     CALL s_psi(npwx, npw, natomwfc, wfcatom, swfcatom)
+     !
+     IF ( orthogonalize_wfc ) &
+        CALL ortho_swfc(npw, normalize_only, natomwfc, wfcatom, swfcatom, .FALSE.)
+     !
+     ! copy S * atomic wavefunctions with Hubbard term only in wfcv
+     ! (this is used during the self-consistent solution of Kohn-Sham equations)
+     ! save to unit iunhubv
+     ! 
+     CALL copy_v_wfc(swfcatom, noncolin)
+     !
+     IF ( nks > 1 ) &
+        CALL save_buffer(wfcv, nwordwfcv, iunhubv, ik)
+     !
+  ENDDO
+  !
+  DEALLOCATE ( wfcatom, swfcatom )
+  !
+  CALL deallocate_bec_type(becp)
+  !
+  use_bgrp_in_hpsi = save_flag
+  !
+  RETURN
+
+END SUBROUTINE orthowfcv
+!
+!-----------------------------------------------------------------------
+SUBROUTINE orthowfcv2 (ik)
+  !
+  ! For a given k point "ik", this routine computes (ortho-)atomic wavefunctions 
+  ! having an associated Hubbard U term * S, for DFT+U(+V) calculations. 
+  ! Also without S (this is then used to computed Hubbard forces 
+  ! and stresses). 
+  ! wfcatom and swfcatom must be allocated on input.
+  ! Beta functions vkb must be already computed before.
+  ! 
+  ! please refer to orthoUwfc_k in orthoatwfc.f90
+  !
+  USE kinds,            ONLY : DP
+  USE io_global,        ONLY : stdout
+  USE io_files,         ONLY : iunhubv, nwordwfcv
+  USE ions_base,        ONLY : nat
+  USE basis,            ONLY : natomwfc, wfcatom, swfcatom
+  USE klist,            ONLY : nks, xk, ngk, igk_k
+  USE ldaU,             ONLY : Hubbard_projectors
+  USE ldaV,             ONLY : wfcv, nwfcv, copy_v_wfc
+  USE wvfct,            ONLY : npwx
+  USE uspp,             ONLY : nkb, vkb
+  USE becmod,           ONLY : allocate_bec_type, deallocate_bec_type, &
+                               bec_type, becp, calbec
+  USE control_flags,    ONLY : gamma_only
+  USE noncollin_module, ONLY : noncolin, npol
+  ! 
+  IMPLICIT NONE
+  !
+  INTEGER, INTENT(IN) :: ik ! the k point under consideration
+  !
+  INTEGER :: npw
+  LOGICAL :: orthogonalize_wfc, normalize_only, save_flag
+  COMPLEX(DP), ALLOCATABLE :: aux(:,:)
+
+  IF ( Hubbard_projectors=="ortho-atomic" ) THEN
+     orthogonalize_wfc = .TRUE.
+     normalize_only = .FALSE.
+     IF ( gamma_only ) CALL errore('orthoatwfcv2', &
+          'Gamma-only calculation for this case not implemented', 1 )
+  ELSE
+     WRITE ( stdout,'(/5x,"Hubbard_projectors = ",a)') Hubbard_projectors
+     CALL errore ("orthoatwfcv2"," This type of Hubbard projectors is not valid",1)
+  ENDIF
+  !
+  ! Compute atomic wfc at this k (phi)
+  IF (noncolin) THEN
+     CALL atomic_wfc_v_nc (ik, wfcatom)
+  ELSE
+     CALL atomic_wfc (ik, wfcatom)
+  ENDIF
+  !
+  IF (Hubbard_projectors=="ortho-atomic") THEN
+     ALLOCATE(aux(npwx*npol,natomwfc))
+     ! Copy atomic wfcs (phi)
+     aux(:,:) = wfcatom(:,:)
+  ENDIF
+  !
+  IF (orthogonalize_wfc) THEN
+     !
+     ! Number of plane waves at this k point
+     npw = ngk(ik)
+     !
+     ! Allocate the array becp = <beta|wfcatom>
+     CALL allocate_bec_type (nkb,natomwfc, becp)
+     CALL calbec (npw, vkb, wfcatom, becp)
+     ! Calculate swfcatom = S * phi
+     CALL s_psi (npwx, npw, natomwfc, wfcatom, swfcatom)
+     CALL deallocate_bec_type (becp)
+     !  
+     ! Compute the overlap matrix
+     ! On the output: wfcatom = O^{-1/2} \phi (no ultrasoft S)
+     CALL ortho_swfc ( npw, normalize_only, natomwfc, wfcatom, swfcatom, .TRUE. )
+     !
+  ENDIF
+  !
+  ! Copy (ortho-)atomic wavefunctions with Hubbard U term only 
+  ! in wfcU (no ultrasoft S).
+  CALL copy_v_wfc (wfcatom, noncolin)
+  !
+  IF (Hubbard_projectors=="ortho-atomic") THEN
+     ! Copy atomic wfcs
+     wfcatom(:,:) = aux(:,:)
+     DEALLOCATE(aux)
+  ENDIF
+  !
+  RETURN
+  !   
+
+END SUBROUTINE orthowfcv2
+!
+! by WIY
diff --git a/PW/src/pao_3g.f90 b/PW/src/pao_3g.f90
new file mode 100644
index 000000000..9a0d8eefd
--- /dev/null
+++ b/PW/src/pao_3g.f90
@@ -0,0 +1,1619 @@
+SUBROUTINE pao_3g(psd, ehub_l, c)
+
+      USE kinds, ONLY: DP
+
+      IMPLICIT NONE
+
+      CHARACTER(LEN=2), INTENT(IN)  :: psd
+      INTEGER,          INTENT(IN)  :: ehub_l
+      REAL(DP),         INTENT(OUT) :: c(6)
+      !
+      c = 0.0_DP
+      !
+      SELECT CASE (TRIM(ADJUSTL(psd)))
+
+         CASE ('H') ! #1
+            IF (ehub_l == 1) THEN
+               c(1) =  0.604191619248_DP
+               c(2) =  0.167940726333_DP
+               c(3) =  0.714258724303_DP
+               c(4) =  0.338717115284_DP
+               c(5) =  0.082184110767_DP
+               c(6) =  1.825678822667_DP
+            ENDIF
+
+         CASE ('He') ! #2
+            IF (ehub_l == 1) THEN
+               c(1) =  0.942547702298_DP
+               c(2) =  0.206527701640_DP
+               c(3) =  1.798439422996_DP
+               c(4) =  0.651044598727_DP
+               c(5) =  0.178014952630_DP
+               c(6) =  2.744063563515_DP
+            ENDIF
+
+         CASE ('Li') ! #3
+            IF (ehub_l == 1) THEN
+               c(1) = -0.241751641077_DP
+               c(2) =  0.646397993211_DP
+               c(3) =  0.501125834943_DP
+               c(4) =  0.043027094655_DP
+               c(5) =  1.413799186854_DP
+               c(6) =  6.092478129404_DP
+            ENDIF
+
+         CASE ('Be') ! #4
+            IF (ehub_l == 1) THEN
+               c(1) = -0.443498325954_DP
+               c(2) =  3.989114779566_DP
+               c(3) = -2.280629532463_DP
+               c(4) =  0.096702135622_DP
+               c(5) =  3.711306871584_DP
+               c(6) =  3.969540534991_DP
+            ENDIF
+
+         CASE ('B') ! #5
+            IF (ehub_l == 1) THEN
+               c(1) =  0.656355337018_DP
+               c(2) =  0.183034188458_DP
+               c(3) = -0.576077082062_DP
+               c(4) =  0.286973112733_DP
+               c(5) =  0.088758506937_DP
+               c(6) =  2.150083982021_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.044969613094_DP
+               c(2) =  0.372132346750_DP
+               c(3) =  1.040424593070_DP
+               c(4) =  0.069917443217_DP
+               c(5) =  0.297032797251_DP
+               c(6) =  1.434105216910_DP
+            ENDIF
+
+         CASE ('C') ! #6
+            IF (ehub_l == 1) THEN
+               c(1) =  0.911056695981_DP
+               c(2) =  0.249401643334_DP
+               c(3) = -0.833758569243_DP
+               c(4) =  0.444078795383_DP
+               c(5) =  0.134343072577_DP
+               c(6) =  3.524391812748_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.064917002859_DP
+               c(2) =  0.579676091998_DP
+               c(3) =  1.831155020004_DP
+               c(4) =  0.101865640094_DP
+               c(5) =  0.426724237955_DP
+               c(6) =  1.917952558108_DP
+            ENDIF
+
+         CASE ('N') ! #7
+            IF (ehub_l == 1) THEN
+               c(1) =  1.193345666376_DP
+               c(2) =  0.324822683145_DP
+               c(3) = -0.856749333765_DP
+               c(4) =  0.637653633348_DP
+               c(5) =  0.188688569529_DP
+               c(6) =  4.257461576337_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.075652564714_DP
+               c(2) =  0.720067960010_DP
+               c(3) =  2.672206131908_DP
+               c(4) =  0.129951237236_DP
+               c(5) =  0.522369234165_DP
+               c(6) =  2.168540476009_DP
+            ENDIF
+
+         CASE ('O') ! #8
+            IF (ehub_l == 1) THEN
+               c(1) =  0.373809278741_DP
+               c(2) = -0.610324418760_DP
+               c(3) =  1.464561789733_DP
+               c(4) =  0.243165825060_DP
+               c(5) =  4.673791891958_DP
+               c(6) =  0.822447989915_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.087598066875_DP
+               c(2) =  3.680042564303_DP
+               c(3) =  0.871731746608_DP
+               c(4) =  0.160367821619_DP
+               c(5) =  2.504313460020_DP
+               c(6) =  0.628010267834_DP
+            ENDIF
+
+         CASE ('F') ! #9
+            IF (ehub_l == 1) THEN
+               c(1) =  0.404630576044_DP
+               c(2) = -0.302335566424_DP
+               c(3) =  1.705342476241_DP
+               c(4) =  0.298101315546_DP
+               c(5) =  5.962916328850_DP
+               c(6) =  0.996675980766_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.081664858438_DP
+               c(2) =  4.390189333717_DP
+               c(3) =  0.850467631069_DP
+               c(4) =  0.179119107431_DP
+               c(5) =  2.481405176715_DP
+               c(6) =  0.659825985425_DP
+            ENDIF
+
+         CASE ('Ne') ! #10
+            IF (ehub_l == 1) THEN
+               c(1) =  0.455643227274_DP
+               c(2) = -0.101866294430_DP
+               c(3) =  1.969445485699_DP
+               c(4) =  0.363824829858_DP
+               c(5) = 12.050813114004_DP
+               c(6) =  1.213503317737_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.076039433482_DP
+               c(2) =  5.085594177529_DP
+               c(3) =  0.822153488538_DP
+               c(4) =  0.197552310841_DP
+               c(5) =  2.510564358263_DP
+               c(6) =  0.691877350263_DP
+            ENDIF
+
+         CASE ('Na') ! #11
+            IF (ehub_l == 1) THEN
+               c(1) = -0.227294992712_DP
+               c(2) =  3.072554770390_DP
+               c(3) = -2.342088186932_DP
+               c(4) =  0.039291178925_DP
+               c(5) =  1.338209815922_DP
+               c(6) =  1.424569625836_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.061756018287_DP
+               c(2) =  6.190460773345_DP
+               c(3) =  0.820469277502_DP
+               c(4) =  0.259585904994_DP
+               c(5) =  2.596766620565_DP
+               c(6) =  0.774050537209_DP
+            ENDIF
+
+         CASE ('Mg') ! #12
+            IF (ehub_l == 1) THEN
+               c(1) = -0.039740452192_DP
+               c(2) =  1.122713110955_DP
+               c(3) = -0.346572719176_DP
+               c(4) =  0.027705656166_DP
+               c(5) =  1.343552529113_DP
+               c(6) =  0.087143259622_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.661444445465_DP       
+               c(2) =  7.296815721995_DP       
+               c(3) =  0.019088633428_DP       
+               c(4) =  0.766843324359_DP
+               c(5) =  2.617442996388_DP
+               c(6) =  0.243245472137_DP
+            ENDIF
+
+         CASE ('Al') ! #13
+            IF (ehub_l == 1) THEN
+               c(1) =  0.500316411330_DP
+               c(2) =  0.147417937230_DP
+               c(3) = -0.544597421342_DP
+               c(4) =  0.181008583290_DP
+               c(5) =  0.062803792454_DP
+               c(6) =  0.810393089723_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.010010380536_DP
+               c(2) =  0.078080076910_DP
+               c(3) =  0.159867596509_DP
+               c(4) =  0.030511948768_DP
+               c(5) =  0.090164250255_DP
+               c(6) =  0.239496826308_DP
+            ENDIF
+
+         CASE ('Si') ! #14
+            IF (ehub_l == 1) THEN
+               c(1) =  0.653356494085_DP
+               c(2) =  0.181395093639_DP
+               c(3) = -0.739469728881_DP
+               c(4) =  0.247218789226_DP
+               c(5) =  0.086733995628_DP
+               c(6) =  1.105491059309_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.007971011397_DP
+               c(2) =  0.086867614229_DP
+               c(3) =  0.299971545416_DP
+               c(4) =  0.037379807962_DP
+               c(5) =  0.104244707920_DP
+               c(6) =  0.299477477724_DP
+            ENDIF
+ 
+         CASE ('P') ! #15
+            IF (ehub_l == 1) THEN
+               c(1) =  0.209623887990_DP
+               c(2) = -0.946507997553_DP
+               c(3) =  0.806689455268_DP
+               c(4) =  0.111399186790_DP
+               c(5) =  1.463741813603_DP
+               c(6) =  0.316081905463_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.008303473248_DP
+               c(2) =  0.455893148993_DP
+               c(3) =  0.114337376306_DP
+               c(4) =  0.046337546846_DP
+               c(5) =  0.390725157316_DP
+               c(6) =  0.132088379177_DP
+            ENDIF
+
+         CASE ('S') ! #16
+            IF (ehub_l == 1) THEN
+               c(1) =  0.250901929637_DP
+               c(2) = -1.163001827739_DP
+               c(3) =  0.972328200366_DP
+               c(4) =  0.140170258888_DP
+               c(5) =  1.796610185319_DP
+               c(6) =  0.400554817608_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.095216533639_DP
+               c(2) = -0.209399450160_DP
+               c(3) =  0.677722552783_DP
+               c(4) =  0.117583911615_DP
+               c(5) =  9.326319489236_DP
+               c(6) =  0.443859221287_DP
+            ENDIF
+
+         CASE ('Cl') ! #17
+            IF (ehub_l == 1) THEN
+               c(1) =  0.294962934487_DP
+               c(2) = -1.310069360650_DP
+               c(3) =  1.152644469963_DP
+               c(4) =  0.171352043891_DP
+               c(5) =  2.043531633075_DP
+               c(6) =  0.495343466401_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.123931656168_DP
+               c(2) = -0.304468863382_DP
+               c(3) =  0.905494955796_DP
+               c(4) =  0.146740779273_DP
+               c(5) = 10.255804232771_DP
+               c(6) =  0.555225704605_DP
+            ENDIF
+
+         CASE ('Ar') ! #18
+            IF (ehub_l == 1) THEN
+               c(1) =  0.322456176916_DP
+               c(2) = -1.520870419502_DP
+               c(3) =  1.312921303619_DP
+               c(4) =  0.201081097695_DP
+               c(5) =  2.505175912587_DP
+               c(6) =  0.581130094051_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.155622012451_DP
+               c(2) = -0.224475457820_DP
+               c(3) =  1.164350849513_DP
+               c(4) =  0.177963169478_DP
+               c(5) = 18.839963511142_DP
+               c(6) =  0.674604636165_DP
+            ENDIF
+
+         CASE ('K') ! #19
+            IF (ehub_l == 1) THEN
+               c(1) = -0.181242219750_DP
+               c(2) = -0.431390960285_DP
+               c(3) =  0.664602516792_DP
+               c(4) =  0.028118093627_DP
+               c(5) =  2.852442054404_DP
+               c(6) =  0.537678960374_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.225111791303_DP      
+               c(2) = -0.263985565680_DP       
+               c(3) =  1.567969539805_DP       
+               c(4) =  0.248990866741_DP      
+               c(5) = 16.165057705590_DP       
+               c(6) =  0.848949073063_DP
+            ENDIF
+
+         CASE ('Ca') ! #20
+            IF (ehub_l == 1) THEN
+               c(1) = -0.264799707770_DP
+               c(2) = -0.549308519142_DP
+               c(3) =  0.985820214448_DP
+               c(4) =  0.045289218650_DP
+               c(5) =  2.681103408865_DP
+               c(6) =  0.675703387316_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.028601134158_DP      
+               c(2) =  1.893770019936_DP       
+               c(3) =  0.484255007307_DP       
+               c(4) =  0.168384052384_DP       
+               c(5) =  1.148530532989_DP       
+               c(6) =  0.442104233139_DP
+            ENDIF
+
+         CASE ('Sc') ! #21
+            IF (ehub_l == 1) THEN
+               c(1) = -0.295213729380_DP
+               c(2) = -0.690486291363_DP
+               c(3) =  1.205940725185_DP
+               c(4) =  0.052568436621_DP
+               c(5) =  2.642302285256_DP
+               c(6) =  0.826758449461_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.030911394455_DP       
+               c(2) =  2.331421748738_DP       
+               c(3) =  0.575647369610_DP       
+               c(4) =  0.194775194057_DP       
+               c(5) =  1.333638659610_DP       
+               c(6) =  0.512252071382_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.016732792663_DP
+               c(2) =  3.513153315214_DP
+               c(3) =  0.332190984174_DP
+               c(4) =  0.101742137550_DP
+               c(5) =  1.849748970889_DP
+               c(6) =  0.442948288175_DP
+            ENDIF
+
+         CASE ('Ti') ! #22
+            IF (ehub_l == 1) THEN
+               c(1) = -0.318225769001_DP
+               c(2) = -0.969471620436_DP
+               c(3) =  1.618688664346_DP
+               c(4) =  0.058463938265_DP
+               c(5) =  2.161748341173_DP
+               c(6) =  1.022513391072_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.058797207764_DP      
+               c(2) =  2.714413575837_DP       
+               c(3) =  0.778846706639_DP       
+               c(4) =  0.256142741840_DP       
+               c(5) =  1.591339649343_DP       
+               c(6) =  0.643090411255_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.020642587473_DP
+               c(2) =  4.474677432323_DP
+               c(3) =  0.413865163811_DP
+               c(4) =  0.123682984416_DP
+               c(5) =  2.029434860117_DP
+               c(6) =  0.511373185245_DP
+            ENDIF
+
+         CASE ('V') ! #23
+            IF (ehub_l == 1) THEN
+               c(1) = -0.338218686383_DP
+               c(2) = -3.270998094612_DP
+               c(3) =  4.011726318349_DP
+               c(4) =  0.063803422756_DP
+               c(5) =  1.730322474662_DP
+               c(6) =  1.354487655362_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.092510583324_DP       
+               c(2) =  3.107892592685_DP       
+               c(3) =  1.033558703074_DP       
+               c(4) =  0.314725689731_DP       
+               c(5) =  1.882573795417_DP       
+               c(6) =  0.786857012502_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.022746191331_DP
+               c(2) =  5.288786537290_DP
+               c(3) =  0.460601013446_DP
+               c(4) =  0.140438031953_DP
+               c(5) =  2.136984327283_DP
+               c(6) =  0.557352443235_DP
+            ENDIF
+
+         CASE ('Cr') ! #24
+            IF (ehub_l == 1) THEN
+               c(1) = -0.315769402320_DP
+               c(2) = -1.168781746014_DP
+               c(3) =  1.726014803822_DP
+               c(4) =  0.059230565423_DP
+               c(5) =  3.034633462390_DP
+               c(6) =  1.324383725932_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.036288681890_DP       
+               c(2) =  3.836346100011_DP       
+               c(3) =  0.853660637750_DP       
+               c(4) =  0.256896201615_DP       
+               c(5) =  1.924914557193_DP       
+               c(6) =  0.710202001153_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.024115045897_DP
+               c(2) =  7.616668495423_DP
+               c(3) =  0.608657720967_DP
+               c(4) =  0.129613659718_DP
+               c(5) =  2.746444149346_DP
+               c(6) =  0.626994776055_DP
+            ENDIF
+
+         CASE ('Mn') ! #25
+            IF (ehub_l == 1) THEN
+               c(1) = -0.375311257000_DP
+               c(2) = -1.557535797738_DP
+               c(3) =  2.274052898015_DP
+               c(4) =  0.073924993623_DP
+               c(5) =  2.988799544966_DP
+               c(6) =  1.536640326823_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.087272783766_DP       
+               c(2) =  4.308091371200_DP       
+               c(3) =  1.203988232107_DP       
+               c(4) =  0.363157808632_DP       
+               c(5) =  2.278990728292_DP       
+               c(6) =  0.915032797516_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.044608437128_DP
+               c(2) = 10.302751443943_DP
+               c(3) =  0.959964258051_DP
+               c(4) =  0.202649964930_DP
+               c(5) =  3.205301023063_DP
+               c(6) =  0.829896544192_DP
+            ENDIF
+
+         CASE ('Fe') ! #26
+            IF (ehub_l == 1) THEN
+               c(1) = -0.392468695101_DP
+               c(2) =-17.378135958170_DP
+               c(3) = 18.260982645601_DP
+               c(4) =  0.078792169541_DP
+               c(5) =  2.176069451855_DP
+               c(6) =  2.050771177614_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.129709750427_DP       
+               c(2) =  4.808495209752_DP       
+               c(3) =  1.510085908714_DP       
+               c(4) =  0.431096943700_DP       
+               c(5) =  2.608090828403_DP       
+               c(6) =  1.078223159466_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.040860261745_DP
+               c(2) = 10.562034113832_DP
+               c(3) =  0.879915821284_DP
+               c(4) =  0.208392291280_DP
+               c(5) =  3.083305153715_DP
+               c(6) =  0.819649986507_DP
+            ENDIF
+
+         CASE ('Co') ! #27
+            IF (ehub_l == 1) THEN
+               c(1) = -0.409449796747_DP
+               c(2) =-24.327869994553_DP
+               c(3) = 25.276006463214_DP
+               c(4) =  0.083649892057_DP
+               c(5) =  2.360476030025_DP
+               c(6) =  2.260514857432_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.157884172648_DP       
+               c(2) =  5.412581502815_DP       
+               c(3) =  1.784719290248_DP       
+               c(4) =  0.483703429680_DP       
+               c(5) =  2.930363506712_DP       
+               c(6) =  1.216840978520_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.032756048270_DP
+               c(2) =  9.828446052105_DP
+               c(3) =  0.703720485735_DP
+               c(4) =  0.204488830736_DP
+               c(5) =  2.789560109164_DP
+               c(6) =  0.764033743706_DP
+            ENDIF
+
+         CASE ('Ni') ! #28
+            IF (ehub_l == 1) THEN
+               c(1) = -0.426112214801_DP
+               c(2) =-42.556963420485_DP
+               c(3) = 43.574099353067_DP
+               c(4) =  0.088491284687_DP
+               c(5) =  2.551600156264_DP
+               c(6) =  2.487659567652_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.130560912727_DP     
+               c(2) =  6.237805303170_DP       
+               c(3) =  1.687732950459_DP       
+               c(4) =  0.491888997437_DP       
+               c(5) =  3.023019784437_DP       
+               c(6) =  1.224915297875_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.031569431192_DP
+               c(2) = 10.445400530425_DP
+               c(3) =  0.685120158029_DP
+               c(4) =  0.212187259769_DP
+               c(5) =  2.811807499308_DP
+               c(6) =  0.776566016795_DP
+            ENDIF
+
+         CASE ('Cu') ! #29
+            IF (ehub_l == 1) THEN
+               c(1) = -0.388492555266_DP
+               c(2) =-61.349264143911_DP
+               c(3) = 62.333754166376_DP
+               c(4) =  0.079322877272_DP
+               c(5) =  2.750536834559_DP
+               c(6) =  2.706896773763_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.091774418632_DP       
+               c(2) =  7.006702592356_DP       
+               c(3) =  1.502676670774_DP       
+               c(4) =  0.465273233319_DP       
+               c(5) =  3.057801585522_DP       
+               c(6) =  1.184501570889_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.022099655591_DP
+               c(2) = 10.132546058353_DP
+               c(3) =  0.549819156845_DP
+               c(4) =  0.167306852284_DP
+               c(5) =  2.715745529473_DP
+               c(6) =  0.689815139893_DP
+           ENDIF
+
+         CASE ('Zn') ! #30
+            IF (ehub_l == 1) THEN
+               c(1) = -0.459123341504_DP
+               c(2) =-86.599379743686_DP
+               c(3) = 87.847510774798_DP
+               c(4) =  0.098245346612_DP
+               c(5) =  2.851352341989_DP
+               c(6) =  2.821152267040_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.001141144619_DP       
+               c(2) =  6.995902223435_DP       
+               c(3) =  0.531333702406_DP       
+               c(4) =  0.144004793512_DP       
+               c(5) =  2.372318439604_DP       
+               c(6) =  0.797655892405_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.015160623405_DP
+               c(2) =  8.200124694445_DP
+               c(3) =  0.355506538124_DP
+               c(4) =  0.186163476497_DP
+               c(5) =  2.238263617414_DP
+               c(6) =  0.621882507007_DP
+            ENDIF
+
+         CASE ('Ga') ! #31
+            IF (ehub_l == 1) THEN
+               c(1) = -0.570186309642_DP
+               c(2) = 36.708786061408_DP
+               c(3) =-35.227020873330_DP
+               c(4) =  0.129005025052_DP
+               c(5) =  3.050856014642_DP
+               c(6) =  3.151382129492_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.031688670008_DP
+               c(2) =  2.276553777312_DP
+               c(3) = -0.210165049050_DP
+               c(4) =  0.044927478174_DP
+               c(5) =  3.104458612517_DP
+               c(6) =  0.182213823985_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.036783722491_DP
+               c(2) = 14.406525679355_DP
+               c(3) =  0.805658337501_DP
+               c(4) =  0.296895814122_DP
+               c(5) =  3.187015692054_DP
+               c(6) =  0.938886749965_DP
+            ENDIF
+
+         CASE ('Ge') ! #32
+            IF (ehub_l == 1) THEN
+               c(1) = -0.679954859629_DP
+               c(2) = 89.595615555979_DP
+               c(3) =-87.826067526074_DP
+               c(4) =  0.160883208900_DP
+               c(5) =  3.315702845736_DP
+               c(6) =  3.363737098719_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.044449395647_DP
+               c(2) =  2.980657603487_DP
+               c(3) = -0.300334459481_DP
+               c(4) =  0.062275286221_DP
+               c(5) =  3.339614734480_DP
+               c(6) =  0.234700930422_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.029903663528_DP
+               c(2) = 16.411485116235_DP
+               c(3) =  0.818749390120_DP
+               c(4) =  0.331927575866_DP
+               c(5) =  3.335733370077_DP
+               c(6) =  0.997668602277_DP
+            ENDIF
+
+         CASE ('As') ! #33
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.790597588817_DP
+               c(2) = 188.779544833468_DP
+               c(3) =-186.721872365407_DP
+               c(4) =   0.194366296004_DP
+               c(5) =   3.604618738427_DP
+               c(6) =   3.631431235458_DP
+           ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.057788534305_DP
+               c(2) =  3.683715554837_DP
+               c(3) = -0.401726669733_DP
+               c(4) =  0.079756015416_DP
+               c(5) =  3.536349821653_DP
+               c(6) =  0.289490665665_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.002879273971_DP
+               c(2) = 14.592521467880_DP
+               c(3) =  0.424518304212_DP
+               c(4) =  0.203900518627_DP
+               c(5) =  2.923041942290_DP
+               c(6) =  0.808990267376_DP
+            ENDIF
+
+         CASE ('Se') ! #34
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.902464608635_DP
+               c(2) = 350.532816593843_DP
+               c(3) =-348.180108242355_DP
+               c(4) =   0.229494632770_DP
+               c(5) =   3.910947638028_DP
+               c(6) =   3.927758231384_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.072312096546_DP
+               c(2) =  4.436216555188_DP
+               c(3) = -0.515824939914_DP
+               c(4) =  0.097889622041_DP
+               c(5) =  3.757205546940_DP
+               c(6) =  0.347739135376_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.000196755787_DP
+               c(2) = 15.389778312548_DP
+               c(3) =  0.320909878286_DP
+               c(4) =  0.097502862437_DP
+               c(5) =  2.936617281628_DP
+               c(6) =  0.793707703748_DP
+            ENDIF
+
+         CASE ('Br') ! #35
+            IF (ehub_l == 1) THEN
+               c(1) =  0.297230125247_DP
+               c(2) =  1.129428561283_DP
+               c(3) = -1.380320944045_DP
+               c(4) =  0.159396801513_DP
+               c(5) =  0.447518267841_DP
+               c(6) =  1.504512029541_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.065511912377_DP
+               c(2) =  0.602775053733_DP
+               c(3) =  0.122984973198_DP
+               c(4) =  0.084245857273_DP
+               c(5) =  0.360068754225_DP
+               c(6) =  0.090519037773_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  4.593469256087_DP       
+               c(2) =  5.582984386442_DP       
+               c(3) =  0.039953514881_DP       
+               c(4) =  2.206669632524_DP       
+               c(5) =  2.206490256837_DP       
+               c(6) =  0.470079864283_DP
+            ENDIF
+
+         CASE ('Kr') ! #36
+            IF (ehub_l == 1) THEN
+               c(1) =  0.329362264882_DP
+               c(2) =  1.285527823837_DP
+               c(3) = -1.551605758559_DP
+               c(4) =  0.182665116564_DP
+               c(5) =  0.513892687203_DP
+               c(6) =  1.633894103966_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.006228593181_DP
+               c(2) =  0.723247889187_DP
+               c(3) =  0.057081866696_DP
+               c(4) =  0.112227311313_DP
+               c(5) =  0.408188227323_DP
+               c(6) =  0.112460661449_DP
+            ENDIF
+
+         CASE ('Rb') ! #37
+            IF (ehub_l == 1) THEN
+               c(1) = -0.173114313850_DP
+               c(2) = -0.486379260440_DP
+               c(3) =  0.707320378162_DP
+               c(4) =  0.026101261837_DP
+               c(5) =  1.661596504124_DP
+               c(6) =  0.455812470526_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.272209246631_DP       
+               c(2) =  0.938488495461_DP       
+               c(3) =  0.344579164880_DP       
+               c(4) =  0.114453576781_DP       
+               c(5) =  0.486972201410_DP       
+               c(6) =  0.119284466699_DP
+            ENDIF
+
+         CASE ('Sr') ! #38
+            IF (ehub_l == 1) THEN
+               c(1) = -0.245182735180_DP
+               c(2) = -0.695065618632_DP
+               c(3) =  0.976496200596_DP
+               c(4) =  0.040044511833_DP
+               c(5) =  1.915845291848_DP
+               c(6) =  0.535147345304_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.178534795404_DP      
+               c(2) = -0.986292752479_DP       
+               c(3) =  1.269883114765_DP       
+               c(4) =  0.227048943780_DP       
+               c(5) =  3.226621851080_DP       
+               c(6) =  0.671183607772_DP
+            ENDIF
+
+         CASE ('Y') ! #39
+            IF (ehub_l == 1) THEN
+               c(1) = -0.281663069200_DP
+               c(2) = -0.912434183564_DP
+               c(3) =  1.256997681467_DP
+               c(4) =  0.048024002200_DP
+               c(5) =  1.876435865512_DP
+               c(6) =  0.647183790718_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.048079462119_DP       
+               c(2) =  0.983535878535_DP       
+               c(3) =  0.373451843125_DP       
+               c(4) =  0.157795569425_DP       
+               c(5) =  0.594333269384_DP       
+               c(6) =  0.594385378398_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.006705969797_DP
+               c(2) =  0.721844261500_DP
+               c(3) =  0.109997277353_DP
+               c(4) =  0.061001386887_DP
+               c(5) =  0.833484412996_DP
+               c(6) =  0.228414569864_DP
+            ENDIF
+
+         CASE ('Zr') ! #40
+            IF (ehub_l == 1) THEN
+               c(1) = -0.306915848557_DP
+               c(2) = -1.180466644569_DP
+               c(3) =  1.579448406545_DP
+               c(4) =  0.054028807507_DP
+               c(5) =  1.836613284891_DP
+               c(6) =  0.769251324655_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.071262325265_DP       
+               c(2) =  1.223984911452_DP       
+               c(3) =  0.369642658796_DP       
+               c(4) =  0.199204737781_DP       
+               c(5) =  0.687426372356_DP       
+               c(6) =  0.687449567266_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.010007834189_DP
+               c(2) =  1.018006284314_DP
+               c(3) =  0.169573298259_DP
+               c(4) =  0.081000463005_DP
+               c(5) =  0.997113564610_DP
+               c(6) =  0.292835802852_DP
+            ENDIF
+
+         CASE ('Nb') ! #41
+            IF (ehub_l == 1) THEN
+               c(1) = -0.296167364999_DP
+               c(2) = -1.562315637674_DP
+               c(3) =  1.951361088833_DP
+               c(4) =  0.052618886583_DP
+               c(5) =  1.781811087408_DP
+               c(6) =  0.915123959111_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.054895010580_DP       
+               c(2) =  1.421020327022_DP       
+               c(3) =  0.360220145719_DP       
+               c(4) =  0.189265877614_DP       
+               c(5) =  0.730973013752_DP       
+               c(6) =  0.730904100341_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.010014869511_DP
+               c(2) =  1.259192220484_DP
+               c(3) =  0.192202984088_DP
+               c(4) =  0.080908290272_DP
+               c(5) =  1.104568384592_DP
+               c(6) =  0.313989745519_DP
+            ENDIF
+
+         CASE ('Mo') ! #42
+            IF (ehub_l == 1) THEN
+               c(1) = -0.310098928911_DP
+               c(2) = -2.144842503362_DP
+               c(3) =  2.554006089572_DP
+               c(4) =  0.056245404942_DP
+               c(5) =  1.792570868516_DP
+               c(6) =  1.067324564389_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.081366064644_DP       
+               c(2) =  1.717024445546_DP       
+               c(3) =  0.323191088977_DP       
+               c(4) =  0.234353244849_DP       
+               c(5) =  0.829387759124_DP       
+               c(6) =  0.829230013347_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.013026527996_DP
+               c(2) =  1.622771153459_DP
+               c(3) =  0.255583498983_DP
+               c(4) =  0.097196255581_DP
+               c(5) =  1.261210564254_DP
+               c(6) =  0.370390046407_DP
+            ENDIF
+
+         CASE ('Tc') ! #43
+            IF (ehub_l == 1) THEN
+               c(1) = -0.359036462534_DP
+               c(2) = -2.861970342655_DP
+               c(3) =  3.348513527568_DP
+               c(4) =  0.067650607005_DP
+               c(5) =  1.868574601889_DP
+               c(6) =  1.207931541213_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.412979482345_DP       
+               c(2) =  2.338657881695_DP       
+               c(3) =  0.484071668922_DP       
+               c(4) =  0.165530330820_DP       
+               c(5) =  0.909515973693_DP       
+               c(6) =  0.173437056364_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.021887598099_DP
+               c(2) =  2.153612067273_DP
+               c(3) =  0.397166052347_DP
+               c(4) =  0.138105103711_DP
+               c(5) =  1.489072441324_DP
+               c(6) =  0.478025337010_DP
+            ENDIF
+
+         CASE ('Ru') ! #44
+            IF (ehub_l == 1) THEN
+               c(1) = -0.333108901587_DP
+               c(2) =-21.679961363224_DP
+               c(3) = 22.145957846106_DP
+               c(4) =  0.062497158490_DP
+               c(5) =  1.638753376796_DP
+               c(6) =  1.546546668195_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.383753056855_DP       
+               c(2) =  2.596147429254_DP       
+               c(3) =  0.489335802963_DP       
+               c(4) =  0.204654205142_DP       
+               c(5) =  1.010595017786_DP       
+               c(6) =  0.217967028720_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.019900789131_DP
+               c(2) =  2.494626479803_DP
+               c(3) =  0.403387663667_DP
+               c(4) =  0.130075556667_DP
+               c(5) =  1.579393879933_DP
+               c(6) =  0.483574255384_DP
+            ENDIF
+
+         CASE ('Rh') ! #45
+            IF (ehub_l == 1) THEN
+               c(1) = -0.343283879013_DP
+               c(2) =-35.171708684278_DP
+               c(3) = 35.671811103368_DP
+               c(4) =  0.065320889732_DP
+               c(5) =  1.752328144129_DP
+               c(6) =  1.689302769802_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.391841129793_DP       
+               c(2) =  2.888378661674_DP       
+               c(3) =  0.520466989948_DP       
+               c(4) =  0.234087747468_DP       
+               c(5) =  1.108532031212_DP       
+               c(6) =  0.251028676292_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.023741706971_DP
+               c(2) =  3.009421136835_DP
+               c(3) =  0.487359144666_DP
+               c(4) =  0.146736912823_DP
+               c(5) =  1.741209130665_DP
+               c(6) =  0.540625824305_DP
+            ENDIF
+
+         CASE ('Pd') ! #46
+            IF (ehub_l == 3) THEN
+               c(1) =  0.018693496588_DP
+               c(2) =  3.315302075266_DP
+               c(3) =  0.435843667482_DP
+               c(4) =  0.129153130578_DP
+               c(5) =  1.752925240852_DP
+               c(6) =  0.514896004522_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.249856923907_DP       
+               c(2) =  3.162666165646_DP       
+               c(3) =  0.526065324812_DP       
+               c(4) =  0.367927215234_DP       
+               c(5) =  1.284305267582_DP       
+               c(6) =  0.401699344495_DP
+            ENDIF
+
+         CASE ('Ag') ! #47
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.361667650935_DP
+               c(2) =-163.975414647460_DP
+               c(3) = 164.562761749415_DP
+               c(4) =   0.070546264580_DP
+               c(5) =   1.990328961350_DP
+               c(6) =   1.974370570869_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.000285357274_DP   
+               c(2) =  3.475553163345_DP       
+               c(3) =  0.371062643905_DP       
+               c(4) =  0.061971403344_DP       
+               c(5) =  1.421889145466_DP       
+               c(6) =  0.519003534581_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.027494570158_DP
+               c(2) =  4.005167285803_DP
+               c(3) =  0.578648802024_DP
+               c(4) =  0.171987943364_DP
+               c(5) =  1.934330309129_DP
+               c(6) =  0.613690621507_DP
+            ENDIF
+
+         CASE ('Cd') ! #48
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.421224422443_DP
+               c(2) =-165.123871270089_DP
+               c(3) = 165.682635362663_DP
+               c(4) =   0.085435466592_DP
+               c(5) =   2.186390953591_DP
+               c(6) =   2.164724253301_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.490750124993_DP       
+               c(2) =  3.820547602402_DP       
+               c(3) =  0.587004069994_DP       
+               c(4) =  0.227240917552_DP       
+               c(5) =  1.330726974120_DP       
+               c(6) =  0.240170540409_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.049166501796_DP
+               c(2) =  5.133816774912_DP
+               c(3) =  0.951488891419_DP
+               c(4) =  0.235590703865_DP
+               c(5) =  2.364228213369_DP
+               c(6) =  0.796166445200_DP
+            ENDIF
+
+         CASE ('In') ! #49
+            IF (ehub_l == 1) THEN
+               c(1) = -0.511981033888_DP
+               c(2) = 85.716590637197_DP
+               c(3) =-84.752845581471_DP
+               c(4) =  0.108379157178_DP
+               c(5) =  2.172569042173_DP
+               c(6) =  2.211816156015_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.024425647593_DP
+               c(2) =  1.354588511411_DP
+               c(3) = -0.159468544301_DP
+               c(4) =  0.038333393636_DP
+               c(5) =  1.685434711803_DP
+               c(6) =  0.141669087548_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.039997161800_DP
+               c(2) =  5.288104937993_DP
+               c(3) =  0.752958553278_DP
+               c(4) =  0.256909244031_DP
+               c(5) =  2.118948320873_DP
+               c(6) =  0.758264911027_DP
+            ENDIF
+
+         CASE ('Sn') ! #50
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.598885277255_DP
+               c(2) = 146.218396730025_DP
+               c(3) =-145.172029182004_DP
+               c(4) =   0.131220816998_DP
+               c(5) =   2.365912226558_DP
+               c(6) =   2.395825128252_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.032562966995_DP
+               c(2) =  1.696102523830_DP
+               c(3) = -0.218242401613_DP
+               c(4) =  0.051101833684_DP
+               c(5) =  1.779168649454_DP
+               c(6) =  0.175922953262_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.064054942793_DP
+               c(2) =  6.662885074756_DP
+               c(3) =  1.146027057383_DP
+               c(4) =  0.328587975028_DP
+               c(5) =  2.519814727698_DP
+               c(6) =  0.938628671517_DP
+            ENDIF
+
+         CASE ('Sb') ! #51
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.685849757456_DP
+               c(2) = 455.802654604601_DP
+               c(3) =-454.559098502503_DP
+               c(4) =   0.154733192529_DP
+               c(5) =   2.526656650711_DP
+               c(6) =   2.537588223637_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.040543652476_DP
+               c(2) =  2.075571497628_DP
+               c(3) = -0.281498464561_DP
+               c(4) =  0.063462901123_DP
+               c(5) =  1.915475656066_DP
+               c(6) =  0.210212255764_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.070825934123_DP
+               c(2) =  7.626822260177_DP
+               c(3) =  1.263906754873_DP
+               c(4) =  0.375413726081_DP
+               c(5) =  2.643433065239_DP
+               c(6) =  1.017572782226_DP
+            ENDIF
+
+         CASE ('Te') ! #52
+            IF (ehub_l == 1) THEN
+               c(1) =   -0.773410347266_DP
+               c(2) = 1466.642316101258_DP
+               c(3) =-1465.176960128878_DP
+               c(4) =    0.179032494168_DP
+               c(5) =    2.679800262243_DP
+               c(6) =    2.683555508207_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.048790950482_DP
+               c(2) =  2.481211727143_DP
+               c(3) = -0.350117034596_DP
+               c(4) =  0.075853226895_DP
+               c(5) =  2.068097528403_DP
+               c(6) =  0.245478852065_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.068148010985_DP
+               c(2) =  8.599662889658_DP
+               c(3) =  1.277786102590_DP
+               c(4) =  0.410730105021_DP
+               c(5) =  2.712068246323_DP
+               c(6) =  1.062732286092_DP
+            ENDIF
+
+         CASE ('I') ! #53
+            IF (ehub_l == 1) THEN
+               c(1) =  0.342184210130_DP
+               c(2) = 19.939029995101_DP
+               c(3) =-20.215068744468_DP
+               c(4) =  0.137894783239_DP
+               c(5) =  0.554319110152_DP
+               c(6) =  0.581259186178_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.058730420781_DP
+               c(2) =  0.430634041187_DP
+               c(3) = -0.384817417194_DP
+               c(4) =  0.089085128012_DP
+               c(5) =  0.285140098083_DP
+               c(6) =  1.383553007501_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.001511142722_DP       
+               c(2) =  7.270120532702_DP       
+               c(3) =  0.361166497447_DP       
+               c(4) =  0.177834559985_DP       
+               c(5) =  2.025164020767_DP       
+               c(6) =  0.685892285680_DP
+            ENDIF
+
+         CASE ('Xe') ! #54
+            IF (ehub_l == 1) THEN
+               c(1) =  0.389586991356_DP
+               c(2) = 22.839804900433_DP
+               c(3) =-23.171222884795_DP
+               c(4) =  0.158307098341_DP
+               c(5) =  0.622125022057_DP
+               c(6) =  0.650565171739_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.068158756951_DP
+               c(2) =  0.511687662127_DP
+               c(3) = -0.502827480805_DP
+               c(4) =  0.102104498502_DP
+               c(5) =  0.323289314678_DP
+               c(6) =  1.551991061531_DP
+            ENDIF
+
+         CASE ('Cs') ! #55
+            IF (ehub_l == 1) THEN
+               c(1) = -0.159441865895_DP
+               c(2) = -0.538431303851_DP
+               c(3) =  0.737484184873_DP
+               c(4) =  0.022881342745_DP
+               c(5) =  0.958455483730_DP
+               c(6) =  0.351569924272_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.089886240512_DP      
+               c(2) = -0.706011648508_DP       
+               c(3) =  0.661415775836_DP       
+               c(4) =  0.132512948893_DP       
+               c(5) =  1.624566967936_DP       
+               c(6) =  0.386088461934_DP
+            ENDIF
+
+         CASE ('Ba') ! #56
+            IF (ehub_l == 1) THEN
+               c(1) = -0.221961619711_DP
+               c(2) = -0.736286740071_DP
+               c(3) =  0.967720799318_DP
+               c(4) =  0.034010036254_DP
+               c(5) =  1.143494015144_DP
+               c(6) =  0.399030087941_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.113889298024_DP      
+               c(2) = -0.921436196061_DP       
+               c(3) =  0.828614567461_DP       
+               c(4) =  0.163302303210_DP       
+               c(5) =  1.713755839951_DP       
+               c(6) =  0.452245675596_DP
+            ENDIF
+        
+         CASE ('La') ! #57
+            IF (ehub_l == 1) THEN
+               c(1) = -0.251222223831_DP      
+               c(2) = -1.048948585892_DP       
+               c(3) =  1.342382709744_DP       
+               c(4) =  0.039999785879_DP       
+               c(5) =  1.066911361907_DP       
+               c(6) =  0.486260112092_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.139654236432_DP      
+               c(2) = -1.039523419487_DP       
+               c(3) =  0.996472268198_DP       
+               c(4) =  0.190767302430_DP       
+               c(5) =  1.725662115013_DP       
+               c(6) =  0.517408819401_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.003049549808_DP       
+               c(2) =  0.278942303216_DP       
+               c(3) =  0.048133472215_DP       
+               c(4) =  0.047698974715_DP       
+               c(5) =  0.444604335063_DP       
+               c(6) =  0.146505792174_DP
+            ENDIF
+        
+         CASE ('Lu') ! #71
+            IF (ehub_l == 1) THEN
+               c(1) = -0.316067241819_DP    
+               c(2) = -1.368694018722_DP       
+               c(3) =  1.756460260859_DP       
+               c(4) =  0.056407605376_DP       
+               c(5) =  1.863914161455_DP       
+               c(6) =  0.848998800406_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.238005161969_DP       
+               c(2) = -1.226113155076_DP       
+               c(3) =  1.778525736620_DP       
+               c(4) =  0.297170380648_DP       
+               c(5) =  3.011077420178_DP       
+               c(6) =  0.845301673574_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.004135801299_DP       
+               c(2) =  0.565700114374_DP       
+               c(3) =  0.074065126628_DP       
+               c(4) =  0.047410426298_DP       
+               c(5) =  0.694976557361_DP       
+               c(6) =  0.182927648089_DP
+            ELSEIF (ehub_l == 4) THEN
+               c(1) =  0.001112187822_DP     
+               c(2) = 14.384944095177_DP       
+               c(3) =  0.134325103703_DP       
+               c(4) =  0.161565607831_DP       
+               c(5) =  2.522064385161_DP       
+               c(6) =  0.633776856552_DP
+            ENDIF
+
+         CASE ('Hf') ! #72
+            IF (ehub_l == 1) THEN
+               c(1) = -0.345098512122_DP
+               c(2) = -2.109918375272_DP
+               c(3) =  2.580349252556_DP
+               c(4) =  0.063202398107_DP
+               c(5) =  1.679777181703_DP
+               c(6) =  0.990740938243_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.046382253180_DP       
+               c(2) =  1.183784644114_DP       
+               c(3) =  0.486546318220_DP       
+               c(4) =  0.179419216657_DP       
+               c(5) =  0.688496932126_DP       
+               c(6) =  0.688634094775_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.006004945673_DP
+               c(2) =  0.739764778367_DP
+               c(3) =  0.107774832627_DP
+               c(4) =  0.063041434628_DP
+               c(5) =  0.792180180590_DP
+               c(6) =  0.228312005724_DP
+            ELSEIF (ehub_l == 4) THEN
+               c(1) =  0.003395223701_DP      
+               c(2) = 26.475093114189_DP       
+               c(3) =  0.344965368802_DP       
+               c(4) =  0.252752198600_DP       
+               c(5) =  3.347291139348_DP       
+               c(6) =  0.909526809179_DP
+            ENDIF
+
+         CASE ('Ta') ! #73
+            IF (ehub_l == 1) THEN
+               c(1) = -0.370724587294_DP
+               c(2) =-23.213618116462_DP
+               c(3) = 24.090262006129_DP
+               c(4) =  0.069306665279_DP
+               c(5) =  1.163677511230_DP
+               c(6) =  1.130879163408_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.000038243446_DP       
+               c(2) =  1.853473923647_DP       
+               c(3) =  0.186351499313_DP       
+               c(4) =  0.020690797887_DP       
+               c(5) =  0.848746798169_DP       
+               c(6) =  0.312175152490_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.008032248242_DP
+               c(2) =  0.926368338393_DP
+               c(3) =  0.145637753751_DP
+               c(4) =  0.077881948707_DP
+               c(5) =  0.891868413250_DP
+               c(6) =  0.272239389632_DP
+            ENDIF
+
+         CASE ('W') ! #74
+            IF (ehub_l == 1) THEN
+               c(1) = -0.390498159940_DP
+               c(2) =-38.649655937890_DP
+               c(3) = 39.266798820537_DP
+               c(4) =  0.074536546045_DP
+               c(5) =  1.439996529344_DP
+               c(6) =  1.393983485600_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.063037660674_DP       
+               c(2) =  1.508885826125_DP       
+               c(3) =  0.495374051028_DP       
+               c(4) =  0.225248283737_DP       
+               c(5) =  0.800999727038_DP       
+               c(6) =  0.801032150074_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.009708927624_DP
+               c(2) =  1.108159193204_DP
+               c(3) =  0.178760799769_DP
+               c(4) =  0.090931525658_DP
+               c(5) =  0.969940676042_DP
+               c(6) =  0.308608520742_DP
+            ENDIF
+
+         CASE ('Re') ! #75
+            IF (ehub_l == 1) THEN
+               c(1) = -0.409547819517_DP
+               c(2) =-53.000282776526_DP
+               c(3) = 53.662747606480_DP
+               c(4) =  0.079544343973_DP
+               c(5) =  1.541231964797_DP
+               c(6) =  1.503346048841_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.081444078315_DP       
+               c(2) =  1.689652226047_DP       
+               c(3) =  0.498732623225_DP       
+               c(4) =  0.260134135659_DP       
+               c(5) =  0.868137975666_DP       
+               c(6) =  0.868412658626_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.011652287278_DP
+               c(2) =  1.311391285293_DP
+               c(3) =  0.217278265396_DP
+               c(4) =  0.104256923131_DP
+               c(5) =  1.056865038009_DP
+               c(6) =  0.346901779835_DP
+            ENDIF
+
+         CASE ('Os') ! #76
+            IF (ehub_l == 1) THEN
+               c(1) = -0.426715773479_DP
+               c(2) =-70.788115346835_DP
+               c(3) = 71.379627317830_DP
+               c(4) =  0.084234787737_DP
+               c(5) =  1.686050558167_DP
+               c(6) =  1.650265522132_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.063416879973_DP       
+               c(2) =  1.869132992060_DP       
+               c(3) =  0.486101896533_DP       
+               c(4) =  0.248459910009_DP       
+               c(5) =  0.901985589525_DP       
+               c(6) =  0.902136234467_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.013279041155_DP
+               c(2) =  1.518970979702_DP
+               c(3) =  0.251283554510_DP
+               c(4) =  0.116424709223_DP
+               c(5) =  1.131287633222_DP
+               c(6) =  0.380282876144_DP
+            ENDIF
+
+         CASE ('Ir') ! #77
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.443229097307_DP
+               c(2) =-167.335084341934_DP
+               c(3) = 168.059751341307_DP
+               c(4) =   0.088787518632_DP
+               c(5) =   1.752814551413_DP
+               c(6) =   1.737649450709_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.119437350282_DP       
+               c(2) =  2.093029118377_DP       
+               c(3) =  0.478126896403_DP       
+               c(4) =  0.326283754776_DP       
+               c(5) =  1.002927255960_DP       
+               c(6) =  1.002669155610_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.015242326251_DP
+               c(2) =  1.752275275473_DP
+               c(3) =  0.291708341122_DP
+               c(4) =  0.129205970564_DP
+               c(5) =  1.215718486288_DP
+               c(6) =  0.416564537621_DP
+            ENDIF
+
+         CASE ('Pt') ! #78
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.424738360967_DP
+               c(2) =-263.411944303290_DP
+               c(3) = 263.959337731527_DP
+               c(4) =   0.085171912645_DP
+               c(5) =   1.928870761357_DP
+               c(6) =   1.916895432516_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.051210892460_DP       
+               c(2) =  2.229450427216_DP       
+               c(3) =  0.464005388131_DP       
+               c(4) =  0.244360806685_DP       
+               c(5) =  0.987677007491_DP       
+               c(6) =  0.987714421070_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.014646508749_DP
+               c(2) =  1.924683600926_DP
+               c(3) =  0.297221109153_DP
+               c(4) =  0.125138570909_DP
+               c(5) =  1.267113576090_DP
+               c(6) =  0.422483977869_DP
+            ENDIF
+
+         CASE ('Au') ! #79
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.437565960679_DP
+               c(2) =-308.394681084705_DP
+               c(3) = 309.024085534359_DP
+               c(4) =   0.088837340161_DP
+               c(5) =   2.028566184075_DP
+               c(6) =   2.017897339028_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.400122615019_DP       
+               c(2) =  2.979763910892_DP       
+               c(3) =  0.523481313987_DP       
+               c(4) =  0.256540792819_DP       
+               c(5) =  1.122273889273_DP       
+               c(6) =  0.273323141729_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.017510938405_DP
+               c(2) =  2.219387467626_DP
+               c(3) =  0.356850928536_DP
+               c(4) =  0.139309859200_DP
+               c(5) =  1.381119932590_DP
+               c(6) =  0.467970535370_DP
+            ENDIF
+
+         CASE ('Hg') ! #80
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.487408189976_DP
+               c(2) =-395.478949762781_DP
+               c(3) = 396.130430449862_DP
+               c(4) =   0.101593186473_DP
+               c(5) =   2.166610634381_DP
+               c(6) =   2.156544563593_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.085626843880_DP       
+               c(2) =  1.784475733432_DP       
+               c(3) =  1.381938658997_DP       
+               c(4) =  0.326203567672_DP       
+               c(5) =  1.141227944219_DP       
+               c(6) =  1.141485880523_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.021494444658_DP
+               c(2) =  2.560816756226_DP
+               c(3) =  0.423591635348_DP
+               c(4) =  0.167294527032_DP
+               c(5) =  1.472075536053_DP
+               c(6) =  0.524364248504_DP
+            ENDIF
+
+         CASE ('Tl') ! #81
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.574539775311_DP
+               c(2) = 157.207726940166_DP
+               c(3) =-156.371031838272_DP
+               c(4) =   0.123607406475_DP
+               c(5) =   2.224765691806_DP
+               c(6) =   2.253110251721_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.023192926592_DP
+               c(2) =  1.148945998718_DP
+               c(3) = -0.152485694405_DP
+               c(4) =  0.036410484838_DP
+               c(5) =  1.378034783130_DP
+               c(6) =  0.136435505495_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.029126786568_DP
+               c(2) =  2.967519397528_DP
+               c(3) =  0.540508754049_DP
+               c(4) =  0.209097445924_DP
+               c(5) =  1.602713184800_DP
+               c(6) =  0.606606331303_DP
+            ENDIF
+
+         CASE ('Pb') ! #82
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.658623967207_DP
+               c(2) = 444.653108689615_DP
+               c(3) =-443.634660230533_DP
+               c(4) =   0.145353778437_DP
+               c(5) =   2.328520473633_DP
+               c(6) =   2.339612664195_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.030737992553_DP
+               c(2) =  1.426594106245_DP
+               c(3) = -0.203565271657_DP
+               c(4) =  0.048190133489_DP
+               c(5) =  1.448008255391_DP
+               c(6) =  0.166174600300_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.036662887671_DP
+               c(2) =  3.404757836726_DP
+               c(3) =  0.660175651487_DP
+               c(4) =  0.249054129612_DP
+               c(5) =  1.728306574617_DP
+               c(6) =  0.684736576905_DP
+            ENDIF
+
+         CASE ('Bi') ! #83
+            IF (ehub_l == 1) THEN
+               c(1) =  -0.742801164457_DP
+               c(2) = 943.042667164432_DP
+               c(3) =-941.834855963301_DP
+               c(4) =   0.167544846670_DP
+               c(5) =   2.432483868729_DP
+               c(6) =   2.438211627337_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) = -0.037944065661_DP
+               c(2) =  1.708619194405_DP
+               c(3) = -0.257329475026_DP
+               c(4) =  0.059322071622_DP
+               c(5) =  1.532521076189_DP
+               c(6) =  0.195216386616_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.044146699478_DP
+               c(2) =  3.876241158861_DP
+               c(3) =  0.782608917564_DP
+               c(4) =  0.288315141954_DP
+               c(5) =  1.851161549689_DP
+               c(6) =  0.760242314862_DP
+            ENDIF
+
+         CASE ('Po') ! #84
+            IF (ehub_l == 1) THEN
+               c(1) =  106.041806916171_DP    
+               c(2) = -104.637247337300_DP      
+               c(3) =   -0.828031749719_DP       
+               c(4) =    2.512581746420_DP       
+               c(5) =    2.568203681800_DP       
+               c(6) =    0.190385951094_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  80.418251583782_DP     
+               c(2) = -79.266969964092_DP      
+               c(3) =  -0.251576729377_DP       
+               c(4) =   3.089922352775_DP       
+               c(5) =   3.163341509351_DP       
+               c(6) =   0.141197886233_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.051204429072_DP       
+               c(2) =  4.384618307424_DP       
+               c(3) =  0.904842542969_DP       
+               c(4) =  0.326700244235_DP       
+               c(5) =  1.970697456465_DP       
+               c(6) =  0.832830434516_DP
+            ENDIF
+
+         CASE ('Rn') ! #86
+            IF (ehub_l == 1) THEN
+               c(1) =   0.993698064532_DP      
+               c(2) =  28.586370352909_DP     
+               c(3) = -29.265015749277_DP       
+               c(4) =   0.236885702336_DP       
+               c(5) =   1.922949722512_DP       
+               c(6) =   1.881255646461_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  79.913306263149_DP     
+               c(2) = -79.771744330173_DP       
+               c(3) =   0.351371218668_DP       
+               c(4) =   4.632776390712_DP       
+               c(5) =   4.592332310942_DP       
+               c(6) =   0.183753778535_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  82.542839802866_DP     
+               c(2) = -77.142210955045_DP       
+               c(3) =   0.397438655240_DP       
+               c(4) =   1.797167872964_DP       
+               c(5) =   1.797165445116_DP       
+               c(6) =   0.619540838416_DP
+            ENDIF
+
+         CASE ('Pb5Bi5') ! #82.5
+            IF (ehub_l == 1) THEN
+               c(1) =   0.182638953900_DP
+               c(2) =-364.790521917688_DP
+               c(3) = 364.949512203615_DP
+               c(4) =   0.109604608737_DP
+               c(5) =   4.863139879782_DP
+               c(6) =   4.868981076531_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.032776295941_DP
+               c(2) = -0.248930280734_DP
+               c(3) =  0.227568543730_DP
+               c(4) =  0.052514446701_DP
+               c(5) =  1.082705860866_DP
+               c(6) =  0.178300719857_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.032776124966_DP
+               c(2) =  0.227580476360_DP
+               c(3) = -0.248806593903_DP
+               c(4) =  0.052514383289_DP
+               c(5) =  0.178304367292_DP
+               c(6) =  1.082332268584_DP
+            ENDIF
+
+         CASE ('Pb4Bi6') ! #82.6
+            IF (ehub_l == 1) THEN
+               c(1) =   0.056648245166_DP
+               c(2) =-301.468601097052_DP
+               c(3) = 301.540702990076_DP
+               c(4) =   0.064792654043_DP
+               c(5) =   0.327709902556_DP
+               c(6) =   0.327488364134_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.033462441809_DP
+               c(2) = -0.256723757839_DP
+               c(3) =  0.232977924671_DP
+               c(4) =  0.053620914031_DP
+               c(5) =  1.088782994108_DP
+               c(6) =  0.181166698272_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.033463842847_DP
+               c(2) =  0.232977347444_DP
+               c(3) = -0.256736189347_DP
+               c(4) =  0.053621812590_DP
+               c(5) =  0.181168546423_DP
+               c(6) =  1.088821795190_DP
+            ENDIF
+
+         CASE ('Pb2Bi8') ! #82.8
+            IF (ehub_l == 1) THEN
+               c(1) =   0.060428977071_DP
+               c(2) =-309.432045886787_DP
+               c(3) = 309.499014299818_DP
+               c(4) =   0.068064688556_DP
+               c(5) =   0.341245625856_DP
+               c(6) =   0.341005268685_DP
+            ELSEIF (ehub_l == 2) THEN
+               c(1) =  0.035071997891_DP
+               c(2) = -0.272870635991_DP
+               c(3) =  0.244074167363_DP
+               c(4) =  0.056061926550_DP
+               c(5) =  1.097994289528_DP
+               c(6) =  0.187082689188_DP
+            ELSEIF (ehub_l == 3) THEN
+               c(1) =  0.035072020088_DP
+               c(2) =  0.244074329940_DP
+               c(3) = -0.272869700667_DP
+               c(4) =  0.056061937235_DP
+               c(5) =  0.187082774713_DP
+               c(6) =  1.097989661259_DP
+            ENDIF
+
+         CASE DEFAULT
+            c = 0.0_DP
+
+      END SELECT
+      !
+      IF(all( ABS(c) < 1.D-10,1)) CALL errore('pao_3g', 'the coefficients and exponents does not exist.', 1)
+      !
+END SUBROUTINE pao_3g
diff --git a/PW/src/plus_u_full.f90 b/PW/src/plus_u_full.f90
index e339738db..ba38c8510 100644
--- a/PW/src/plus_u_full.f90
+++ b/PW/src/plus_u_full.f90
@@ -263,7 +263,7 @@ SUBROUTINE comp_dspinldau()
    DO isym = 1, nsym  
       !        
       CALL find_u( sr(1,1,isym), d_spin_ldau(1,1,isym) )  
-      !        
+      !       
       ! ... if time-reversal:  d_spin_ldau --> i sigma_y d_spin_ldau^*         
       !              
       IF (t_rev(isym)==1) THEN        
diff --git a/PW/src/plus_v_nc_v.f90 b/PW/src/plus_v_nc_v.f90
new file mode 100644
index 000000000..6e4d539cf
--- /dev/null
+++ b/PW/src/plus_v_nc_v.f90
@@ -0,0 +1,469 @@
+! WIY
+!
+!-----------------------------------------------------------------------
+SUBROUTINE comp_dspinldav() 
+  !---------------------------------------------------------------------
+  !! Initializes the spin rotation matrix for each symmetry operation.
+  !! It is needed when symmetrizing the occupation matrix with
+  !! noncollinear case.
+  !! Based on 'comp_dspinldau' in 'plus_u_full.f90'  
+  !
+  USE kinds,     ONLY : DP
+  USE ldaV,      ONLY : d_spin_ldav
+  USE symm_base, ONLY : nsym, sr, t_rev, sname
+  !
+  IMPLICIT NONE
+  !
+  ! ... local variables
+  !
+  COMPLEX(DP) :: a, b
+  INTEGER     :: isym
+  INTEGER     :: is1, is2
+  REAL(DP), PARAMETER    :: eps=1e-6_DP
+  !
+  d_spin_ldav = 0.0_DP
+  !  
+  DO isym = 1, nsym  
+     !        
+     CALL find_u( sr(1,1,isym), d_spin_ldav(1,1,isym) )  
+     !       
+     ! ... if time-reversal:  d_spin_ldau --> i sigma_y d_spin_ldau^*         
+     !
+     DO is1 = 1, 2
+     DO is2 = 1, 2
+       IF( ABS(d_spin_ldav(is1,is2,isym)**2) < eps) d_spin_ldav(is1,is2,isym) = 0.0_DP
+     ENDDO
+     ENDDO
+     !
+     IF (t_rev(isym)==1) THEN        
+       a = CONJG( d_spin_ldav(1,1,isym) )        
+       b = CONJG( d_spin_ldav(1,2,isym) )        
+       d_spin_ldav(1,1,isym) = CONJG( d_spin_ldav(2,1,isym) )        
+       d_spin_ldav(1,2,isym) = CONJG( d_spin_ldav(2,2,isym) )        
+       d_spin_ldav(2,1,isym) = -a        
+       d_spin_ldav(2,2,isym) = -b        
+     ENDIF         
+     !  
+  ENDDO 
+  !  
+  RETURN
+  !
+END SUBROUTINE comp_dspinldav   
+!
+!-----------------------------------------------------------------------
+SUBROUTINE atomic_wfc_v_nc( ik, wfcatom )
+  !---------------------------------------------------------------------
+  !! For noncollinear case: builds up the superposition (for a k-point 
+  !! \(\text{ik}\)) of pure spin-up or spin-down atomic wavefunctions.
+  !! Refer to atomic_wfc.f90
+  !
+  USE kinds,            ONLY : DP
+  USE constants,        ONLY : tpi, fpi, pi
+  USE cell_base,        ONLY : omega, tpiba
+  USE ions_base,        ONLY : nat, ntyp => nsp, ityp, tau
+  USE basis,            ONLY : natomwfc
+  USE gvect,            ONLY : mill, eigts1, eigts2, eigts3, g
+  USE klist,            ONLY : xk, igk_k, ngk
+  USE wvfct,            ONLY : npwx
+  USE uspp_param,       ONLY : upf, nwfcm
+  USE noncollin_module, ONLY : noncolin, domag, npol, angle1, angle2, &
+                               starting_spin_angle
+  USE upf_spinorb,      ONLY : rot_ylm, lmaxx
+  !
+  implicit none
+  INTEGER, INTENT(IN) :: ik
+  !! k-point index
+  COMPLEX(DP), INTENT(OUT) :: wfcatom( npwx, npol, natomwfc )
+  !! Superposition of atomic wavefunctions
+  !
+  ! ... local variables
+  !
+  INTEGER :: n_starting_wfc, lmax_wfc, nt, l, nb, na, m, lm, ig, iig, &
+             i0, i1, i2, i3, npw
+  REAL(DP),    ALLOCATABLE :: qg(:), ylm (:,:), chiq (:,:,:), gk (:,:)
+  COMPLEX(DP), ALLOCATABLE :: sk (:), aux(:)
+  COMPLEX(DP) :: kphase, lphase
+  REAL(DP)    :: arg
+
+  REAL(DP) :: j
+  REAL(DP), ALLOCATABLE :: chiaux(:)
+  INTEGER :: nc, ib
+
+
+  CALL start_clock( 'atomic_wfc' )
+
+  ! calculate max angular momentum required in wavefunctions
+  lmax_wfc = 0
+  DO nt = 1, ntyp
+     lmax_wfc = MAX( lmax_wfc, MAXVAL( upf(nt)%lchi(1:upf(nt)%nwfc) ) )
+  END DO
+  !
+  npw = ngk(ik)
+  !
+  ALLOCATE( ylm (npw,(lmax_wfc+1)**2), chiq(npw,nwfcm,ntyp), &
+       gk(3,npw), qg(npw) )
+  !
+  DO ig = 1, npw
+     iig = igk_k (ig,ik)
+     gk (1,ig) = xk(1, ik) + g(1,iig)
+     gk (2,ig) = xk(2, ik) + g(2,iig)
+     gk (3,ig) = xk(3, ik) + g(3,iig)
+     qg(ig) = gk(1, ig)**2 +  gk(2, ig)**2 + gk(3, ig)**2
+  END DO
+  !
+  !  ylm = spherical harmonics
+  !
+  CALL ylmr2( (lmax_wfc+1)**2, npw, gk, qg, ylm )
+  !
+  ! set now q=|k+G| in atomic units
+  !
+  DO ig = 1, npw
+     qg(ig) = SQRT( qg(ig) )*tpiba
+  END DO
+  !
+  CALL interp_atwfc ( npw, qg, nwfcm, chiq )
+  !
+  DEALLOCATE( qg, gk )
+  ALLOCATE( aux(npw), sk(npw) )
+  ALLOCATE(chiaux(npw))
+  !
+  wfcatom(:,:,:) = (0.0_dp, 0.0_dp)
+  n_starting_wfc = 0
+  !
+  DO na = 1, nat
+     arg = (xk(1,ik)*tau(1,na) + xk(2,ik)*tau(2,na) + xk(3,ik)*tau(3,na)) * tpi
+     kphase = CMPLX( COS(arg), - SIN(arg) ,KIND=DP)
+     !
+     !     sk is the structure factor
+     !
+     DO ig = 1, npw
+        iig = igk_k (ig,ik)
+        sk (ig) = kphase * eigts1 (mill (1,iig), na) * &
+                           eigts2 (mill (2,iig), na) * &
+                           eigts3 (mill (3,iig), na)
+     END DO
+     !
+     nt = ityp (na)
+     DO nb = 1, upf(nt)%nwfc
+        IF ( upf(nt)%oc(nb) >= 0.d0 ) THEN
+           l = upf(nt)%lchi(nb)
+           lphase = (0.d0,1.d0)**l
+           !
+           !  the factor i^l MUST BE PRESENT in order to produce
+           !  wavefunctions for k=0 that are real in real space
+           !
+           j = upf(nt)%jchi(nb)
+           !
+           !  This routine creates two functions only in the case j=l+1/2 or exit in the
+           !  other case 
+           !    
+           IF (ABS(j-l+0.5_DP)<1.d-4) CYCLE
+           !
+           !  Find the functions j=l-1/2
+           !
+           IF (l == 0)  THEN
+              chiaux(:)=chiq(:,nb,nt)
+           ELSE
+              DO ib=1, upf(nt)%nwfc
+                 IF ((upf(nt)%lchi(ib) == l).AND. &
+                              (ABS(upf(nt)%jchi(ib)-l+0.5_DP)<1.d-4)) THEN
+                    nc=ib
+                    EXIT
+                 ENDIF
+              ENDDO
+              !
+              !  Average the two functions
+              !
+              chiaux(:)=(chiq(:,nb,nt)*(l+1.0_DP)+chiq(:,nc,nt)*l)/(2.0_DP*l+1.0_DP)
+              !
+           ENDIF 
+           !
+           !  and construct the starting wavefunctions as in the noncollinear case.
+           !
+           DO m = 1, 2 * l + 1
+              lm = l**2 + m
+              n_starting_wfc = n_starting_wfc + 1
+              IF ( n_starting_wfc + 2*l+1 > natomwfc ) CALL errore &
+                    ('atomic_wfc_so_mag', 'internal error: too many wfcs', 1)
+              DO ig = 1, npw
+                 aux(ig) = sk(ig)*ylm(ig,lm)*chiaux(ig)
+              END DO
+              !
+              DO ig = 1, npw
+                 !
+                 ! Now, build the orthogonal wfc
+                 !
+                 wfcatom(ig,1,n_starting_wfc) = lphase * aux(ig)
+                 wfcatom(ig,2,n_starting_wfc) = (0.0_DP, 0.0_DP)
+                 !
+                 !
+                 wfcatom(ig,1,n_starting_wfc+2*l+1) = (0.0_DP, 0.0_DP)
+                 !wfcatom(ig,2,n_starting_wfc+2*l+1) = (0.0_DP, 1.0_DP) * lphase * aux(ig)
+                 wfcatom(ig,2,n_starting_wfc+2*l+1) = lphase * aux(ig)
+                 !
+              END DO
+           END DO
+           n_starting_wfc = n_starting_wfc + 2*l+1
+           !
+        END IF
+        !
+     END DO
+     !
+  END DO
+
+  IF ( n_starting_wfc /= natomwfc) call errore ('atomic_wfc', &
+       'internal error: some wfcs were lost ', 1 )
+
+  DEALLOCATE( aux, sk, chiq, ylm )
+  DEALLOCATE( chiaux )
+
+  CALL stop_clock( 'atomic_wfc' )
+  
+  RETURN
+
+END SUBROUTINE atomic_wfc_v_nc
+!
+! WIY
+SUBROUTINE atomic_wfc_nc_updown_v( ik, wfcatom )
+  !-----------------------------------------------------------------------
+  !! For noncollinear case: builds up the superposition (for a k-point 
+  !! \(\text{ik}\)) of pure spin-up or spin-down atomic wavefunctions.
+  !
+  !! Based on 'atomic_wfc.f90'
+  !! Refer to SUBROUTINE 'atomic_wfc_so_mag' and 'atomic_wfc_nc'
+  !
+  USE kinds,             ONLY : DP
+  USE constants,         ONLY : tpi, fpi, pi
+  USE cell_base,         ONLY : tpiba
+  USE ions_base,         ONLY : nat, ntyp => nsp, ityp, tau
+  USE basis,             ONLY : natomwfc
+  USE gvect,             ONLY : mill, eigts1, eigts2, eigts3, g
+  USE klist,             ONLY : xk, ngk, igk_k
+  USE wvfct,             ONLY : npwx, nbnd
+  USE uspp_param,        ONLY : upf, nwfcm
+  USE noncollin_module,  ONLY : noncolin, npol, angle1, angle2, domag, lspinorb
+  USE upf_spinorb,       ONLY : rot_ylm
+  USE constants,         ONLY : sqrt2
+  !
+  IMPLICIT NONE
+  !
+  INTEGER, INTENT(IN) :: ik
+  !! the k-point index
+  COMPLEX(DP), INTENT(OUT) :: wfcatom(npwx,npol,natomwfc)
+  !! the superposition of atomic wavefunctions (up or down)
+  !
+  ! ... local variables
+  !
+  INTEGER :: n_starting_wfc, lmax_wfc, nt, l, nb, na, m, lm, ig, iig, npw
+  REAL(DP), ALLOCATABLE :: qg(:), ylm(:,:), chiq(:,:,:), gk(:,:)
+  COMPLEX(DP), ALLOCATABLE :: sk(:), aux(:)
+  COMPLEX(DP) :: kphase, lphase
+  REAL(DP) :: arg, px, ux, vx, wx
+  !
+  CALL start_clock( 'atomic_wfc' )
+  !
+  ! ... calculate max angular momentum required in wavefunctions
+  !
+  lmax_wfc = 0
+  do nt = 1, ntyp
+     lmax_wfc = MAX( lmax_wfc, MAXVAL(upf(nt)%lchi(1:upf(nt)%nwfc)) )
+  ENDDO
+  !
+  npw = ngk(ik)
+  ALLOCATE ( ylm (npw,(lmax_wfc+1)**2), chiq(npw,nwfcm,ntyp), &
+       gk(3,npw), qg(npw) )
+  !
+  DO ig = 1, npw
+     iig = igk_k(ig,ik)
+     gk(1,ig) = xk(1,ik) + g(1,iig)
+     gk(2,ig) = xk(2,ik) + g(2,iig)
+     gk(3,ig) = xk(3,ik) + g(3,iig)
+     qg(ig) = gk(1,ig)**2 +  gk(2,ig)**2 + gk(3,ig)**2
+  ENDDO
+  !
+  ! ... ylm = spherical harmonics
+  !
+  CALL ylmr2( (lmax_wfc+1)**2, npw, gk, qg, ylm )
+  !
+  ! ... set now q=|k+G| in atomic units
+  !
+  DO ig = 1, npw
+     qg(ig) = SQRT(qg(ig))*tpiba
+  ENDDO
+  !
+  CALL interp_atwfc ( npw, qg, nwfcm, chiq )
+  !
+  DEALLOCATE( qg, gk )
+  ALLOCATE( aux(npw), sk(npw) )
+  !
+  wfcatom(:,:,:) = (0.0_dp, 0.0_dp)
+  n_starting_wfc = 0
+  !
+  DO na = 1, nat
+     arg = (xk(1,ik)*tau(1,na) + xk(2,ik)*tau(2,na) + xk(3,ik)*tau(3,na)) * tpi
+     kphase = CMPLX(COS(arg), - SIN(arg), KIND=DP)
+     !
+     ! ... sk is the structure factor
+     !
+     DO ig = 1, npw
+        iig = igk_k(ig,ik)
+        sk(ig) = kphase * eigts1 (mill(1,iig), na) * &
+                          eigts2 (mill(2,iig), na) * &
+                          eigts3 (mill(3,iig), na)
+     ENDDO
+     !
+     nt = ityp (na)
+     DO nb = 1, upf(nt)%nwfc
+        IF (upf(nt)%oc(nb) >= 0.d0) THEN
+           l = upf(nt)%lchi(nb)
+           lphase = (0.d0,1.d0)**l
+           !
+           ! the factor i^l MUST BE PRESENT in order to produce
+           ! wavefunctions for k = 0 that are real in real space
+           !
+           IF ( upf(nt)%has_so ) THEN
+              !
+              CALL wfc_atom( .TRUE. )
+              !
+           ELSE
+              !
+              CALL wfc_atom( .FALSE. )
+              !
+           ENDIF
+           !
+        ENDIF
+        !
+     ENDDO
+     !
+  ENDDO
+  !
+  IF (n_starting_wfc /= natomwfc) CALL errore( 'atomic_wfc_nc_updown', &
+                             'internal error: some wfcs were lost ', 1 )
+  !
+  DEALLOCATE( aux, sk, chiq, ylm )
+  !
+  CALL stop_clock ( 'atomic_wfc' )
+  !
+  RETURN
+  !
+CONTAINS
+   !
+   !--------------------------
+   SUBROUTINE wfc_atom( soc )
+      !---------------------------
+      !
+      LOGICAL :: soc
+      !! .TRUE. if the fully-relativistic pseudo
+      !
+      ! ... local variables
+      !
+      REAL(DP) :: j, gamman
+      REAL(DP), ALLOCATABLE :: chiaux(:)
+      INTEGER :: nc, ib 
+      !
+      ! ... If SOC go on only if j=l+1/2
+      IF (soc) j = upf(nt)%jchi(nb)
+      IF (soc .AND. ABS(j-l+0.5_DP)<1.d-4 ) RETURN
+      !
+      ALLOCATE( chiaux(npw) )
+      !
+      IF (soc) THEN 
+        !
+        ! ... Find the index for j=l-1/2
+        !
+        IF (l == 0)  THEN
+           chiaux(:)=chiq(:,nb,nt)
+        ELSE
+           DO ib=1, upf(nt)%nwfc
+              IF ((upf(nt)%lchi(ib) == l) .AND. &
+                           (ABS(upf(nt)%jchi(ib)-l+0.5_DP)<1.d-4)) THEN
+                 nc=ib
+                 exit
+              ENDIF
+           ENDDO
+           !
+           ! ... Average the two radial functions 
+           !
+           chiaux(:) = (chiq(:,nb,nt)*(l+1.0_DP)+chiq(:,nc,nt)*l)/(2.0_DP*l+1.0_DP)
+        ENDIF
+        !
+      ELSE
+        !
+        chiaux(:) = chiq(:,nb,nt)
+        !
+      ENDIF
+      !
+      DO m = 1, 2*l+1
+         lm = l**2 + m
+         n_starting_wfc = n_starting_wfc + 1
+         !
+         IF (n_starting_wfc + 2*l+1 > natomwfc) CALL errore &
+               ('atomic_wfc_nc', 'internal error: too many wfcs', 1)
+         !
+         aux=(0.d0,0.d0)
+         !
+         ! temp
+         !IF ( soc == .true. ) THEN
+         !    !
+         !    IF ( l == 1 ) THEN
+         !       IF ( m == 2 ) THEN
+         !           aux(:) = CMPLX((-1.d0)/sqrt2, 0.d0, KIND=DP) * ylm(:,lm) + & 
+         !                    CMPLX(0.d0, (-1.d0)/sqrt2, KIND=DP) * ylm(:,lm+1) 
+         !       ELSE IF ( m == 3 ) THEN
+         !           aux(:) = CMPLX(1.d0/sqrt2, 0.d0, KIND=DP) * ylm(:,lm-1) + & 
+         !                    CMPLX(0.d0, (-1.d0)/sqrt2, KIND=DP) * ylm(:,lm)
+         !       ELSE
+         !           aux(:) = ylm(:,lm)
+         !       ENDIF
+         !       !
+         !    ELSE IF ( l == 2 ) THEN
+         !       IF ( m == 2 ) THEN
+         !           aux(:) = CMPLX((-1.d0)/sqrt2, 0.d0, KIND=DP) * ylm(:,lm) + & 
+         !                    CMPLX(0.d0, (-1.d0)/sqrt2, KIND=DP) * ylm(:,lm+1)    
+         !       ELSE IF ( m == 3 ) THEN
+         !           aux(:) = CMPLX(1.d0/sqrt2, 0.d0, KIND=DP) * ylm(:,lm-1) + &
+         !                    CMPLX(0.d0, (-1.d0)/sqrt2, KIND=DP) * ylm(:,lm)
+         !       ELSE IF ( m == 4 ) THEN
+         !           aux(:) = CMPLX(1.d0/sqrt2, 0.d0, KIND=DP) * ylm(:,lm) + & 
+         !                    CMPLX(0.d0, (1.d0)/sqrt2, KIND=DP) * ylm(:,lm+1)
+         !       ELSE IF ( m == 5 ) THEN
+         !           aux(:) = CMPLX(1.d0/sqrt2, 0.d0, KIND=DP) * ylm(:,lm-1) + &
+         !                    CMPLX(0.d0, (-1.d0)/sqrt2, KIND=DP) * ylm(:,lm)
+         !       ELSE
+         !           aux(:) = ylm(:,lm)
+         !       ENDIF
+         !    ELSE
+         !        aux(:) = ylm(:,lm)
+         !    ENDIF
+         !ELSE
+         !   aux(:) = ylm(:,lm)
+         !ENDIF
+         ! temp
+         !
+         DO ig = 1, npw
+            aux(ig) = sk(ig)*ylm(ig,lm)*chiaux(ig)
+         ENDDO
+         ! 
+         DO ig = 1, npw
+            !
+            wfcatom(ig,1,n_starting_wfc) = lphase*aux(ig)
+            !wfcatom(ig,1,n_starting_wfc) = lphase*sk(ig)*aux(ig)*chiaux(ig)
+            wfcatom(ig,2,n_starting_wfc) = (0.0_dp, 0.0_dp)
+            !
+            wfcatom(ig,1,n_starting_wfc+2*l+1) = (0.0_dp, 0.0_dp)
+            !wfcatom(ig,2,n_starting_wfc+2*l+1) = lphase*sk(ig)*CONJG(aux(ig))*chiaux(ig)
+            wfcatom(ig,2,n_starting_wfc+2*l+1) = lphase * aux(ig)
+            !
+         ENDDO
+      ENDDO
+      !
+      n_starting_wfc = n_starting_wfc + 2*l+1
+      !
+      DEALLOCATE( chiaux )
+      !
+   END SUBROUTINE wfc_atom
+   !
+   !
+END SUBROUTINE atomic_wfc_nc_updown_v
+!
+
diff --git a/PW/src/potinit.f90 b/PW/src/potinit.f90
index 4b6226b2c..dab84a302 100644
--- a/PW/src/potinit.f90
+++ b/PW/src/potinit.f90
@@ -42,11 +42,17 @@ SUBROUTINE potinit()
                                    niter_with_fixed_ns, lda_plus_u_kind, &
                                    nsg, nsgnew
   USE noncollin_module,     ONLY : noncolin, domag, report, lforcet
+  ! by LSH
+  USE ldaV,                 ONLY : lda_plus_v, lacbn0, acbn0_type, ehubene, &
+                                   read_ehub_ns_file, read_ehub_uv_file
+  ! by LSH
   USE io_files,             ONLY : restart_dir, input_drho, check_file_exist
   USE mp,                   ONLY : mp_sum
   USE mp_bands ,            ONLY : intra_bgrp_comm, root_bgrp
   USE io_global,            ONLY : ionode, ionode_id
-  USE io_rho_xml,           ONLY : read_scf
+  ! by LSH
+  USE io_rho_xml,           ONLY : read_scf, read_ehub_ns, read_ehub_uv
+  ! by LSH
   USE io_base,              ONLY : read_rhog
   USE fft_rho,              ONLY : rho_g2r, rho_r2g
   !
@@ -170,6 +176,21 @@ SUBROUTINE potinit()
         ENDIF
         !
      ENDIF
+     ! by LSH
+     IF ( lda_plus_v ) THEN
+        IF ( read_ehub_ns_file ) THEN
+           CALL read_ehub_ns( rho )
+           CALL read_ehub_uv
+        ELSE
+           IF ( read_ehub_uv_file ) CALL read_ehub_uv
+           IF ( noncolin ) THEN
+              CALL init_ns_v_nc()
+           ELSE
+              CALL init_ns_v()
+           ENDIF
+        ENDIF
+     ENDIF
+     ! by LSH
 
      ! ... in the paw case uses atomic becsum
      IF ( okpaw )      CALL PAW_atomic_becsum()
@@ -269,7 +290,9 @@ SUBROUTINE potinit()
   ! ... compute the potential and store it in v
   !
   CALL v_of_rho( rho, rho_core, rhog_core, &
-                 ehart, etxc, vtxc, eth, etotefield, charge, v )
+                 ! by LSH
+                 ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+                 ! by LSH
   IF (okpaw) CALL PAW_potential(rho%bec, ddd_PAW, epaw)
   !
   ! ... calculate 3D-RISM to get the solvation potential
diff --git a/PW/src/print_clock_pw.f90 b/PW/src/print_clock_pw.f90
index 82d05bb72..1bd2d40f0 100644
--- a/PW/src/print_clock_pw.f90
+++ b/PW/src/print_clock_pw.f90
@@ -21,6 +21,10 @@ SUBROUTINE print_clock_pw()
    USE noncollin_module,   ONLY : noncolin
    USE ldaU,               ONLY : lda_plus_u, lda_plus_u_kind, is_hubbard_back
    USE xc_lib,             ONLY : xclib_dft_is
+   ! by LSH
+   USE ldaV,               ONLY : lda_plus_v, lacbn0, acbn0_type
+   ! by LSH
+   !USE funct,              ONLY : dft_is_hybrid
    USE bp,                 ONLY : lelfield
    USE rism_module,        ONLY : rism_print_clock
    !
@@ -283,6 +287,47 @@ SUBROUTINE print_clock_pw()
       CALL print_clock( 'force_hub' )
       CALL print_clock( 'stres_hub' )
    ENDIF
+   ! by LSH WIY
+   IF ( lda_plus_v ) THEN
+      WRITE( stdout, '(/,5X,"Extended Hubbard routines")' )
+      IF ( lacbn0 ) THEN
+         IF ( noncolin ) THEN
+            IF ( acbn0_type == 1 ) CALL print_clock( 'new_ns_a0_nc' )
+            IF ( acbn0_type == 2 ) CALL print_clock( 'new_ns_e0_nc' )
+            IF ( acbn0_type == 3 ) CALL print_clock( 'new_ns_e0_nc' )
+         ELSE
+            IF ( acbn0_type == 1 ) CALL print_clock( 'new_ns_a0' )
+            IF ( acbn0_type == 2 ) CALL print_clock( 'new_ns_e0_#1' )
+            IF ( acbn0_type == 3 ) CALL print_clock( 'new_ns_e0_#2' )
+         ENDIF
+      ELSE
+         IF ( noncolin ) THEN 
+            CALL print_clock( 'new_ns_v_nc' )
+         ELSE 
+            CALL print_clock( 'new_ns_v' )
+         ENDIF 
+      ENDIF
+      IF ( lacbn0 ) THEN
+         IF ( noncolin ) THEN
+             IF ( acbn0_type == 1 ) CALL print_clock( 'vhpsi_a0_nc' )
+             IF ( acbn0_type == 2 ) CALL print_clock( 'vhpsi_v_nc' )
+             IF ( acbn0_type == 3 ) CALL print_clock( 'vhpsi_v_nc' )
+         ELSE
+             IF ( acbn0_type == 1 ) CALL print_clock( 'vhpsi_a0' )
+             IF ( acbn0_type == 2 ) CALL print_clock( 'vhpsi_v' )
+             IF ( acbn0_type == 3 ) CALL print_clock( 'vhpsi_v' )
+         ENDIF
+      ELSE
+         IF ( noncolin ) THEN 
+            CALL print_clock( 'vhpsi_v_nc' )
+         ELSE 
+            CALL print_clock( 'vhpsi_v' )
+         ENDIF 
+      ENDIF
+      CALL print_clock( 'force_hub_v' )
+      CALL print_clock( 'stres_hub_v' )
+   ENDIF
+   ! by LSH WIY
    !
    IF ( xclib_dft_is('hybrid') ) THEN
       WRITE( stdout, '(/,5X,"EXX routines")' )
diff --git a/PW/src/pw2casino_write.f90 b/PW/src/pw2casino_write.f90
index 0b19a207a..b40b915b5 100644
--- a/PW/src/pw2casino_write.f90
+++ b/PW/src/pw2casino_write.f90
@@ -21,6 +21,9 @@ SUBROUTINE write_casino_wfn(gather,blip,multiplicity,binwrite,single_precision_b
    USE lsda_mod, ONLY: lsda, nspin
    USE scf, ONLY: rho, rho_core, rhog_core, v
    USE ldaU, ONLY : eth
+   ! by LSH
+   USE ldaV, ONLY : ehubene
+   ! by LSH
    USE vlocal, ONLY: vloc, strf
    USE wvfct, ONLY: npwx, nbnd, wg, et
    USE gvecw, ONLY: ecutwfc
@@ -461,7 +464,9 @@ CONTAINS
       ! compute hartree and xc contribution
       !
       CALL v_of_rho( rho, rho_core, rhog_core, &
-                     ehart, etxc, vtxc, eth, etotefield, charge, v )
+                     ! by LSH
+                     ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+                     ! by LSH
       !
       ! compute exact exchange contribution (if present)
       !
diff --git a/PW/src/pw_init_qexsd_input.f90 b/PW/src/pw_init_qexsd_input.f90
index 2b7d19b7b..75ef63307 100644
--- a/PW/src/pw_init_qexsd_input.f90
+++ b/PW/src/pw_init_qexsd_input.f90
@@ -74,7 +74,13 @@
                                 laue_buffer_left, laue_buffer_left_solu, laue_buffer_left_solv, laue_both_hands,      &
                                 laue_reference, laue_wall, laue_wall_z, laue_wall_rho, laue_wall_epsilon,             &
                                 laue_wall_sigma, laue_wall_lj6, nsolv, solv_label, solv_mfile, solv_dens1, solv_dens2,&
-                                solvents_unit
+                                solvents_unit,                                                                        &
+                                ! by LSH
+                                ip_lda_plus_v => lda_plus_v, ip_lacbn0 => lacbn0, ip_acbn0_type => acbn0_type,        &
+                                ip_ehub_nn_distance => ehub_nn_distance, ip_ehub_l_choice => ehub_l_choice,           &
+                                ip_ehub_u => ehub_u, ip_ehub_v => ehub_v
+                                ! by LSH
+
 !
   USE fixed_occ,         ONLY:  f_inp               
 !
@@ -90,7 +96,9 @@
   USE qes_types_module
   USE qes_libs_module
   USE qexsd_init,        ONLY: qexsd_init_atomic_species, qexsd_init_atomic_structure, qexsd_init_dft, &
-                               qexsd_init_hybrid, qexsd_init_vdw, qexsd_init_dftU
+                               ! by LSH
+                               qexsd_init_hybrid, qexsd_init_vdw, qexsd_init_dftU, qexsd_init_ehub
+                               ! by LSH
   USE qexsd_input  
   IMPLICIT NONE
   ! 
@@ -119,6 +127,9 @@
   REAL(DP),POINTER                         ::  block_1_ptr, block_2_ptr, block_height_ptr, zgate_ptr
   TYPE(hybrid_type)                        ::  hybrid_
   TYPE(dftU_type)                          ::  dftU_
+  ! by LSH
+  TYPE(ehub_type)                          ::  ehub_
+  ! by LSH
   TYPE(vdW_type)                           ::  vdW_
   REAL(DP),TARGET                          ::  xdm_a1_, xdm_a2_, lond_s6_, lond_rcut_, ts_vdw_econv_thr_,&
                                                scr_par_, exx_frc_, ecutvcut_, ecut_fock_, loc_thr_, cell_factor_tg      
@@ -139,6 +150,12 @@
   CHARACTER,EXTERNAL                       :: capital
   INTEGER                                  :: i, nt1, nt2, na, nb
   REAL(DP), PARAMETER                      :: ev_to_Ha = 1 / e2 / RYTOEV 
+  ! by LSH
+  REAL(DP), ALLOCATABLE                    :: ehub_u_(:,:,:), ehub_v_(:,:,:,:,:)
+  INTEGER,  ALLOCATABLE                    :: ehub_l_choice_(:,:)
+  INTEGER                                  :: ehub_lm_max, l_max, ehub_nnnc, nnnc_xml
+  INTEGER                                  :: k, j !!
+  ! by LSH
   !
   ! 
   NULLIFY(vdw_corr_pointer, vdw_nonlocc_pt) 
@@ -391,10 +408,66 @@
   ELSE
     dftU_%lwrite = .false. 
   END IF
-  CALL qexsd_init_dft(obj%dft, TRIM(dft_name), hybrid_, vdW_, dftU_)
+  ! by LSH WIY
+  IF (ip_lda_plus_v) THEN
+     !
+     ALLOCATE ( ehub_l_choice_(ntyp,6) )
+     ehub_l_choice_(1:ntyp,1:6) = ip_ehub_l_choice(1:ntyp,1:6)
+     !
+     ehub_nnnc = nnnc_xml(ip_ehub_nn_distance, ip_nat)
+     !
+     ehub_lm_max = -1
+     !
+     DO k = 1, ntyp
+        !
+        l_max = 0
+        !
+        DO j = 1, 6
+           IF ( j < 5 ) THEN
+              l_max = l_max + ehub_l_choice_(k,j) * (2*j-1)
+           ELSEIF ( j == 5 ) THEN
+              l_max = l_max + ehub_l_choice_(k,j) * 5
+           ENDIF
+        ENDDO
+        !
+        ehub_lm_max = MAX(ehub_lm_max, l_max)
+        !
+     ENDDO
+     !
+     IF ( ip_lacbn0 .AND. ip_acbn0_type == 1 ) THEN
+        !
+        ALLOCATE ( ehub_u_(ip_nat,ehub_lm_max,ehub_lm_max) )
+        !
+        ehub_u_(1:ip_nat,1:ehub_lm_max,1:ehub_lm_max) = &
+        ip_ehub_u(1:ip_nat,1:ehub_lm_max,1:ehub_lm_max)
+        !
+        CALL qexsd_init_ehub (ehub_, ip_lacbn0, ip_acbn0_type, ip_ehub_nn_distance, ehub_nnnc, &
+                              ehub_l_choice_, ehub_lm_max, U_projection_type=ip_hubbard_projectors, ehub_u = ehub_u_)
+        !
+     ELSE
+        !
+        ALLOCATE ( ehub_v_(ip_nat,ip_nat,ehub_lm_max,ehub_lm_max,ehub_nnnc) )
+        !
+        ehub_v_(1:ip_nat,1:ip_nat,1:ehub_lm_max,1:ehub_lm_max,1:ehub_nnnc) = &
+        ip_ehub_v(1:ip_nat,1:ip_nat,1:ehub_lm_max,1:ehub_lm_max,1:ehub_nnnc)
+        !
+        CALL qexsd_init_ehub (ehub_, ip_lacbn0, ip_acbn0_type, ip_ehub_nn_distance, ehub_nnnc, &
+                              ehub_l_choice_, ehub_lm_max, U_projection_type=ip_hubbard_projectors, ehub_v = ehub_v_)
+        !
+     END IF
+  ELSE
+    ehub_%lwrite = .false.
+  END IF
+  ! by LSH WIY
+  ! by LSH WIY
+  CALL qexsd_init_dft(obj%dft, TRIM(dft_name), hybrid_, vdW_, dftU_, ehub_)
+  ! by LSH WIY
   CALL qes_reset(hybrid_)
   CALL qes_reset(vdW_)
   CALL qes_reset(dftU_)
+  ! by LSH WIY
+  CALL qes_reset(ehub_)
+  ! by LSH WIY
   IF (ALLOCATED(hubbard_U_))          DEALLOCATE(hubbard_U_)
   IF (ALLOCATED(hubbard_U2_))         DEALLOCATE(hubbard_U2_)
   IF (ALLOCATED(hubbard_J0_))         DEALLOCATE(hubbard_J0_)
@@ -405,6 +478,11 @@
   IF (ALLOCATED(starting_ns_))        DEALLOCATE(starting_ns_)
   IF (ALLOCATED(hubbard_n_))          DEALLOCATE(hubbard_n_)
   IF (ALLOCATED(hubbard_l_))          DEALLOCATE(hubbard_l_)
+  ! by WIY
+  IF (ALLOCATED(ehub_l_choice_))      DEALLOCATE(ehub_l_choice_)
+  IF (ALLOCATED(ehub_u_))             DEALLOCATE(ehub_u_)
+  IF (ALLOCATED(ehub_v_))             DEALLOCATE(ehub_v_)
+  ! by WIY
   !
   !------------------------------------------------------------------------------------------------------------------------
   !                                                   SPIN ELEMENT
@@ -689,3 +767,70 @@
   !
   END SUBROUTINE pw_init_qexsd_input
   !
+  ! by LSH
+  !-----------------------------------------------------------------------
+FUNCTION nnnc_xml( ehub_nn_distance, nat )
+  !-----------------------------------------------------------------------
+  !
+  ! number of nearest neighbor cells for extended Hubbard calculations
+  !
+  USE kinds,     ONLY : dp
+  USE constants, ONLY : bohr_radius_angs
+  USE cell_base, ONLY : at, alat
+  USE ions_base, ONLY : tau
+
+  IMPLICIT NONE
+
+  REAL(DP), INTENT(IN) :: ehub_nn_distance
+  INTEGER              :: nat
+
+  REAL(DP)             :: rmax, dtau(3)
+  REAL(DP)             :: r(3), r2
+
+  INTEGER              :: na, nb
+  INTEGER              :: n1, n2, n3, ix
+  INTEGER              :: counter
+  INTEGER              :: nnnc_xml
+
+  counter = 0
+  nnnc_xml = 0
+  rmax = ehub_nn_distance / bohr_radius_angs / alat
+  !
+  DO n1 = -10, 10
+  DO n2 = -10, 10
+  DO n3 = -10, 10
+     !
+     DO na = 1, nat
+     DO nb = 1, nat
+        !
+        dtau(:) = tau(:, na) - tau(:, nb)
+        !
+        r2 = 0.0_DP
+        !
+        DO ix = 1, 3
+           r(ix) = n1 * at(ix,1) + n2 * at(ix,2) + n3 * at(ix,3) - dtau(ix)
+           r2 = r2 + r(ix) * r(ix)
+        ENDDO
+        !
+        IF (r2 <= rmax**2 .AND. ABS(r2) > 1.0D-10) THEN
+           IF (n1 == 0 .AND. n2 == 0 .AND. n3 == 0) counter = 1
+           nnnc_xml = nnnc_xml + 1
+           GO TO 10
+        ENDIF
+        !
+     ENDDO ! nb
+     ENDDO ! na
+     !
+10   CONTINUE
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  IF (counter == 0) nnnc_xml = nnnc_xml + 1
+  !
+  RETURN
+
+END FUNCTION nnnc_xml
+  ! by LSH
+
diff --git a/PW/src/pw_restart_new.f90 b/PW/src/pw_restart_new.f90
index 1736feb39..832ea3fbe 100644
--- a/PW/src/pw_restart_new.f90
+++ b/PW/src/pw_restart_new.f90
@@ -18,7 +18,10 @@ MODULE pw_restart_new
   USE kinds, ONLY: dp
   USE qes_types_module, ONLY : output_type, parallel_info_type, &
        general_info_type, input_type, gateInfo_type, dipoleOutput_type, &
-       BerryPhaseOutput_type, hybrid_type, vdw_type, dftU_type, smearing_type
+       ! by LSH
+       BerryPhaseOutput_type, hybrid_type, vdw_type, dftU_type, smearing_type, &
+       ehub_type
+       ! by LSH
   USE qes_write_module, ONLY: qes_write
   USE qes_reset_module, ONLY: qes_reset 
   USE qes_bcast_module,ONLY : qes_bcast
@@ -35,7 +38,9 @@ MODULE pw_restart_new
                           qexsd_init_outputElectricField, qexsd_init_outputPBC,        &
                           qexsd_init_gate_info, qexsd_init_hybrid,  qexsd_init_dftU,   &
                           qexsd_init_rism3d, qexsd_init_rismlaue,                      &
-                          qexsd_occ_obj, qexsd_bp_obj, qexsd_start_k_obj
+                          ! by LSH
+                          qexsd_occ_obj, qexsd_bp_obj, qexsd_start_k_obj, qexsd_init_ehub
+                          ! by LSH
   USE qexsd_copy,      ONLY : qexsd_copy_parallel_info, &
        qexsd_copy_algorithmic_info, qexsd_copy_atomic_species, &
        qexsd_copy_atomic_structure, qexsd_copy_symmetry, &
@@ -105,6 +110,10 @@ MODULE pw_restart_new
                                        Hubbard_alpha, Hubbard_alpha_back, nsg, &
                                        Hubbard_J0, Hubbard_beta, Hubbard_U2, ityp_s, &
                                        is_hubbard, is_hubbard_back, backall, neighood, nsg
+      ! by LSH
+      USE ldaV,                 ONLY : lda_plus_v, lacbn0, acbn0_type, ehub_nn_distance, &
+                                       ehub_nnnc, ehub_l_choice_inp, ehub_lm_max, ehub_u, ehub_v
+      ! by LSH
       USE symm_base,            ONLY : nrot, nsym, invsym, s, ft, irt, &
                                        t_rev, sname, time_reversal, no_t_rev,&
                                        spacegroup
@@ -204,6 +213,9 @@ MODULE pw_restart_new
       TYPE(vdW_type)               :: vdw_obj_opt
       TYPE(dftU_type)              :: dftU_obj_opt
       TYPE(smearing_type)          :: smear_obj_opt 
+      ! by LSH WIY
+      TYPE(ehub_type)              :: ehub_obj_opt
+      ! by LSH WIY
       !
       ! Copies of optional variables (*_tg) and pointers to them (*_pt)
       ! Pointers are nullified to signal that there is no such variable
@@ -236,6 +248,10 @@ MODULE pw_restart_new
            U2_opt(:), alpha_back_opt(:), ef_updw(:), nsg_(:,:,:,:)
       INTEGER,ALLOCATABLE :: n_opt(:), l_opt(:), l2_opt(:), l3_opt(:), n2_opt(:), n3_opt(:)
       LOGICAL, ALLOCATABLE :: backall_opt(:) 
+      ! by LSH
+      INTEGER,  ALLOCATABLE :: ehub_l_choice_opt(:,:)
+      REAL(DP), ALLOCATABLE :: ehub_u_opt(:,:,:), ehub_v_opt(:,:,:,:,:)
+      ! by LSH
       !
       !
       NULLIFY (homo_pt, lumo_pt, ef_pt, degauss_pt, demet_pt, &
@@ -535,12 +551,66 @@ MODULE pw_restart_new
          ELSE 
            dftU_obj_opt%lwrite=.false. 
          END IF 
+         ! by LSH WIY
+         IF ( lda_plus_v ) THEN
+            ALLOCATE ( ehub_l_choice_opt(nsp,6) )
+            ehub_l_choice_opt(1:nsp,1:6) = ehub_l_choice_inp(1:nsp,1:6)
+            !
+            IF ( lacbn0 .AND. acbn0_type == 1 ) THEN
+               !
+               ALLOCATE ( ehub_u_opt(nat,ehub_lm_max,ehub_lm_max) )
+               ehub_u_opt(1:nat,1:ehub_lm_max,1:ehub_lm_max) = &
+                   ehub_u(1:nat,1:ehub_lm_max,1:ehub_lm_max)
+               !
+               IF ( noncolin ) THEN
+                  CALL qexsd_init_ehub (ehub_obj_opt, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+                                        ehub_l_choice_opt, ehub_lm_max, U_projection_type = Hubbard_projectors, &
+                                        ehub_u = ehub_u_opt, ehub_na0_nc = rho%na0_nc)
+               ELSE
+                  CALL qexsd_init_ehub (ehub_obj_opt, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+                                        ehub_l_choice_opt, ehub_lm_max, U_projection_type = Hubbard_projectors, & 
+                                        ehub_u = ehub_u_opt, ehub_na0 = rho%na0)
+               ENDIF
+               !
+               IF (ALLOCATED(ehub_u_opt)) DEALLOCATE(ehub_u_opt)
+               !
+            ELSE
+               !
+               ALLOCATE ( ehub_v_opt(nat,nat,ehub_lm_max,ehub_lm_max,ehub_nnnc) )
+               ehub_v_opt(1:nat,1:nat,1:ehub_lm_max,1:ehub_lm_max,1:ehub_nnnc) = &
+                   ehub_v(1:nat,1:nat,1:ehub_lm_max,1:ehub_lm_max,1:ehub_nnnc)
+               !
+               IF ( noncolin ) THEN
+                  CALL qexsd_init_ehub (ehub_obj_opt, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+                                        ehub_l_choice_opt, ehub_lm_max, U_projection_type = Hubbard_projectors, &
+                                        ehub_v = ehub_v_opt, ehub_ne0_nc = rho%ne0_nc)
+               ELSE
+                  CALL qexsd_init_ehub (ehub_obj_opt, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+                                        ehub_l_choice_opt, ehub_lm_max, U_projection_type = Hubbard_projectors, &
+                                        ehub_v = ehub_v_opt, ehub_ne0 = rho%ne0)
+               ENDIF
+               !
+               IF (ALLOCATED(ehub_v_opt)) DEALLOCATE(ehub_v_opt)
+               !
+            ENDIF
+            !
+            IF (ALLOCATED(ehub_l_choice_opt)) DEALLOCATE(ehub_l_choice_opt)
+            !
+         ELSE
+           ehub_obj_opt%lwrite=.false.
+         END IF
+         ! by LSH WIY
          dft_name = get_dft_short()
          !
-         CALL qexsd_init_dft  (output_obj%dft, dft_name, hybrid_obj_opt, vdw_obj_opt, dftU_obj_opt)
+         ! by LSH WIY
+         CALL qexsd_init_dft  (output_obj%dft, dft_name, hybrid_obj_opt, vdw_obj_opt, dftU_obj_opt, ehub_obj_opt)
+         ! by LSH WIY
          CALL qes_reset(hybrid_obj_opt) 
          CALL qes_reset(vdw_obj_opt) 
          CALL qes_reset(dftU_obj_opt) 
+         ! by LSH WIY
+         CALL qes_reset(ehub_obj_opt)
+         ! by LSH WIY
          !
 !-------------------------------------------------------------------------------
 ! ... PERIODIC BOUNDARY CONDITIONS 
@@ -1137,6 +1207,11 @@ MODULE pw_restart_new
                                   Hubbard_n, Hubbard_l, Hubbard_n2, Hubbard_l2, Hubbard_n3, Hubbard_l3, backall, &
                                   Hubbard_U, Hubbard_U2, Hubbard_J, Hubbard_V, Hubbard_alpha, Hubbard_occ, &
                                   Hubbard_alpha_back, Hubbard_J0, Hubbard_beta, Hubbard_projectors
+      ! by LSH
+      USE ldaV,            ONLY : lda_plus_v, lacbn0, acbn0_type, ehub_nn_distance, &
+                                  ehub_lm_max, ehub_nnnc, ehub_l_choice, &
+                                  ehub_u, ehub_v
+      ! by LSH
       USE funct,           ONLY : enforce_input_dft, get_dft_short
       USE xc_lib,          ONLY : start_exx, exx_is_active,xclib_dft_is,      &
                                   set_screening_parameter, set_gau_parameter, &
@@ -1250,7 +1325,11 @@ MODULE pw_restart_new
            lda_plus_u, lda_plus_u_kind, Hubbard_projectors, Hubbard_n, Hubbard_l, Hubbard_lmax, Hubbard_occ,&
            Hubbard_n2, Hubbard_l2, Hubbard_n3, Hubbard_l3, backall, Hubbard_lmax_back, Hubbard_alpha_back, &
            Hubbard_U, Hubbard_U2, Hubbard_J0, Hubbard_alpha, Hubbard_beta, Hubbard_J, Hubbard_V, &
-           vdw_corr, dftd3_version, dftd3_3body, scal6, lon_rcut, vdw_isolated )
+           vdw_corr, dftd3_version, dftd3_3body, scal6, lon_rcut, vdw_isolated, &
+           ! by LSH
+           nat, lda_plus_v, lacbn0, acbn0_type, ehub_nn_distance, ehub_nnnc, &
+           ehub_l_choice, ehub_lm_max, ehub_u, ehub_v )
+           ! by LSH
       Hubbard_alpha_back = Hubbard_alpha_back * e2 
       Hubbard_alpha      = Hubbard_alpha      * e2
       Hubbard_beta       = Hubbard_beta       * e2 
diff --git a/PW/src/read_file_new.f90 b/PW/src/read_file_new.f90
index 60d6b2c9c..d18aadbcc 100644
--- a/PW/src/read_file_new.f90
+++ b/PW/src/read_file_new.f90
@@ -252,6 +252,9 @@ SUBROUTINE post_xml_init (  )
   USE funct,                ONLY : get_dft_name
   USE ldaU,                 ONLY : lda_plus_u, eth, init_hubbard, Hubbard_projectors, &
                                    lda_plus_u_kind
+  ! by LSH
+  USE ldaV,                 ONLY : lda_plus_v, ehubene, init_lda_plus_v
+  ! by LSH
   USE esm,                  ONLY : do_comp_esm, esm_init
   USE Coul_cut_2D,          ONLY : do_cutoff_2D, cutoff_fact 
   USE ions_base,            ONLY : nat, nsp, tau, ityp
@@ -318,6 +321,9 @@ SUBROUTINE post_xml_init (  )
   IF ( lda_plus_u ) THEN
      CALL init_hubbard ( upf(1:nsp)%psd, nspin, noncolin )
   ENDIF
+  ! by LSH
+  IF ( lda_plus_v ) CALL init_lda_plus_v ( noncolin, nspin )
+  ! by LSH
   !
   ! ... allocate memory for G- and R-space fft arrays (from init_run.f90)
   !
@@ -397,7 +403,9 @@ SUBROUTINE post_xml_init (  )
   END IF
   !
   CALL v_of_rho( rho, rho_core, rhog_core, &
-       ehart, etxc, vtxc, eth, etotefield, charge, v )
+       ! by LSH
+       ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+       ! by LSH
   !
   ! ... recalculate the solvation potential (3D-RISM)
   !
diff --git a/PW/src/scf_mod.f90 b/PW/src/scf_mod.f90
index ec7414b3c..733bea0c4 100644
--- a/PW/src/scf_mod.f90
+++ b/PW/src/scf_mod.f90
@@ -13,6 +13,10 @@ MODULE scf
   USE lsda_mod,        ONLY : nspin
   USE ldaU,            ONLY : lda_plus_u, Hubbard_lmax, lda_plus_u_kind, ldmx, &
                               ldmx_b, is_hubbard_back
+  ! by LSH
+  USE ldaV,            ONLY : lda_plus_v, lacbn0, acbn0_type, &
+                              ehub_lm_max, ehub_nnnc
+  ! by LSH
   USE ions_base,       ONLY : nat
   USE buffers,         ONLY : open_buffer, close_buffer, get_buffer, save_buffer
   USE xc_lib,          ONLY : xclib_dft_is
@@ -58,6 +62,12 @@ MODULE scf
      !! the DFT+U occupation matrix (background states)
      COMPLEX(DP), ALLOCATABLE :: ns_nc(:,:,:,:)
      !! the DFT+U occupation matrix - noncollinear case
+     ! by LSH
+     REAL(DP),    ALLOCATABLE :: na0(:,:,:,:)        !  ACBN0 
+     COMPLEX(DP), ALLOCATABLE :: na0_nc(:,:,:,:)     !  ACBN0 - noncollinear
+     REAL(DP),    ALLOCATABLE :: ne0(:,:,:,:,:,:)    ! eACBN0
+     COMPLEX(DP), ALLOCATABLE :: ne0_nc(:,:,:,:,:,:) ! eACBN0 - noncollinear
+     ! by LSH
      REAL(DP),    ALLOCATABLE :: bec(:,:,:)
      !! the PAW hamiltonian elements
      REAL(DP),   ALLOCATABLE :: pol_r(:,:) 
@@ -77,7 +87,13 @@ MODULE scf
      REAL(DP),    ALLOCATABLE :: nsb(:,:,:,:)
      !! the DFT+U occupation matrix (background states)
      COMPLEX(DP), ALLOCATABLE :: ns_nc(:,:,:,:)
-     !! the DFT+U occupation matrix noncollinear case 
+     !! the DFT+U occupation matrix noncollinear case
+     ! by LSH
+     REAL(DP),    ALLOCATABLE :: na0(:,:,:,:)        !  ACBN0 
+     COMPLEX(DP), ALLOCATABLE :: na0_nc(:,:,:,:)     !  ACBN0 - noncollinear
+     REAL(DP),    ALLOCATABLE :: ne0(:,:,:,:,:,:)    ! eACBN0
+     COMPLEX(DP), ALLOCATABLE :: ne0_nc(:,:,:,:,:,:) ! eACBN0 - noncollinear
+     ! by LSH
      REAL(DP),    ALLOCATABLE :: bec(:,:,:)
      !! PAW corrections to hamiltonian
      REAL(DP) :: el_dipole
@@ -115,10 +131,16 @@ MODULE scf
                        start_rho=0, start_kin=0, start_ldaU=0, start_bec=0, &
                        start_dipole=0, start_ldaUb=0, start_pol=0
   INTEGER :: nt
+  ! by LSH
+  INTEGER, PRIVATE  :: rlen_ldaV=0, start_ldaV=0
+  ! by LSH
   ! DFT+U, colinear and noncolinear cases
   LOGICAL, PRIVATE :: lda_plus_u_co  ! collinear case
   LOGICAL, PRIVATE :: lda_plus_u_cob ! collinear case (background states)
   LOGICAL, PRIVATE :: lda_plus_u_nc  ! noncollinear case
+  ! by LSH
+  LOGICAL, PRIVATE :: lda_plus_v_co, lda_plus_v_nc
+  ! by LSH
   COMPLEX(DP), PRIVATE, ALLOCATABLE:: io_buffer(:)
   !
 CONTAINS
@@ -163,6 +185,35 @@ CONTAINS
    IF (lda_plus_u_cob) ALLOCATE( rho%nsb(ldmx_b,ldmx_b,nspin,nat) )
    IF (lda_plus_u_nc)  ALLOCATE( rho%ns_nc(2*Hubbard_lmax+1,2*Hubbard_lmax+1,nspin,nat) )
    !
+   ! by LSH
+   lda_plus_v_co = lda_plus_v .AND. .NOT. ( nspin == 4 )
+   lda_plus_v_nc = lda_plus_v .AND.       ( nspin == 4 )
+   !
+   IF ( lda_plus_v_co ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            ALLOCATE ( rho%na0(ehub_lm_max,ehub_lm_max,nspin,nat) )
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            ALLOCATE ( rho%ne0(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+         ENDIF
+      ELSE
+         ALLOCATE ( rho%ne0(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+      ENDIF
+   ENDIF
+   !
+   IF ( lda_plus_v_nc ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            ALLOCATE ( rho%na0_nc(ehub_lm_max,ehub_lm_max,nspin,nat) )
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            ALLOCATE ( rho%ne0_nc(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+         ENDIF
+      ELSE
+         ALLOCATE ( rho%ne0_nc(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+      ENDIF
+   ENDIF
+   ! by LSH
+   !
    IF (okpaw) THEN ! See the top of the file for clarification
       IF ( PRESENT(do_not_allocate_becsum) ) THEN
          allocate_becsum = .NOT. do_not_allocate_becsum
@@ -199,6 +250,12 @@ CONTAINS
    IF (ALLOCATED(rho%ns)   )  DEALLOCATE( rho%ns    )
    IF (ALLOCATED(rho%nsb)  )  DEALLOCATE( rho%nsb   )
    IF (ALLOCATED(rho%ns_nc))  DEALLOCATE( rho%ns_nc )
+   ! by LSH
+   IF (ALLOCATED(rho%na0)   ) DEALLOCATE( rho%na0    )
+   IF (ALLOCATED(rho%na0_nc)) DEALLOCATE( rho%na0_nc ) 
+   IF (ALLOCATED(rho%ne0)   ) DEALLOCATE( rho%ne0    )
+   IF (ALLOCATED(rho%ne0_nc)) DEALLOCATE( rho%ne0_nc )
+   ! by LSH
    IF (ALLOCATED(rho%bec)  )  DEALLOCATE( rho%bec   )
    IF (ALLOCATED(rho%pol_r))  DEALLOCATE( rho%pol_r )
    IF (ALLOCATED(rho%pol_g))  DEALLOCATE( rho%pol_g )
@@ -254,6 +311,40 @@ CONTAINS
       ALLOCATE( rho%nsb(ldmx_b,ldmx_b,nspin,nat) )
       rho%nsb = 0._dp
    ENDIF
+   ! by LSH
+   lda_plus_v_co = lda_plus_v .AND. .NOT. ( nspin == 4 )
+   lda_plus_v_nc = lda_plus_v .AND.       ( nspin == 4 )
+   !
+   IF ( lda_plus_v_co ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            ALLOCATE ( rho%na0(ehub_lm_max,ehub_lm_max,nspin,nat) )
+            rho%na0 = 0._dp
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            ALLOCATE ( rho%ne0(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+            rho%ne0 = 0._dp
+         ENDIF
+      ELSE
+         ALLOCATE ( rho%ne0(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+         rho%ne0 = 0._dp
+      ENDIF
+   ENDIF
+   !
+   IF ( lda_plus_v_nc ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            ALLOCATE ( rho%na0_nc(ehub_lm_max,ehub_lm_max,nspin,nat) )
+            rho%na0_nc = 0._dp
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            ALLOCATE ( rho%ne0_nc(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+            rho%ne0_nc = 0._dp
+         ENDIF
+      ELSE
+         ALLOCATE ( rho%ne0_nc(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+         rho%ne0_nc = 0._dp
+      ENDIF
+   ENDIF
+   ! by LSH
    !
    IF (okpaw) THEN
       ALLOCATE( rho%bec(nhm*(nhm+1)/2,nat,nspin) )
@@ -294,6 +385,12 @@ CONTAINS
    IF (ALLOCATED(rho%ns)   )  DEALLOCATE( rho%ns    )
    IF (ALLOCATED(rho%nsb)  )  DEALLOCATE( rho%nsb   )
    IF (ALLOCATED(rho%ns_nc))  DEALLOCATE( rho%ns_nc )
+   ! by LSH
+   IF (ALLOCATED(rho%na0)   ) DEALLOCATE( rho%na0    )
+   IF (ALLOCATED(rho%na0_nc)) DEALLOCATE( rho%na0_nc )
+   IF (ALLOCATED(rho%ne0)   ) DEALLOCATE( rho%ne0    )
+   IF (ALLOCATED(rho%ne0_nc)) DEALLOCATE( rho%ne0_nc )
+   ! by LSH
    IF (ALLOCATED(rho%bec)  )  DEALLOCATE( rho%bec   )
    !
    RETURN
@@ -331,6 +428,31 @@ CONTAINS
    IF (lda_plus_u_nc)  rho_m%ns_nc  = rho_s%ns_nc
    IF (lda_plus_u_co)  rho_m%ns     = rho_s%ns
    IF (lda_plus_u_cob) rho_m%nsb    = rho_s%nsb
+   ! by LSH
+   IF ( lda_plus_v_co ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rho_m%na0 = rho_s%na0
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rho_m%ne0 = rho_s%ne0
+         ENDIF
+      ELSE
+         rho_m%ne0 = rho_s%ne0
+      ENDIF
+   ENDIF
+   !
+   IF ( lda_plus_v_nc ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rho_m%na0_nc = rho_s%na0_nc
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rho_m%ne0_nc = rho_s%ne0_nc
+         ENDIF
+      ELSE
+         rho_m%ne0_nc = rho_s%ne0_nc
+      ENDIF
+   ENDIF
+   ! by LSH
    IF (okpaw)          rho_m%bec    = rho_s%bec
    !
    IF (dipfield) THEN
@@ -381,6 +503,31 @@ CONTAINS
    IF (lda_plus_u_nc)  rho_s%ns_nc(:,:,:,:) = rho_m%ns_nc(:,:,:,:)
    IF (lda_plus_u_co)  rho_s%ns(:,:,:,:)    = rho_m%ns(:,:,:,:)
    IF (lda_plus_u_cob) rho_s%nsb(:,:,:,:)   = rho_m%nsb(:,:,:,:)
+   ! by LSH
+   IF ( lda_plus_v_co ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rho_s%na0(:,:,:,:) = rho_m%na0(:,:,:,:)
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rho_s%ne0(:,:,:,:,:,:) = rho_m%ne0(:,:,:,:,:,:)
+         ENDIF
+      ELSE
+         rho_s%ne0(:,:,:,:,:,:) = rho_m%ne0(:,:,:,:,:,:)
+      ENDIF
+   ENDIF
+   !
+   IF ( lda_plus_v_nc ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rho_s%na0_nc(:,:,:,:) = rho_m%na0_nc(:,:,:,:)
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rho_s%ne0_nc(:,:,:,:,:,:) = rho_m%ne0_nc(:,:,:,:,:,:)
+         ENDIF
+      ELSE
+         rho_s%ne0_nc(:,:,:,:,:,:) = rho_m%ne0_nc(:,:,:,:,:,:)
+      ENDIF
+   ENDIF
+   ! by LSH
    IF (okpaw)          rho_s%bec(:,:,:)     = rho_m%bec(:,:,:)
    !
    RETURN
@@ -411,6 +558,31 @@ CONTAINS
   IF (lda_plus_u_nc)  Y%ns_nc = X%ns_nc
   IF (lda_plus_u_co)  Y%ns    = X%ns
   IF (lda_plus_u_cob) Y%nsb   = X%nsb
+  ! by LSH
+  IF ( lda_plus_v_co ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           Y%na0 = X%na0
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           Y%ne0 = X%ne0
+        ENDIF
+     ELSE
+        Y%ne0 = X%ne0
+     ENDIF
+  ENDIF
+  !
+  IF ( lda_plus_v_nc ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           Y%na0_nc = X%na0_nc
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           Y%ne0_nc = X%ne0_nc
+        ENDIF
+     ELSE
+        Y%ne0_nc = X%ne0_nc
+     ENDIF
+  ENDIF
+  ! by LSH
   IF (okpaw)          Y%bec   = X%bec
   IF (sic) THEN
      Y%pol_r = X%pol_r
@@ -451,6 +623,31 @@ CONTAINS
   IF (lda_plus_u_nc)           Y%ns_nc     = Y%ns_nc     + A * X%ns_nc
   IF (lda_plus_u_co)           Y%ns        = Y%ns        + A * X%ns
   IF (lda_plus_u_cob)          Y%nsb       = Y%nsb       + A * X%nsb
+  ! by LSH
+  IF ( lda_plus_v_co ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           Y%na0 = Y%na0 + A * X%na0
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           Y%ne0 = Y%ne0 + A * X%ne0
+        ENDIF
+     ELSE
+        Y%ne0 = Y%ne0 + A * X%ne0
+     ENDIF
+  ENDIF
+  !
+  IF ( lda_plus_v_nc ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           Y%na0_nc = Y%na0_nc + A * X%na0_nc
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           Y%ne0_nc = Y%ne0_nc + A * X%ne0_nc
+        ENDIF
+     ELSE
+        Y%ne0_nc = Y%ne0_nc + A * X%ne0_nc
+     ENDIF
+  ENDIF
+  ! by LSH
   IF (okpaw)                   Y%bec       = Y%bec       + A * X%bec
   IF (dipfield)                Y%el_dipole = Y%el_dipole + A * X%el_dipole
   IF (sic)                     Y%pol_g     = Y%pol_g     + A * X%pol_g
@@ -486,6 +683,31 @@ CONTAINS
   IF (lda_plus_u_nc)           Y%ns_nc     = X%ns_nc
   IF (lda_plus_u_co)           Y%ns        = X%ns
   IF (lda_plus_u_cob)          Y%nsb       = X%nsb
+  ! by LSH
+  IF ( lda_plus_v_co ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           Y%na0 = X%na0
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           Y%ne0 = X%ne0
+        ENDIF
+     ELSE
+        Y%ne0 = X%ne0
+     ENDIF
+  ENDIF
+  !
+  IF ( lda_plus_v_nc ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           Y%na0_nc = X%na0_nc
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           Y%ne0_nc = X%ne0_nc
+        ENDIF
+     ELSE
+        Y%ne0_nc = X%ne0_nc
+     ENDIF
+  ENDIF
+  ! by LSH
   IF (okpaw)                   Y%bec       = X%bec
   IF (dipfield)                Y%el_dipole = X%el_dipole
   IF (sic)                     Y%pol_g     = X%pol_g
@@ -522,6 +744,31 @@ CONTAINS
   IF (lda_plus_u_nc)           X%ns_nc     = A * X%ns_nc
   IF (lda_plus_u_co)           X%ns        = A * X%ns
   IF (lda_plus_u_cob)          X%nsb       = A * X%nsb
+  ! by LSH
+  IF ( lda_plus_v_co ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           X%na0 = A * X%na0
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           X%ne0 = A * X%ne0
+        ENDIF
+     ELSE
+        X%ne0 = A * X%ne0
+     ENDIF
+  ENDIF
+  !
+  IF ( lda_plus_v_nc ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           X%na0_nc = A * X%na0_nc
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           X%ne0_nc = A * X%ne0_nc
+        ENDIF
+     ELSE
+        X%ne0_nc = A * X%ne0_nc
+     ENDIF
+  ENDIF
+  ! by LSH
   IF (okpaw)                   X%bec       = A * X%bec
   IF (dipfield)                X%el_dipole = A * X%el_dipole
   IF (sic)                     X%pol_g     = A * X%pol_g
@@ -586,6 +833,32 @@ CONTAINS
    IF (lda_plus_u_co)  rhoin%ns(:,:,:,:)    = 0.d0
    IF (lda_plus_u_cob) rhoin%nsb(:,:,:,:)   = 0.d0
    !
+   ! by LSH
+   IF ( lda_plus_v_co ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rhoin%na0(:,:,:,:) = 0.d0
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rhoin%ne0(:,:,:,:,:,:) = 0.d0
+         ENDIF
+      ELSE
+         rhoin%ne0(:,:,:,:,:,:) = 0.d0
+      ENDIF
+   ENDIF
+   !
+   IF ( lda_plus_v_nc ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rhoin%na0_nc(:,:,:,:) = 0.d0
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rhoin%ne0_nc(:,:,:,:,:,:) = 0.d0
+         ENDIF
+      ELSE
+         rhoin%ne0_nc(:,:,:,:,:,:) = 0.d0
+      ENDIF
+   ENDIF
+   ! by LSH
+   !
    !$acc end data 
    call stop_clock('high_freq_mix') 
    RETURN
@@ -611,6 +884,31 @@ CONTAINS
    IF (lda_plus_u_co)           rlen_ldaU = (2*Hubbard_lmax+1)**2 *nspin*nat
    IF (lda_plus_u_cob)          rlen_ldaUb = (ldmx_b)**2 *nspin*nat
    IF (lda_plus_u_nc)           rlen_ldaU = 2 * (2*Hubbard_lmax+1)**2 *nspin*nat
+   ! by LSH
+   IF ( lda_plus_v_co ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rlen_ldaV = (ehub_lm_max)**2 * nspin * nat
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rlen_ldaV = (ehub_lm_max)**2 * nspin * nat * nat * ehub_nnnc
+         ENDIF
+      ELSE
+         rlen_ldaV = (ehub_lm_max)**2 * nspin * nat * nat * ehub_nnnc
+      ENDIF
+   ENDIF
+   !
+   IF ( lda_plus_v_nc ) THEN
+      IF ( lacbn0 ) THEN
+         IF ( acbn0_type == 1 ) THEN
+            rlen_ldaV = 2 * (ehub_lm_max)**2 * nspin * nat
+         ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+            rlen_ldaV = 2 * (ehub_lm_max)**2 * nspin * nat * nat * ehub_nnnc
+         ENDIF
+      ELSE
+         rlen_ldaV = 2 * (ehub_lm_max)**2 * nspin * nat * nat * ehub_nnnc
+      ENDIF
+   ENDIF
+   ! by LSH
    IF (okpaw)                   rlen_bec  = (nhm*(nhm+1)/2) * nat * nspin
    IF (dipfield)                rlen_dip  = 1
    IF (sic)                     rlen_pol  = 2*ngms*nspin
@@ -622,11 +920,20 @@ CONTAINS
    start_rho    = 1
    start_kin    = start_rho  + rlen_rho / 2
    start_ldaU   = start_kin  + rlen_kin / 2
+   ! by LSH WIY
+   start_ldaV   = start_ldaU + ( rlen_ldaU + 1 ) / 2
+   ! by LSH WIY
    IF (lda_plus_u_cob) THEN
-      start_ldaUb = start_ldaU + ( rlen_ldaU + 1 ) / 2
+    ! by LSH WIY    
+      !start_ldaUb = start_ldaU + ( rlen_ldaU + 1 ) / 2
+      start_ldaUb = start_ldaV + ( rlen_ldaV + 1 ) / 2
       start_bec = start_ldaUb + ( rlen_ldaUb + 1 ) / 2
+    ! by LSH WIY
    ELSE
-      start_bec = start_ldaU + ( rlen_ldaU + 1 ) / 2
+    !  by LSH WIY
+    !  start_bec = start_ldaU + ( rlen_ldaU + 1 ) / 2
+      start_bec    = start_ldaV + ( rlen_ldaV + 1 ) / 2
+    !  by LSH WIY
    ENDIF
    start_dipole = start_bec  + ( rlen_bec + 1 ) / 2
    start_pol    = start_dipole + ( rlen_dip + 1 ) / 2
@@ -686,6 +993,31 @@ CONTAINS
       IF (lda_plus_u_nc)           CALL DCOPY(rlen_ldaU,rho%ns_nc,1,io_buffer(start_ldaU),1)
       IF (lda_plus_u_co)           CALL DCOPY(rlen_ldaU,rho%ns,   1,io_buffer(start_ldaU),1)
       IF (lda_plus_u_cob)          CALL DCOPY(rlen_ldaUb,rho%nsb, 1,io_buffer(start_ldaUb),1)
+      ! by LSH
+      IF ( lda_plus_v_co ) THEN
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               CALL DCOPY(rlen_ldaV, rho%na0, 1, io_buffer(start_ldaV), 1)
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               CALL DCOPY(rlen_ldaV, rho%ne0, 1, io_buffer(start_ldaV), 1)
+            ENDIF
+         ELSE
+            CALL DCOPY(rlen_ldaV, rho%ne0, 1, io_buffer(start_ldaV), 1)
+         ENDIF
+      ENDIF
+      !
+      IF ( lda_plus_v_nc ) THEN
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               CALL DCOPY(rlen_ldaV, rho%na0_nc, 1, io_buffer(start_ldaV), 1)
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               CALL DCOPY(rlen_ldaV, rho%ne0_nc, 1, io_buffer(start_ldaV), 1)
+            ENDIF
+         ELSE
+            CALL DCOPY(rlen_ldaV, rho%ne0_nc, 1, io_buffer(start_ldaV), 1)
+         ENDIF
+      ENDIF
+      ! by LSH
       IF (okpaw)                   CALL DCOPY(rlen_bec, rho%bec,  1,io_buffer(start_bec), 1)
       !
       IF (dipfield) io_buffer(start_dipole) = CMPLX( rho%el_dipole, 0.0_dp, KIND=DP )
@@ -707,6 +1039,31 @@ CONTAINS
       IF (lda_plus_u_co)           CALL DCOPY(rlen_ldaU,io_buffer(start_ldaU),1,rho%ns,   1)
       IF (lda_plus_u_cob)          CALL DCOPY(rlen_ldaUb,io_buffer(start_ldaUb),1,rho%nsb,1)
       IF (lda_plus_u_nc)           CALL DCOPY(rlen_ldaU,io_buffer(start_ldaU),1,rho%ns_nc,1)
+      ! by LSH
+      IF ( lda_plus_v_co ) THEN
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               CALL DCOPY(rlen_ldaV, io_buffer(start_ldaV), 1, rho%na0, 1)
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN 
+               CALL DCOPY(rlen_ldaV, io_buffer(start_ldaV), 1, rho%ne0, 1)
+            ENDIF
+         ELSE
+            CALL DCOPY(rlen_ldaV, io_buffer(start_ldaV), 1, rho%ne0, 1)
+         ENDIF
+      ENDIF
+      !
+      IF ( lda_plus_v_nc ) THEN
+         IF ( lacbn0 ) THEN
+            IF ( acbn0_type == 1 ) THEN
+               CALL DCOPY(rlen_ldaV, io_buffer(start_ldaV), 1, rho%na0_nc, 1)
+            ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+               CALL DCOPY(rlen_ldaV, io_buffer(start_ldaV), 1, rho%ne0_nc, 1)
+            ENDIF
+         ELSE
+            CALL DCOPY(rlen_ldaV, io_buffer(start_ldaV), 1, rho%ne0_nc, 1)
+         ENDIF
+      ENDIF
+      ! by LSH
       IF (okpaw)                   CALL DCOPY(rlen_bec, io_buffer(start_bec), 1,rho%bec,  1)
       !
       IF (dipfield) rho%el_dipole = DBLE( io_buffer(start_dipole) )
@@ -731,6 +1088,9 @@ FUNCTION rho_ddot( rho1, rho2, gf, g0 )
   USE paw_onecenter,   ONLY : paw_ddot
   USE mp_bands,        ONLY : intra_bgrp_comm
   USE mp,              ONLY : mp_sum
+  ! by LSH
+  USE ldaV,            ONLY : lda_plus_v, lacbn0, acbn0_type
+  ! by LSH
   !
   IMPLICIT NONE
   !
@@ -829,6 +1189,19 @@ FUNCTION rho_ddot( rho1, rho2, gf, g0 )
   !
   IF (xclib_dft_is('meta')) rho_ddot = rho_ddot + tauk_ddot( rho1, rho2, gf )
   IF (lda_plus_u )   rho_ddot = rho_ddot + ns_ddot( rho1, rho2 )
+  ! by LSH
+  IF ( lda_plus_v ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           rho_ddot = rho_ddot + ns_ddot_a0(rho1,rho2)
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           rho_ddot = rho_ddot + ns_ddot_v(rho1,rho2)
+        ENDIF
+     ELSE
+        rho_ddot = rho_ddot + ns_ddot_v(rho1,rho2)
+     ENDIF
+  ENDIF
+  ! by LSH
   ! 
   ! Beware: paw_ddot has a hidden parallelization on all processors
   !         it must be called on all processors or else it will hang
@@ -1166,6 +1539,31 @@ SUBROUTINE bcast_scf_type( rho, root, comm )
   IF (lda_plus_u_co)  CALL mp_bcast( rho%ns,    root, comm )
   IF (lda_plus_u_cob) CALL mp_bcast( rho%nsb,   root, comm )
   IF (lda_plus_u_nc)  CALL mp_bcast( rho%ns_nc, root, comm )
+  ! by LSH
+  IF ( lda_plus_v_co ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           CALL mp_bcast (rho%na0, root, comm)
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           CALL mp_bcast (rho%ne0, root, comm)
+        ENDIF
+     ELSE
+        CALL mp_bcast (rho%ne0, root, comm)
+     ENDIF
+  ENDIF
+  !
+  IF ( lda_plus_v_nc ) THEN
+     IF ( lacbn0 ) THEN
+        IF ( acbn0_type == 1 ) THEN
+           CALL mp_bcast (rho%na0_nc, root, comm)
+        ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+           CALL mp_bcast (rho%ne0_nc, root, comm)
+        ENDIF
+     ELSE
+        CALL mp_bcast (rho%ne0_nc, root, comm)
+     ENDIF
+  ENDIF
+  ! by LSH
   IF (okpaw)          CALL mp_bcast( rho%bec,   root, comm )
   IF (sic) THEN
      CALL mp_bcast ( rho%pol_r, root, comm )
@@ -1231,6 +1629,182 @@ SUBROUTINE rhoz_or_updw( rho, sp, dir )
   RETURN
   !
   END SUBROUTINE
+  ! by LSH
   !
   !
+  !---------------------------------------------------------------------------
+FUNCTION ns_ddot_v( rho1, rho2 )
+  !--------------------------------------------------------------------------
+  !
+  ! ... calculates V/2 \sum_i ns1(i)*ns2(i)
+  ! ... used as an estimate of the self-consistency error
+  ! ... on the DFT+U+V correction to the energy
+  !
+  USE kinds,     ONLY : DP
+  USE ldaV,      ONLY : ehub_lm, ehub_v, ehub_nn_dim, &
+                        ehub_nn_vect, ehub_nnnc, ehub_csize
+  USE ions_base, ONLY : nat, ityp
+  USE lsda_mod,  ONLY : nspin
+
+  IMPLICIT NONE
+
+  type(mix_type), INTENT(IN) :: rho1, rho2
+
+  REAL(DP)                   :: ns_ddot_v
+
+  INTEGER                    :: na, na1, na2
+  INTEGER                    :: nt, nt1, nt2
+  INTEGER                    :: m, m1, m2
+  INTEGER                    :: n1, n2, n3, nnc, ics
+
+  ns_ddot_v = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     m = ehub_lm(nt)
+     IF ( m == 0 ) CYCLE
+     !
+     ! WIY
+     IF ( nspin == 4 ) THEN
+        ns_ddot_v = ns_ddot_v + 0.5_DP * ehub_v(na,na,m,m,1) * &
+                SUM( CONJG(rho1%ne0_nc(:m,:m,:nspin,na,na,1)) * &
+                           rho2%ne0_nc(:m,:m,:nspin,na,na,1))
+     ELSE
+        ns_ddot_v = ns_ddot_v + 0.5_DP * ehub_v(na,na,m,m,1) * &
+                          SUM(rho1%ne0(:m,:m,:nspin,na,na,1) * &
+                              rho2%ne0(:m,:m,:nspin,na,na,1))
+     ENDIF
+     ! WIY
+     !
+  ENDDO ! na
+  !
+  ics = ehub_csize + 1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     m1 = ehub_lm(nt1)
+     IF ( m1 == 0 ) CYCLE
+     !
+  DO na2 = 1, nat
+     nt2 = ityp(na2)
+     !
+     m2 = ehub_lm(nt2)
+     IF ( m2 == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     IF ( nspin == 4 ) THEN
+        ns_ddot_v = ns_ddot_v + 0.5_DP * ehub_v(na1,na2,m1,m2,1) * &
+                SUM( CONJG(rho1%ne0_nc(:m1,:m2,:nspin,na1,na2,1)) * &
+                           rho2%ne0_nc(:m1,:m2,:nspin,na1,na2,1))
+     ELSE
+        ns_ddot_v = ns_ddot_v + 0.5_DP * ehub_v(na1,na2,m1,m2,1) * &
+                          SUM(rho1%ne0(:m1,:m2,:nspin,na1,na2,1) * &
+                              rho2%ne0(:m1,:m2,:nspin,na1,na2,1))
+     ENDIF
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        m1 = ehub_lm(nt1)
+        IF ( m1 == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        m2 = ehub_lm(nt2)
+        IF ( m2 == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        IF ( nspin == 4 ) THEN
+           ns_ddot_v = ns_ddot_v + 0.5_DP * ehub_v(na1,na2,m1,m2,nnc) * &
+                   SUM( CONJG(rho1%ne0_nc(:m1,:m2,:nspin,na1,na2,nnc)) * &
+                              rho2%ne0_nc(:m1,:m2,:nspin,na1,na2,nnc))
+        ELSE
+           ns_ddot_v = ns_ddot_v + 0.5_DP * ehub_v(na1,na2,m1,m2,nnc) * &
+                             SUM(rho1%ne0(:m1,:m2,:nspin,na1,na2,nnc) * &
+                                 rho2%ne0(:m1,:m2,:nspin,na1,na2,nnc))
+        ENDIF
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  IF ( nspin == 1 ) ns_ddot_v = 2.0_DP * ns_ddot_v
+  !
+  RETURN
+
+END FUNCTION ns_ddot_v
+!
+!
+!---------------------------------------------------------------------------
+FUNCTION ns_ddot_a0( rho1, rho2 )
+  !--------------------------------------------------------------------------
+  !
+  ! ... calculates U/2 \sum_i ns1(i)*ns2(i)
+  ! ... used as an estimate of the self-consistency error
+  ! ... on the DFT+U correction to the energy
+  !
+  USE kinds,     ONLY : DP
+  USE ldaV,      ONLY : ehub_lm, ehub_u
+  USE ions_base, ONLY : nat, ityp
+  USE lsda_mod,  ONLY : nspin
+
+  IMPLICIT NONE
+
+  type(mix_type), INTENT(IN) :: rho1, rho2
+
+  REAL(DP)                   :: ns_ddot_a0
+
+  INTEGER                    :: na, nt, m1, m2
+
+  ns_ddot_a0 = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     m1 = ehub_lm(nt)
+     m2 = ehub_lm(nt)
+     !
+     IF ( nspin == 4 ) THEN
+        ns_ddot_a0 = ns_ddot_a0 + 0.5_DP * ehub_u(na,m1,m2) * &
+                         SUM(rho1%na0_nc(:m1,:m2,:nspin,na) * &
+                             rho2%na0_nc(:m1,:m2,:nspin,na))
+     ELSE
+        ns_ddot_a0 = ns_ddot_a0 + 0.5_DP * ehub_u(na,m1,m2) * &
+                            SUM(rho1%na0(:m1,:m2,:nspin,na) * &
+                                rho2%na0(:m1,:m2,:nspin,na))
+     ENDIF
+     !
+  ENDDO ! na
+  !
+  IF ( nspin == 1 ) ns_ddot_a0 = 2.0_DP * ns_ddot_a0
+  !
+  RETURN
+
+END FUNCTION ns_ddot_a0
+!
+!--------------------------------------------------------------------------
+! by LSH
 END MODULE scf
diff --git a/PW/src/setup.f90 b/PW/src/setup.f90
index aa3314083..4fe0e3f3c 100644
--- a/PW/src/setup.f90
+++ b/PW/src/setup.f90
@@ -71,6 +71,9 @@ SUBROUTINE setup()
   USE uspp_param,         ONLY : upf
   USE uspp,               ONLY : okvan
   USE ldaU,               ONLY : lda_plus_u, init_hubbard
+  ! by LSH
+  USE ldaV,               ONLY : lda_plus_v, init_lda_plus_v
+  ! by LSH
   USE bp,                 ONLY : gdir, lberry, nppstr, lelfield, lorbm, nx_el,&
                                  nppstr_3d,l3dstring, efield
   USE fixed_occ,          ONLY : f_inp, tfixed_occ, one_atom_occupations
@@ -651,10 +654,15 @@ SUBROUTINE setup()
   ! ... Set up Hubbard parameters for DFT+Hubbard
   !
   CALL init_hubbard ( upf(1:ntyp)%psd, nspin, noncolin )
+  ! by LSH
+  CALL init_lda_plus_v ( noncolin, nspin )
+  ! by LSH
   !
   ! ... initialize d1 and d2 to rotate the spherical harmonics
   !
-  IF (lda_plus_u .or. okpaw .or. (okvan.and.xclib_dft_is('hybrid')) ) CALL d_matrix( d1, d2, d3 )
+  ! by LSH
+  IF (lda_plus_u .or. lda_plus_v .or. okpaw .or. (okvan.and.xclib_dft_is('hybrid')) ) CALL d_matrix( d1, d2, d3 )
+  ! by LSH
   !
   ! ... set parallelization strategy: need an estimate of FFT dimension along z
   !
diff --git a/PW/src/stres_hub_v.f90 b/PW/src/stres_hub_v.f90
new file mode 100644
index 000000000..0eefb8810
--- /dev/null
+++ b/PW/src/stres_hub_v.f90
@@ -0,0 +1,1153 @@
+!
+! Copyright (C) 2002-2020 Quantum ESPRESSO group
+! This file is distributed under the terms of the
+! GNU General Public License. See the file `License'
+! in the root directory of the present distribution,
+! or http://www.gnu.org/copyleft/gpl.txt .
+!
+!
+!----------------------------------------------------------------------
+SUBROUTINE stres_hub_v (sigmah)
+   !----------------------------------------------------------------------
+   ! This routines computes the Hubbard contribution to the internal stress
+   ! tensor. It gives in output the array sigmah(i,j) which corresponds to
+   ! the quantity \( -(1/\omega)dE_h/\epsilon_{i,j} \)
+   !
+   USE kinds,                ONLY : DP
+   USE wavefunctions,        ONLY : evc
+   USE ions_base,            ONLY : nat, ityp, ntyp => nsp
+   USE cell_base,            ONLY : omega, at, bg
+   USE wvfct,                ONLY : nbnd, npwx, wg
+   USE becmod,               ONLY : bec_type, becp, calbec, allocate_bec_type, deallocate_bec_type
+   USE lsda_mod,             ONLY : lsda, nspin, current_spin, isk
+   USE uspp,                 ONLY : nkb, vkb, okvan
+   USE klist,                ONLY : nks, xk, ngk, igk_k
+   USE basis,                ONLY : natomwfc, wfcatom, swfcatom
+   USE io_files,             ONLY : nwordwfc, iunwfc
+   USE buffers,              ONLY : get_buffer
+   USE scf,                  ONLY : v, rho
+   USE lsda_mod,             ONLY : nspin
+   USE symme,                ONLY : symmatrix
+   USE io_global,            ONLY : stdout
+   USE mp_pools,             ONLY : inter_pool_comm, me_pool, nproc_pool
+   USE mp,                   ONLY : mp_sum
+   USE control_flags,        ONLY : gamma_only, offload_type
+   USE ldaU,                 ONLY : Hubbard_projectors
+   USE ldaV,                 ONLY : ehub_lm, ehub_lm_max, ehub_csize,     &
+                                    ehub_nn_vect, ehub_nn_dim, ehub_nnnc, &
+                                    wfcv, nwfcv, ofstv, copy_v_wfc,       &
+                                    ehub_l_choice, ehub_l, acbn0_type
+   USE mp_bands,             ONLY : use_bgrp_in_hpsi, intra_bgrp_comm
+   USE noncollin_module,     ONLY : noncolin, npol
+   USE force_mod,            ONLY : eigenval, eigenvect, overlap_inv, at_dy, &
+                                    at_dj, us_dy, us_dj
+   USE uspp_init,            ONLY : init_us_2, gen_us_dj, gen_us_dy 
+   IMPLICIT NONE
+   !
+   ! the Hubbard contribution to stresses
+   !
+   REAL(DP), INTENT(OUT) :: sigmah(3,3) 
+   !
+   ! ... local variables
+   !
+   TYPE(bec_type) :: proj
+   COMPLEX(DP), ALLOCATABLE :: proj_nc(:,:)
+
+   INTEGER :: ipol, jpol, is, ik, npw, i
+   INTEGER :: m1, m2, na1, na2, nt1, nt2
+   INTEGER :: ics, nnc
+   INTEGER :: n1, n2, n3
+   INTEGER :: nb_s, nb_e, mykey
+   INTEGER :: ehub_l_max_
+   INTEGER :: ehub_l_choice_(ntyp,6)
+   INTEGER :: ehub_lm_(ntyp)
+
+   REAL(DP) :: xyz(3,3)
+
+   COMPLEX(DP), ALLOCATABLE :: dns(:,:,:,:,:,:)
+   COMPLEX(DP), ALLOCATABLE :: spsi(:,:)
+   LOGICAL :: save_flag
+   !
+   CALL start_clock('stres_hub_v')
+   !
+   save_flag = use_bgrp_in_hpsi ; use_bgrp_in_hpsi = .false.
+   !
+   IF ( Hubbard_projectors /= "ortho-atomic" ) CALL errore("stres_hub", &
+                   "stress for this Hubbard_projectors type not implemented",1)
+   IF( .NOT.(acbn0_type == 2 .or. acbn0_type == 3)) CALL errore("stres_hub_v", &
+         " acbn0_type should be assigned to 2 or 3 ",1)
+   IF( gamma_only ) CALL errore("stres_hub_v", " gamma_only calculation is not implemented ",1)
+   !
+   ehub_l_max_ = MAXVAL(ehub_l(:,:))
+   ehub_l_choice_ = ehub_l_choice
+   ehub_lm_ = ehub_lm
+   sigmah(:,:) = 0.D0
+   !
+   ALLOCATE ( wfcatom(npwx*npol,natomwfc) )
+   ALLOCATE ( spsi(npwx*npol,nbnd) )
+   ALLOCATE ( at_dy(npwx*npol,natomwfc), at_dj(npwx*npol, natomwfc))
+   IF (okvan) ALLOCATE (us_dy(npwx,nkb), us_dj(npwx,nkb))
+   ALLOCATE ( swfcatom(npwx*npol, natomwfc))
+   ALLOCATE ( eigenval(natomwfc))
+   ALLOCATE ( eigenvect(natomwfc, natomwfc))
+   ALLOCATE ( overlap_inv(natomwfc,natomwfc))
+   !
+   IF (noncolin) THEN
+     ALLOCATE( proj_nc(nwfcv, nbnd))
+   ELSE
+     CALL allocate_bec_type(nwfcv, nbnd, proj)
+   ENDIF
+   !
+   ! poor-man parallelization over bands
+   ! - if nproc_pool=1     : nb_s=1, nb_e=nbnd, mykey=0
+   ! - if nproc_pool<=nbnd : each processor calculates band nb_s to nb_e; mykey=0
+   ! - if nproc_pool>nbnd  : each processor takes care of band na_s=nb_e;
+   !   mykey labels how many times each band appears (mykey=0 first time etc.)
+   !
+   CALL block_distribute(nbnd, me_pool, nproc_pool, nb_s, nb_e, mykey)
+   !
+   ALLOCATE ( dns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc) )
+   !
+   ics = ehub_csize + 1
+   !
+   ! We start a loop on k points
+   !
+   DO ik = 1, nks
+      !
+      IF ( lsda ) current_spin = isk(ik)
+      npw = ngk(ik)
+      !
+      IF ( nks > 1 ) CALL get_buffer(evc, nwordwfc, iunwfc, ik)
+      !
+      CALL init_us_2(npw, igk_k(1,ik), xk(1,ik), vkb, .TRUE.)
+      CALL allocate_bec_type ( nkb, nbnd, becp)
+      CALL calbec(offload_type, npw, vkb, evc, becp)
+      CALL s_psi(npwx, npw, nbnd, evc, spsi)
+      CALL deallocate_bec_type(becp)
+      !
+      CALL orthowfcv2(ik)
+      ! proj=<wfcv|S|evc> - no need to read S*wfcv from buffer
+      IF (noncolin) THEN
+         CALL ZGEMM ('C', 'N', nwfcv, nbnd, npwx*npol, (1.0_DP, 0.0_DP), wfcv, &
+                    npwx*npol, spsi, npwx*npol, (0.0_DP, 0.0_DP),  proj_nc, nwfcv)
+         CALL mp_sum( proj_nc( :, 1:nbnd ), intra_bgrp_comm )
+      ELSE
+         !$acc data create(proj)
+         CALL calbec(offload_type, npw, wfcv, spsi, proj)
+         !$acc update self(projkd)
+         !$acc end data
+      ENDIF
+      !
+      ! Compute derivatives of spherical harmonics and spherical Bessel fnctions
+      !
+      ! xyz are three unit vectors in the x,y,z, directions
+      xyz(:,:) = 0.d0
+      DO i =1,3
+        xyz(i,i) = 1.d0
+      ENDDO
+      ! The derivative of spherical Bessel functions (for atomic functions)
+      CALL gen_at_dj ( ik, at_dj)
+      ! The derivative of spherical Bessel functions (for beta functions)
+      IF (okvan) CALL gen_us_dj( ik, us_dj)
+      !
+      ! NB: both ipol and jpol must run from 1 to 3 because this stress
+      !     contribution is not in general symmetric when computed only
+      !     from k-points in the irreducible wedge of the BZ.
+      !     It is (must be) symmetric after symmetrization but this requires
+      !     the full stress tensor not only its upper triangular part.
+      !
+      DO ipol = 1, 3
+      !
+      ! The derivative of the spherical harmonic
+      !
+      CALL gen_at_dy (ik, xyz(1,ipol), at_dy)
+      ! The derivative of spherical harmonics (for beta functions)
+      IF ( okvan) CALL gen_us_dy (ik, xyz(1,ipol), us_dy)
+      !
+      DO jpol = 1, 3
+         !
+         ! Compute the derivative of the occupation matrix w.r.t epsilon
+         !
+         IF ( noncolin ) THEN
+            CALL dndepsilon_k_v(ipol,jpol,proj_nc,spsi,ik,nb_s,nb_e,mykey,dns)
+         ELSE
+            CALL dndepsilon_k_v(ipol,jpol,proj%k,spsi,ik,nb_s,nb_e,mykey,dns)
+         ENDIF
+         !
+         DO is = 1, nspin
+            DO na1 = 1, nat
+               nt1 = ityp(na1)
+               !
+               IF ( ehub_lm(nt1) == 0 ) CYCLE
+               !
+            DO na2 = 1, nat
+               nt2 = ityp(na2)
+               !
+               IF ( ehub_lm(nt2) == 0 ) CYCLE
+               !
+               DO m1 = 1, ehub_lm(nt1)
+               DO m2 = 1, ehub_lm(nt2)
+                  !
+                  IF (noncolin) THEN
+                     sigmah(ipol,jpol) = sigmah(ipol,jpol) &
+                                       - DBLE(v%ne0_nc(m1,m2,is,na1,na2,1) &
+                                       * dns(m1,m2,is,na1,na2,1))
+                  ELSE
+                     sigmah(ipol,jpol) = sigmah(ipol,jpol) &
+                                       - DBLE(v%ne0(m1,m2,is,na1,na2,1) &
+                                       * dns(m1,m2,is,na1,na2,1))
+                  ENDIF
+                  !
+               ENDDO ! m2
+               ENDDO ! m1
+               !
+            ENDDO ! na2
+            ENDDO ! na1
+            !
+            nnc = 2
+            !
+            DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+            DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+            DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+               !
+               IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+               !
+               DO na1 = 1, nat
+                  nt1 = ityp(na1)
+                  !
+                  IF ( ehub_lm(nt1) == 0 ) CYCLE
+                  !
+               DO na2 = 1, nat
+                  nt2 = ityp(na2)
+                  !
+                  IF ( ehub_lm(nt2) == 0 ) CYCLE
+                  !
+                  IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2 ) == 0 ) CYCLE
+                  !
+                  DO m1 = 1, ehub_lm(nt1)
+                  DO m2 = 1, ehub_lm(nt2)
+                     !
+                     IF (noncolin) THEN
+                        sigmah(ipol,jpol) = sigmah(ipol,jpol)  &
+                                          - DBLE(v%ne0_nc(m1,m2,is,na1,na2,nnc) &
+                                          * dns(m1,m2,is,na1,na2,nnc))
+                     ELSE
+                        sigmah(ipol,jpol) = sigmah(ipol,jpol)  &
+                                          - DBLE(v%ne0(m1,m2,is,na1,na2,nnc) &
+                                          * dns(m1,m2,is,na1,na2,nnc))
+                     ENDIF
+                     !
+                  ENDDO ! m2
+                  ENDDO ! m1
+                  !
+               ENDDO ! na2
+               ENDDO ! na1
+               !
+               IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+               !
+            ENDDO ! n3
+            ENDDO ! n2
+            ENDDO ! n1
+            !
+         ENDDO ! is
+         ! 
+      ENDDO ! jpol
+      ENDDO ! ipol
+      !
+   ENDDO ! ik
+   !
+   CALL mp_sum(sigmah, inter_pool_comm)
+   !
+   sigmah(:,:) = sigmah(:,:) / omega
+   !
+   IF ( nspin == 1 ) sigmah(:,:) = 2.D0 * sigmah(:,:)
+   !
+   ! Symmetrization
+   ! 
+   CALL symmatrix(sigmah)
+   !
+   ! Impose symmetry s(i,j) = s(j,i) to the stress tensor.
+   ! It should NOT be needed, but let us do it for safety.
+   !
+   DO ipol = 1, 3
+   DO jpol = ipol, 3
+      IF ( ABS(sigmah(ipol,jpol)-sigmah(jpol,ipol)) > 1.D-6 ) THEN
+         WRITE ( stdout,'(2i3,2f12.7)' ) ipol,jpol,sigmah(ipol,jpol), &
+                                                   sigmah(jpol,ipol)
+         CALL errore('stres_hub_v','non-symmetric stress contribution',1)
+      ENDIF
+      sigmah(ipol,jpol) = 0.5D0 * (sigmah(ipol,jpol) + sigmah(jpol,ipol))
+      sigmah(jpol,ipol) = sigmah(ipol,jpol)
+   ENDDO
+   ENDDO
+   !
+   IF (noncolin) THEN
+     DEALLOCATE(proj_nc)
+   ELSE
+     CALL deallocate_bec_type(proj)
+   ENDIF
+   IF ( ALLOCATED(dns) )  DEALLOCATE (dns)
+   DEALLOCATE ( wfcatom )
+   DEALLOCATE ( spsi )
+   DEALLOCATE ( at_dy, at_dj)
+   IF (okvan) DEALLOCATE (us_dy, us_dj)
+   DEALLOCATE ( swfcatom)
+   DEALLOCATE ( eigenval)
+   DEALLOCATE ( eigenvect)
+   DEALLOCATE ( overlap_inv)
+   !
+   use_bgrp_in_hpsi = save_flag
+   !
+   CALL stop_clock('stres_hub_v')
+   !
+   RETURN
+   !
+END  SUBROUTINE stres_hub_v
+!
+!
+SUBROUTINE dndepsilon_k_v (ipol,jpol,proj,spsi,ik,nb_s,nb_e,mykey,dns)
+   !-----------------------------------------------------------------------
+   ! This routine computes the derivative of the ns atomic occupations with
+   ! respect to the strain epsilon(ipol,jpol) used to obtain the generalized
+   ! Hubbard contribution to the internal stres tensor.
+   !
+   USE kinds,             ONLY : DP
+   USE constants,         ONLY : tpi
+   USE ions_base,         ONLY : nat, ityp
+   USE cell_base,         ONLY : at
+   USE klist,             ONLY : ngk, xk
+   USE lsda_mod,          ONLY : nspin, current_spin
+   USE wvfct,             ONLY : nbnd, npwx, wg
+   USE becmod,            ONLY : bec_type, allocate_bec_type, deallocate_bec_type
+   USE mp_pools,          ONLY : intra_pool_comm
+   USE mp,                ONLY : mp_sum
+   USE ldaV,              ONLY : ehub_lm, ehub_lm_max, ehub_csize,     &
+                                 ehub_nn_vect, ehub_nn_dim, ehub_nnnc, &
+                                 nwfcv, ofstv, ehub_l, counter_lm
+   USE noncollin_module,  ONLY : noncolin, npol
+
+   IMPLICIT NONE
+   !
+   ! I/O variables
+   !
+   INTEGER, INTENT(IN)       :: ipol, jpol, ik
+   INTEGER, INTENT(IN)       :: nb_s, nb_e, mykey
+
+   COMPLEX (DP), INTENT(IN)  :: proj(nwfcv,nbnd)
+   COMPLEX (DP), INTENT(IN)  :: spsi(npwx*npol,nbnd)
+
+   COMPLEX (DP), INTENT(OUT) :: dns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+   !
+   ! ... local variables
+   !
+   TYPE (bec_type)           :: dproj
+   COMPLEX(DP), ALLOCATABLE  :: dproj_nc(:,:)
+
+   COMPLEX(DP)               :: kphase
+
+   REAL(DP)                  :: arg
+
+   INTEGER                   :: ibnd, is, npw
+   INTEGER                   :: ics, nnc
+   INTEGER                   :: m1, m2
+   INTEGER                   :: na1, na2, nt1, nt2
+   INTEGER                   :: n1, n2, n3
+   INTEGER                   :: is1, is2
+   !
+   IF (noncolin) THEN
+     ALLOCATE (dproj_nc(nwfcv, nbnd))
+   ELSE
+     CALL allocate_bec_type (nwfcv, nbnd, dproj)
+   ENDIF
+   !
+   ! D_Sl for l=1 and l=2 are already initialized, for l=0 D_S0 is 1
+   !
+   ! Offset of atomic wavefunctions initialized in setup and stored in oatwfc
+   !
+   dns(:,:,:,:,:,:) = (0.0_dp, 0.0_dp)
+   !
+   npw = ngk(ik)
+   !
+   ! Calculate the first derivative of proj with respect to epsilon(ipol,jpol)
+   !
+   IF (noncolin) THEN
+     CALL dprojdepsilon_k_v (spsi, ik, ipol, jpol, nb_s, nb_e, mykey, dproj_nc)
+   ELSE
+     CALL dprojdepsilon_k_v (spsi, ik, ipol, jpol, nb_s, nb_e, mykey, dproj%k)
+   ENDIF
+   !
+   ! Band parallelization. If each band appears more than once
+   ! compute its contribution only once (i.e. when mykey=0)
+   !
+
+   ics = ehub_csize +1
+
+   IF ( mykey /= 0 ) GO TO 10
+   !
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = 1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO m1 = 1, ehub_lm(nt1)
+      DO m2 = 1, ehub_lm(nt2)
+         !
+         DO ibnd = nb_s, nb_e
+            !
+            IF (noncolin) THEN
+               !
+               DO is1 = 1, npol
+               DO is2 = 1, npol
+                  dns(m1,m2,npol*(is1-1)+is2,na1,na2,1) = &
+                  dns(m1,m2,npol*(is1-1)+is2,na1,na2,1) + &
+                  wg(ibnd,ik) * &
+              dcmplx(proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) &
+           * CONJG(dproj_nc(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd)) + &
+                   dproj_nc(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) &
+           * CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd)))
+               ENDDO ! is2
+               ENDDO ! is1
+               !
+            ELSE
+               dns(m1,m2,current_spin,na1,na2,1) = &
+               dns(m1,m2,current_spin,na1,na2,1) + &
+                                     wg(ibnd,ik) * &
+                     ((proj(ofstv(na2)+m2,ibnd)) * CONJG(dproj%k(ofstv(na1)+m1,ibnd)) + &
+                   (dproj%k(ofstv(na2)+m2,ibnd)) * CONJG(proj(ofstv(na1)+m1,ibnd)))
+            ENDIF
+         ENDDO !ibnd
+         !
+      ENDDO ! m2
+      ENDDO ! m1
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      arg = tpi * (                                              &
+       xk(1,ik) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+       xk(2,ik) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+       xk(3,ik) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+      !
+      kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            DO ibnd = nb_s, nb_e
+              IF (noncolin) THEN
+                DO is1 = 1, npol
+                DO is2 = 1, npol
+                   dns(m1,m2,npol*(is1-1)+is2,na1,na2,nnc) = &
+                   dns(m1,m2,npol*(is1-1)+is2,na1,na2,nnc) + &
+                   wg(ibnd,ik) * dcmplx( kphase *( &
+                   proj(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) &
+           * CONJG(dproj_nc(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd)) + &
+                   dproj_nc(ofstv(na2)+m2+counter_lm(m2,nt2)+(2*(ehub_l(m2,nt2)-1)+1)*(is2-1),ibnd) &
+           * CONJG(proj(ofstv(na1)+m1+counter_lm(m1,nt1)+(2*(ehub_l(m1,nt1)-1)+1)*(is1-1),ibnd))))
+                ENDDO ! is2
+                ENDDO ! is1
+              ELSE
+                dns(m1,m2,current_spin,na1,na2,nnc) = &
+                dns(m1,m2,current_spin,na1,na2,nnc) + &
+                          kphase*wg(ibnd,ik) * &
+                        ((proj(ofstv(na2)+m2,ibnd)) * CONJG(dproj%k(ofstv(na1)+m1,ibnd)) + &
+                      (dproj%k(ofstv(na2)+m2,ibnd)) * CONJG(proj(ofstv(na1)+m1,ibnd)))
+              ENDIF
+            ENDDO ! ibnd
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+10 CALL mp_sum(dns, intra_pool_comm)
+   !
+   ! In nspin=1 k-point weight wg is normalized to 2 el/band
+   ! in the whole BZ but we are interested in dnsg of one spin component
+   !
+   IF ( nspin == 1 ) dns = 0.5D0 * dns
+   !
+   IF (noncolin) THEN
+     DEALLOCATE(dproj_nc)
+   ELSE
+     CALL deallocate_bec_type (dproj)
+   ENDIF
+   !
+   RETURN
+   !
+END SUBROUTINE dndepsilon_k_v
+!
+SUBROUTINE dprojdepsilon_k_v (spsi, ik, ipol, jpol, nb_s, nb_e, mykey, dproj)
+   !-----------------------------------------------------------------------
+   ! This routine computes the first derivative of the projection
+   ! \( \langle\phi^{at}_{I,m1}|S|\psi_{k,v,s}\rangle \)
+   ! with respect to the strain \( \epsilon(i,j) \).
+   !
+   ! We remember that: $$ \text{ns}_{I,s,m_1,m_2} = \sum_{k,v}
+   ! f_{kv} \langle\phi^{at}_{I,m1}|S|\psi_{k,v,s}\rangle
+   ! \langle\psi_{k,v,s}|S|\phi^{at}_{I,m2}\rangle $$
+   !
+   USE kinds,                ONLY : DP
+   USE cell_base,            ONLY : tpiba
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp
+   USE gvect,                ONLY : g
+   USE klist,                ONLY : nks, xk, igk_k, ngk
+   USE ldaV,                 ONLY : wfcv, nwfcv, ofst, ofstv, ehub_lm
+   USE lsda_mod,             ONLY : lsda, nspin, isk
+   USE wvfct,                ONLY : nbnd, npwx, wg
+   USE uspp,                 ONLY : nkb, vkb, qq_at, okvan
+   USE uspp_param,           ONLY : upf, nhm, nh
+   USE wavefunctions,        ONLY : evc
+   USE becmod,               ONLY : becp, calbec
+   USE basis,                ONLY : natomwfc, wfcatom, swfcatom
+   USE force_mod,            ONLY : eigenval, eigenvect, overlap_inv, at_dy, &
+   at_dj
+   USE mp_bands,             ONLY : intra_bgrp_comm
+   USE mp,                   ONLY : mp_sum
+   USE noncollin_module,     ONLY : noncolin, npol
+   USE control_flags,        ONLY : offload_type
+
+   IMPLICIT NONE
+   !
+   ! I/O variables 
+   !
+   COMPLEX(DP), INTENT(IN)  :: spsi(npwx*npol,nbnd)
+   !! S|evc>
+   INTEGER, INTENT(IN) :: ik
+   !! k-point index
+   INTEGER, INTENT(IN) :: ipol
+   !! component index 1 to 3
+   INTEGER, INTENT(IN) :: jpol
+   !! component index 1 to 3
+   INTEGER, INTENT(IN) :: nb_s
+   !! band number start
+   INTEGER, INTENT(IN) :: nb_e
+   !! band number end
+   INTEGER, INTENT(IN) :: mykey
+   !! labels how many times each band appears (mykey=0 first time etc.)  
+   COMPLEX(DP), INTENT(OUT) :: dproj(nwfcv,nbnd)
+   !
+   ! ... local variables
+   !
+   INTEGER                   :: na, nt
+   INTEGER                   :: i, ibnd
+   INTEGER                   :: ig, ijkb0, ih, jh, iwf, npw, m1, m2
+
+
+   REAL(DP)                  :: q, a1, a2
+
+   REAL(DP), PARAMETER       :: eps = 1.0D-8
+
+   COMPLEX (DP), ALLOCATABLE :: &
+       dproj0(:,:),      & ! derivative of the projector
+       dproj_us(:,:),    & ! USPP contribution to dproj0
+       dwfc(:,:),        & ! the derivative of the (ortho-atomic) wavefunction
+       doverlap(:,:),    & ! derivative of the overlap matrix
+       doverlap_us(:,:), & ! USPP contribution to doverlap
+       doverlap_inv(:,:)   ! derivative of (O^{-1/2})_JI (note the transposition)
+   !
+   REAL (DP), ALLOCATABLE    :: &
+       gk(:,:), & ! k+G
+       qm1(:),  & ! 1/|k+G|
+       a1_temp(:), a2_temp(:)
+   COMPLEX (DP) :: temp, temp2
+   !
+   ! Number of plane waves at the k point with the index ik
+   npw = ngk(ik)
+   !
+   dproj(:,:) = (0.D0, 0.D0)
+   !
+   ! At first the derivatives of the atomic wfcs: we compute the term
+   ! <d\fi^{at}_{I,m1}/d\epsilon(ipol,jpol)|S|\psi_{k,v,s}>
+   !
+   ALLOCATE ( qm1(npwx), gk(3,npwx) )
+   ALLOCATE ( dwfc(npwx*npol,nwfcv) )
+   ALLOCATE (a1_temp(npw), a2_temp(npw))
+   dwfc(:,:) = (0.d0, 0.d0)
+   !
+   DO ig = 1, npw
+      !
+      gk(1,ig) = (xk(1,ik) + g(1,igk_k(ig,ik))) * tpiba
+      gk(2,ig) = (xk(2,ik) + g(2,igk_k(ig,ik))) * tpiba
+      gk(3,ig) = (xk(3,ik) + g(3,igk_k(ig,ik))) * tpiba
+      !
+      q = SQRT(gk(1,ig)**2 + gk(2,ig)**2 + gk(3,ig)**2)
+      !
+      IF ( q > eps ) THEN
+         qm1(ig) = 1.D0/q
+      ELSE
+         qm1(ig) = 0.D0
+      ENDIF
+      !
+      ! (k+G)_jpol
+      a1_temp(ig) = -gk(jpol,ig)
+      !
+      ! (k+G)_ipol * (k+G)_jpol / |k+G|
+      a2_temp(ig) = -gk(ipol,ig) * gk(jpol,ig) * qm1(ig)
+      !
+   ENDDO !ig
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      IF(ehub_lm(nt) >= 1) THEN 
+          DO m1 = 1, ehub_lm(nt)*npol
+             DO ig = 1, npw
+                temp = (0.0_DP, 0.0_DP)
+                temp2 = (0.0_DP, 0.0_DP)
+                DO m2 = 1, natomwfc
+                   temp = temp + overlap_inv(ofst(na)+m1,m2) * &
+                       ( at_dy(ig,m2) * a1_temp(ig) + at_dj(ig,m2) * a2_temp(ig) )
+                   IF (noncolin) temp2 = temp2 + overlap_inv(ofst(na)+m1,m2) * &
+                            ( at_dy(ig+npwx,m2) * a1_temp(ig) + at_dj(ig+npwx,m2) * a2_temp(ig) )
+                ENDDO !m2
+                dwfc(ig, ofstv(na)+m1) = dwfc(ig, ofstv(na)+m1) + temp
+                IF (noncolin) dwfc(ig+npwx, ofstv(na)+m1) = &
+                         dwfc(ig+npwx, ofstv(na)+m1) + temp2
+             ENDDO !ig
+          ENDDO !m1
+      ENDIF
+   ENDDO !na 
+   !
+   ! The diagonal term
+   IF ( ipol == jpol ) THEN
+      dwfc(1:npw,:) = dwfc(1:npw,:) - wfcv(1:npw,:) * 0.5D0
+      IF (noncolin) dwfc(1+npwx:npwx+npw,:) = dwfc(1+npwx:npwx+npw,:) - wfcv(1+npwx:npwx+npw,:) * 0.5D0
+   ENDIF
+   !
+   ! 2. Contribution due to the derivative of (O^{-1/2})_JI which
+   !    is multiplied by atomic wavefunctions (only for ortho-atomic case)
+   !
+   !
+   ! Compute the derivative dO_IJ/d\epsilon(ipol,jpol)
+   !
+   ALLOCATE (doverlap(natomwfc,natomwfc))
+   ALLOCATE (doverlap_inv(natomwfc,natomwfc))
+   doverlap(:,:) = (0.0_DP, 0.0_DP)
+   doverlap_inv(:,:) = (0.0_DP, 0.0_DP)
+   !
+   ! Calculate:
+   ! doverlap = < dphi_I/d\epsilon(ipol,jpol) | S | phi_J > 
+   !            + < phi_I | S | dphi_J/d\epsilon(ipol,jpol) >
+   !
+   DO m2 = 1, natomwfc
+      DO m1 = 1, natomwfc
+         temp = (0.0_DP,0.0_DP)
+         temp2 = (0.0_DP,0.0_DP)
+         DO ig = 1, npw
+            temp = temp + CONJG((at_dy(ig,m1)*a1_temp(ig) + at_dj(ig,m1)*a2_temp(ig))) * swfcatom(ig,m2) &
+                        + CONJG(swfcatom(ig,m1)) * (at_dy(ig,m2)*a1_temp(ig) + at_dj(ig,m2)*a2_temp(ig))
+            IF (noncolin) THEN
+               temp2 = temp2 + CONJG((at_dy(ig+npwx,m1)*a1_temp(ig) + at_dj(ig+npwx,m1)*a2_temp(ig))) * swfcatom(ig+npwx,m2) &
+                             + CONJG(swfcatom(ig+npwx,m1)) * (at_dy(ig+npwx,m2)*a1_temp(ig) + at_dj(ig+npwx,m2)*a2_temp(ig))
+            ENDIF
+         ENDDO
+         doverlap(m1,m2) = doverlap(m1,m2) + temp
+         IF (noncolin) doverlap(m1,m2) = doverlap(m1,m2) + temp2
+      ENDDO
+   ENDDO
+   !
+   IF (ipol.EQ.jpol) THEN
+      DO m2 = 1, natomwfc
+         DO m1 = 1, natomwfc
+            temp = (0.0_DP,0.0_DP)
+            temp2 = (0.0_DP,0.0_DP)
+            !$acc parallel loop reduction(+:temp)
+            DO ig = 1, npw
+               temp = temp + CONJG((-wfcatom(ig,m1)*0.5d0)) * swfcatom(ig,m2) &
+                           + CONJG(swfcatom(ig,m1)) * (-wfcatom(ig,m2)*0.5d0)
+               IF (noncolin) THEN
+                  temp2 = temp2 + CONJG((-wfcatom(ig+npwx,m1)*0.5d0)) * swfcatom(ig+npwx,m2) &
+                           + CONJG(swfcatom(ig+npwx,m1)) * (-wfcatom(ig+npwx,m2)*0.5d0)
+               ENDIF
+            ENDDO
+            doverlap(m1,m2) = doverlap(m1,m2) + temp
+            IF (noncolin) doverlap(m1,m2) = doverlap(m1,m2) + temp2
+         ENDDO
+      ENDDO
+   ENDIF        
+   !
+   ! Sum over G vectors
+   CALL mp_sum( doverlap, intra_bgrp_comm )
+   !
+   ! USPP term in dO_IJ/d\epsilon(ipol,jpol)
+   !
+   IF (okvan) THEN
+      ! Calculate doverlap_us = < phi_I | dS/d\epsilon(ipol,jpol) | phi_J >
+      ALLOCATE (doverlap_us(natomwfc,natomwfc))
+      CALL matrix_element_of_dSdepsilon_v (ik, ipol, jpol, &
+           natomwfc, wfcatom, natomwfc, wfcatom, doverlap_us, 1, natomwfc, 0, .false.)
+      ! Sum up the "normal" and ultrasoft terms
+      DO m1 = 1, natomwfc
+         DO m2 = 1, natomwfc
+            doverlap(m1,m2) = doverlap(m1,m2) + doverlap_us(m1,m2)
+         ENDDO
+      ENDDO
+      DEALLOCATE (doverlap_us)
+   ENDIF
+   !
+   ! Now compute dO^{-1/2}_JI/d\epsilon(ipol,jpol) using dO_IJ/d\epsilon(ipol,jpol)
+   ! Note the transposition!
+   ! 
+   CALL calculate_doverlap_inv (natomwfc, eigenval, eigenvect, &
+                                  doverlap, doverlap_inv)
+   !
+   ! Now compute \sum_J dO^{-1/2}_JI/d\epsilon(ipol,jpol) \phi_J
+   ! and add it to another term (see above)
+   ! Note, doverlap_inv is d(O^{-1/2}) not transposed. The transposition
+   ! of d(O^{-1/2}) is taken into account via a proper usage of the order
+   ! of indices in doverlap_inv:
+   ! dwfc(ig,ofst(na)+m1) = dwfc(ig,ofst(na)+m1) + wfcatom(ig,m2) * doverlap_inv(m2,ofst(na)+m1)
+   ! where m1=1,ehub_lm(nt); m2=1,natomwfc; ig=1,npw
+   !
+   !DO na = 1, nat
+   !   nt = ityp(na)
+   !   IF (ehub_lm(nt) >= 1 ) THEN
+   !      !DO m1 = 1, ehub_lm(nt)
+   !      !   DO m2 = 1, natomwfc
+   !      !      DO ig = 1, npw
+   !      !         dwfc(ig,ofstv(na)+m1) = dwfc(ig,ofstv(na)+m1) + &
+   !      !                       doverlap_inv(ofst(na)+m1,m2) * wfcatom(ig,m2)
+   !      !      ENDDO !ig
+   !      !   ENDDO !m2
+   !      !ENDDO !m1
+   !      CALL ZGEMM('N','N', npw, ehub_lm(nt), natomwfc, (1.d0,0.d0), &
+   !           wfcatom, npwx, doverlap_inv(:,ofst(na)+1:ofst(na)+ehub_lm(nt)), &
+   !           natomwfc, (1.d0,0.d0), dwfc(:,ofstv(na)+1:ofstv(na)+ehub_lm(nt)), npwx)
+   !   ENDIF
+   !ENDDO !na
+   !
+   DO na = 1, nat
+      nt = ityp(na)
+      IF (ehub_lm(nt) >= 1) THEN
+         CALL MYZGEMM('N','N', npwx*npol, ehub_lm(nt)*npol, natomwfc, (1.d0,0.d0), &
+               wfcatom, npwx*npol, doverlap_inv(:,ofst(na)+1:ofst(na)+ehub_lm(nt)*npol), &
+               natomwfc, (1.d0,0.d0), dwfc(:,ofstv(na)+1:ofstv(na)+ehub_lm(nt)*npol), npwx*npol)
+      ENDIF
+   ENDDO
+   !
+   DEALLOCATE (doverlap)
+   DEALLOCATE (doverlap_inv)
+   !
+   ! Compute dproj = <dwfc|S|psi> = <dwfc|spsi>
+   IF (noncolin) THEN
+      CALL ZGEMM('C','N', nwfcv, nbnd, npwx*npol, (1.d0,0.d0), &
+            dwfc, npwx*npol, spsi, npwx*npol, (0.d0,0.d0), &
+            dproj, nwfcv)   
+      CALL mp_sum( dproj, intra_bgrp_comm )
+   ELSE   
+      CALL calbec( offload_type, npw, dwfc, spsi, dproj )
+   ENDIF
+   !
+   DEALLOCATE ( dwfc, qm1, gk)
+   DEALLOCATE(a1_temp, a2_temp)
+   !
+   ! Now the derivatives of the beta functions: we compute the term
+   ! <\phi^{at}_{I,m1}|dS/d\epsilon(ipol,jpol)|\psi_{k,v,s}>
+   !
+   IF (okvan) THEN
+      ALLOCATE(dproj_us(nwfcV,nb_s:nb_e))
+      CALL matrix_element_of_dSdepsilon_v (ik, ipol, jpol, &
+                         nwfcv, wfcv, nbnd, evc, dproj_us, nb_s, nb_e, mykey, .true.)
+      ! dproj + dproj_us
+      DO m1 = 1, nwfcv
+         dproj(m1,nb_s:nb_e) = dproj(m1,nb_s:nb_e) + dproj_us(m1,:)
+      ENDDO
+      DEALLOCATE(dproj_us)
+   ENDIF
+   !
+   RETURN
+   !
+END SUBROUTINE dprojdepsilon_k_v
+!
+SUBROUTINE matrix_element_of_dSdepsilon_v (ik, ipol, jpol, lA, A, lB, B, A_dS_B, lB_s, lB_e, mykey, flag)
+   !
+   ! This routine computes the matrix element < A | dS/d\epsilon(ipol,jpol) | B >
+   ! Written by I. Timrov (2020)
+   !
+   ! Compute the term <\fi^{at}_{I,m1}|dS/d\epsilon(ipol,jpol)|\psi_{k,v,s}>
+   !
+   USE kinds,                ONLY : DP
+   USE ions_base,            ONLY : nat, ntyp => nsp, ityp
+   USE cell_base,            ONLY : tpiba
+   USE gvect,                ONLY : g
+   USE wvfct,                ONLY : npwx, wg
+   USE uspp,                 ONLY : nkb, vkb, qq_at, qq_so, okvan
+   USE uspp_param,           ONLY : nh, upf
+   USE wavefunctions,        ONLY : evc
+   USE becmod,               ONLY : calbec
+   USE control_flags,        ONLY : offload_type
+   USE klist,                ONLY : xk, igk_k, ngk
+   USE force_mod,            ONLY : us_dy, us_dj
+   USE mp_bands,             ONLY : intra_bgrp_comm
+   USE mp,                   ONLY : mp_sum
+   USE noncollin_module,     ONLY : noncolin, npol
+   USE ldav,                 ONLY : ofstv, ehub_lm, ehub_l, counter_lm
+   !
+   IMPLICIT NONE
+   !
+   ! Input/Output
+   !
+   INTEGER, INTENT(IN)      :: ik          ! k point
+   INTEGER, INTENT(IN)      :: ipol, jpol  ! Cartesian components
+   INTEGER, INTENT(IN)      :: lA, lB, lB_s, lB_e
+   ! There is a possibility to parallelize over lB,
+   ! where lB_s (start) and lB_e (end)
+   LOGICAL, INTENT(IN)      :: flag  ! noncollinear: controlling whether 
+                                     ! calculating <phi|dS|PSI> 
+                                     ! or          <phi|dS|PHI> (= .true.)   
+   COMPLEX(DP), INTENT(IN)  :: A(npwx*npol,lA)
+   COMPLEX(DP), INTENT(IN)  :: B(npwx*npol,lB)
+   COMPLEX(DP), INTENT(OUT) :: A_dS_B(lA,lB_s:lB_e)
+   INTEGER,     INTENT(IN)  :: mykey
+   !
+   ! Local variables
+   !
+   INTEGER :: npw, i, nt, na, nb, ih, jh, ig, iA, iB, ijkb0, mU, mD, nt1, nt2, is1
+   REAL(DP) :: gvec
+   COMPLEX (DP), ALLOCATABLE :: Adbeta(:,:), Abeta(:,:), &
+                                dbetaB(:,:), betaB(:,:), &
+                                aux(:,:), qq(:,:)
+   REAL (DP) :: q, a1, a2
+   REAL (DP), PARAMETER :: eps = 1.0d-8
+   REAL (DP), ALLOCATABLE :: gk(:,:), qm1(:)
+   INTEGER :: nh_nt
+   REAL (DP), ALLOCATABLE :: a1_temp(:), a2_temp(:)
+   !
+   IF (.NOT.okvan) RETURN
+   !
+   !$acc data present_or_copyin(A,B) present_or_copyout(A_ds_B)
+   !
+   !$acc kernels
+   A_dS_B(:,:) = (0.0d0, 0.0d0)
+   !$acc end kernels
+   npw = ngk(ik)
+   !
+   ALLOCATE ( qm1(npwx), gk(3,npwx) )
+   ALLOCATE (a1_temp(npw), a2_temp(npw))
+   !
+   ! Compute k+G and 1/|k+G|
+   DO ig = 1, npw
+      DO i = 1, 3
+         gk(i,ig) = (xk(i,ik) + g(i,igk_k(ig,ik))) * tpiba
+      ENDDO
+      q = SQRT(gk(1,ig)**2 + gk(2,ig)**2 + gk(3,ig)**2)
+      IF (q.GT.eps) THEN
+         qm1(ig)=1.d0/q
+      ELSE
+         qm1(ig)=0.d0
+      ENDIF
+      a1_temp(ig) = -gk(jpol,ig)
+      a2_temp(ig) = -gk(ipol,ig)*gk(jpol,ig)*qm1(ig)
+   ENDDO
+   !
+   ijkb0 = 0
+   !
+   !$acc data copyin(us_dj, qq_at, a1_temp, a2_temp)
+   DO nt = 1, ntyp
+      !
+      ALLOCATE ( Adbeta(lA,npol*nh(nt)) )
+      ALLOCATE ( Abeta(lA,npol*nh(nt)) )
+      ALLOCATE ( dbetaB(npol*nh(nt),lB) )
+      ALLOCATE ( betaB(npol*nh(nt),lB) )
+      ALLOCATE ( qq(npol*nh(nt),npol*nh(nt)) )
+      !
+      nh_nt = nh(nt)
+      !$acc data create(Adbeta,Abeta,dbetaB,betaB,qq)
+      !
+      DO na = 1, nat
+         !
+         IF ( ityp(na).EQ.nt ) THEN
+            !
+            IF (noncolin) THEN
+               IF ( upf(nt)%has_so ) THEN
+                  qq(1:nh(nt),1:nh(nt)) = qq_so(:,:,1,nt)
+                  qq(1:nh(nt),1+nh(nt):nh(nt)*npol) = qq_so(:,:,2,nt)
+                  qq(1+nh(nt):nh(nt)*npol,1:nh(nt)) = qq_so(:,:,3,nt)
+                  qq(1+nh(nt):nh(nt)*npol,1+nh(nt):nh(nt)*npol) = qq_so(:,:,4,nt)
+               ELSE
+                  qq(1:nh(nt),1:nh(nt)) = qq_at(1:nh(nt),1:nh(nt),na)
+                  qq(1:nh(nt),1+nh(nt):nh(nt)*npol) = (0.0,0.0)
+                  qq(1+nh(nt):nh(nt)*npol,1:nh(nt)) = (0.0,0.0)
+                  qq(1+nh(nt):nh(nt)*npol,1+nh(nt):nh(nt)*npol) = qq_at(1:nh(nt),1:nh(nt),na)
+               ENDIF
+            ELSE
+               !$acc parallel loop collapse(2) 
+               DO jh = 1, nh_nt 
+                  DO ih = 1, nh_nt
+                     qq(ih,jh) = CMPLX(qq_at(ih,jh,na), 0.0d0, kind=DP)
+                  ENDDO
+               ENDDO
+            ENDIF
+            !
+            ! aux is used as a workspace
+            ALLOCATE ( aux(npwx*npol,nh(nt)*npol) )
+            !$acc data create(aux)
+            aux=(0.0,0.0)
+            !
+            !$acc parallel loop collapse(2) 
+            DO ih = 1, nh_nt !nh(nt)
+               ! now we compute the true dbeta function
+               DO ig = 1, npw
+                  aux(ig,ih) = us_dy(ig,ijkb0+ih) * a1_temp(ig) + us_dj(ig,ijkb0+ih) * a2_temp(ig)
+                  IF (noncolin) aux(ig+npwx,ih+nh(nt)) = us_dy(ig,ijkb0+ih) * a1_temp(ig) &
+                                                + us_dj(ig,ijkb0+ih) * a2_temp(ig)  
+               ENDDO
+            ENDDO
+            !
+            IF (ipol.EQ.jpol) THEN
+               !$acc parallel loop collapse(2)
+               DO ih = 1, nh_nt !nh(nt)
+                  DO ig = 1, npw
+                     aux(ig,ih) = aux(ig,ih) - vkb(ig,ijkb0+ih)*0.5d0
+                     IF (noncolin) aux(ig+npwx,ih+nh(nt)) = aux(ig+npwx,ih+nh(nt)) &
+                                   - vkb(ig,ijkb0+ih)*0.5d0
+                  ENDDO
+               ENDDO   
+            ENDIF 
+            IF (noncolin) THEN
+               ! Calculate betaB = <dbeta|B>
+               ! dbetaB(:,1       : nh(nt))      = spin up
+               ! dbetaB(:,1+nh(nt): nh(nt)*npol) = spin down
+               dbetaB=(0.0,0.0)
+               CALL ZGEMM ('C', 'N', nh(nt)*npol, lB, npwx*npol, (1.0_DP, 0.0_DP), aux, &
+                          npwx*npol, B, npwx*npol, (0.0_DP, 0.0_DP), dbetaB, nh(nt)*npol)
+               CALL mp_sum( dbetaB(:, 1:lB) , intra_bgrp_comm )               
+               !
+               ! Calculate Adbeta = <A|dbeta>
+               ! Adbeta(:,1       : nh(nt))      = spin up
+               ! Adbeta(:,1+nh(nt): nh(nt)*npol) = spin down      
+               Adbeta=(0.0,0.0)
+               CALL ZGEMM ('C', 'N', lA, nh(nt)*npol, npwx*npol, (1.0_DP, 0.0_DP), A, &
+                          npwx*npol, aux, npwx*npol, (0.0_DP, 0.0_DP), Adbeta, lA)
+               CALL mp_sum( Adbeta(:, 1:nh(nt)*npol) , intra_bgrp_comm )
+            ELSE        
+               ! Calculate dbetaB = <dbeta|B> 
+               CALL calbec(offload_type, npw, aux, B, dbetaB )
+               !
+               ! Calculate Adbeta = <A|dbeta>
+               CALL calbec(offload_type, npw, A, aux, Adbeta )
+            ENDIF   
+            !
+            ! aux is now used as a work space to store vkb
+            !$acc parallel loop collapse(2)
+            DO ih = 1, nh_nt  !nh(nt)
+               DO ig = 1, npw
+                  aux(ig,ih) = vkb(ig,ijkb0+ih)
+                  IF (noncolin) aux(ig+npwx,ih+nh(nt)) = vkb(ig,ijkb0+ih)
+               ENDDO
+            ENDDO
+            !
+            IF (noncolin) THEN
+                ! Calculate Abeta = <A|beta>      
+                ! (same as Adbeta)
+                !
+                Abeta=(0.0,0.0)
+                CALL ZGEMM ('C', 'N', lA, nh(nt)*npol, npwx*npol, (1.0_DP, 0.0_DP), A, &
+                           npwx*npol, aux, npwx*npol, (0.0_DP, 0.0_DP), Abeta, lA)
+                CALL mp_sum( Abeta(:, 1:nh(nt)*npol) , intra_bgrp_comm )
+                !
+                ! Calculate betaB = <beta|B>
+                ! (same as dbetaB)
+                !
+                betaB=(0.0,0.0)
+                CALL ZGEMM ('C', 'N', nh(nt)*npol, lB, npwx*npol, (1.0_DP, 0.0_DP), aux, &
+                           npwx*npol, B, npwx*npol, (0.0_DP, 0.0_DP), betaB, nh(nt)*npol)
+                CALL mp_sum( betaB(:, 1:lB) , intra_bgrp_comm )
+             ELSE
+               ! Calculate Abeta = <A|beta>
+               CALL calbec( offload_type, npw, A, aux, Abeta )
+               !
+               ! Calculate betaB = <beta|B>
+               CALL calbec( offload_type, npw, aux, B, betaB )
+             ENDIF
+            !
+            !$acc end data
+            DEALLOCATE ( aux )
+            !
+            ALLOCATE ( aux(nh(nt)*npol, lB) )
+            !$acc data create(aux)
+            aux(:,:)=(0.0,0.0)            
+            !
+            IF (noncolin) THEN
+               ! aux(:, 1:nh(nt))             = \sum_jh qq(1,jh)*dbetaB(1,jh) + qq(2,jh)*dbetaB(2,jh)
+               ! aux(:, 1+nh(nt):nh(nt)*npol) = \sum_jh qq(3,jh)*dbetaB(1,jh) + qq(4,jh)*dbetaB(2,jh)
+               !
+               ! spin up
+               CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                          qq(1, 1), nh(nt)*npol, &
+                          dbetaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                          aux(1, lB_s), nh(nt)*npol)
+               ! spin down   
+               CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                          qq(1+nh(nt), 1), nh(nt)*npol, &
+                          dbetaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                          aux(1+nh(nt), lB_s), nh(nt)*npol)
+            ELSE
+               ! Calculate \sum_jh qq_at(ih,jh) * dbetaB(jh)     
+               !$acc host_data use_device(qq,dbetaB,aux)
+               CALL MYZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                            qq, nh(nt), dbetaB(1,lB_s),    nh(nt), (0.0d0,0.0d0), &
+                            aux(1,lB_s), nh(nt))
+               !$acc end host_data
+            ENDIF
+            !$acc kernels
+            dbetaB(:,:) = aux(:,:)
+            !$acc end kernels
+            !
+            IF (noncolin) THEN
+               ! (same as dbetaB)     
+               !
+               ! spin up 
+               CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                          qq(1, 1), nh(nt)*npol, &
+                          betaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                          aux(1, lB_s), nh(nt)*npol)
+               ! spin down   
+               CALL ZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                          qq(1+nh(nt), 1), nh(nt)*npol, &
+                          betaB(1, lB_s), nh(nt)*npol, (0.0d0,0.0d0), &
+                          aux(1+nh(nt), lB_s), nh(nt)*npol)
+            ELSE
+               ! Calculate \sum_jh qq_at(ih,jh) * betaB(jh)
+               !$acc host_data use_device(qq,betaB,aux)
+               CALL MYZGEMM('N', 'N', nh(nt), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                            qq, nh(nt), betaB(1,lB_s),     nh(nt), (0.0d0,0.0d0), &
+                            aux(1,lB_s), nh(nt))
+              !$acc end host_data
+            ENDIF
+            !
+            !$acc kernels
+            betaB(:,:) = aux(:,:)
+            !$acc end kernels
+            !
+            !$acc end data
+            DEALLOCATE ( aux )
+            !
+            ijkb0 = ijkb0 + nh(nt)
+            !
+            ! A_dS_B(iA,iB) = \sum_ih [Adbeta(iA,ih) * betapsi(ih,iB) +
+            !                          Abeta(iA,ih)  * dbetaB(ih,iB)] 
+            ! Only A_dS_B(:,lB_s:lB_e) are calculated
+            !
+            IF ( mykey == 0 ) THEN
+               IF (noncolin) THEN
+                  nt1 = nh(nt) + 1
+                  IF ( flag ) THEN
+                     DO nb = 1, nat
+                        nt2 = ityp(nb)
+                        IF ( ehub_lm(nt2) > 0 ) THEN
+                           mU = ofstv(nb) + 1
+                           mD = mU + ehub_lm(nt2)
+                           !
+                           ! actually, if we consider more than one Hubard channel, the order of wfcatom is
+                           ! 121112221111122222.... (1: spin up, 2: spin down) 
+                           ! temp
+                           DO ih = 1, ehub_lm(nt2)
+                             DO jh = lB_s, lB_e
+                               DO ig = 1, nh(nt)
+                                 DO is1 = 1, npol
+                                   A_dS_B(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), jh) &
+                                 = A_dS_B(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), jh) &
+                                 + Adbeta(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), &
+                                   ig+nh(nt)*(is1-1)) * betaB(ig+nh(nt)*(is1-1), jh) &
+                                 + Abeta(mU-1+ih+counter_lm(ih,nt2)+(2*(ehub_l(ih,nt2)-1)+1)*(is1-1), &
+                                   ig+nh(nt)*(is1-1)) * dbetaB(ig+nh(nt)*(is1-1), jh) 
+                                 ENDDO
+                               ENDDO
+                             ENDDO
+                           ENDDO
+                           ! temp
+                           !! spin up
+                           !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                           !            Adbeta(mU,1), lA, &
+                           !            betaB(1, lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                           !            A_dS_B(mU, lB_s), lA)
+                           !CALL ZGEMM('N', 'N', ehub_lm(nt2)), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                           !         Abeta(mU,1), lA, &
+                           !         dbetaB(1, lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                           !         A_dS_B(mU, lB_s), lA)
+                           !! spin down
+                           !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                           !            Adbeta(mD, nt1), lA, &
+                           !            betaB(nt1, lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                           !            A_dS_B(mD,lB_s), lA)
+                           !CALL ZGEMM('N', 'N', ehub_lm(nt2), lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                           !            Abeta(mD, nt1), lA, &
+                           !            dbetaB(nt1, lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                           !            A_dS_B(mD,lB_s), lA)
+                        ENDIF ! ehub_lm
+                     ENDDO
+                  ELSEIF ( .not. flag ) THEN
+                     CALL ZGEMM('N', 'N', lA, lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                                  Adbeta, lA, betaB(1,lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                                  A_dS_B(1,lB_s), lA)
+                     CALL ZGEMM('N', 'N', lA, lB_e-lB_s+1, nh(nt)*npol, (1.0d0,0.0d0), &
+                                  Abeta, lA, dbetaB(1,lB_s), nh(nt)*npol, (1.0d0,0.0d0), &
+                                  A_dS_B(1,lB_s), lA)
+                  ENDIF ! flag
+               ELSE
+                  !$acc host_data use_device(Adbeta,betaB,Abeta,dbetaB,A_dS_B)      
+                  CALL MYZGEMM('N', 'N', lA, lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                             Adbeta, lA, betaB(1,lB_s), nh(nt), (1.0d0,0.0d0), &
+                             A_dS_B(1,lB_s), lA)
+                  CALL MYZGEMM('N', 'N', lA, lB_e-lB_s+1, nh(nt), (1.0d0,0.0d0), &
+                             Abeta, lA, dbetaB(1,lB_s), nh(nt), (1.0d0,0.0d0), &
+                             A_dS_B(1,lB_s), lA)
+                  !$acc end host_data   
+                  !
+               ENDIF !noncolin
+            ENDIF ! mykey
+         ENDIF
+         !
+      ENDDO
+      !
+      !$acc end data
+      DEALLOCATE (dbetaB, betaB, Abeta, Adbeta, qq)
+      ! 
+   ENDDO
+   !$acc end data
+   !
+   DEALLOCATE (a1_temp, a2_temp)
+   DEALLOCATE ( qm1, gk )
+   !
+   !$acc end data
+   !
+   RETURN
+   !
+END SUBROUTINE matrix_element_of_dSdepsilon_v
+
diff --git a/PW/src/stress.f90 b/PW/src/stress.f90
index d212be839..936952ff0 100644
--- a/PW/src/stress.f90
+++ b/PW/src/stress.f90
@@ -20,6 +20,9 @@ SUBROUTINE stress( sigma )
   USE gvect,            ONLY : ngm, gstart, g, gg, gcutm, gl
   USE fft_base,         ONLY : dfftp
   USE ldaU,             ONLY : lda_plus_u, Hubbard_projectors
+  ! by LSH
+  USE ldaV,             ONLY : lda_plus_v
+  ! by LSH
   USE lsda_mod,         ONLY : nspin
   USE scf,              ONLY : rho, rho_core, rhog_core
   USE control_flags,    ONLY : iverbosity, gamma_only, llondon, ldftd3, lxdm, &
@@ -165,6 +168,9 @@ SUBROUTINE stress( sigma )
   !
   sigmah(:,:) = 0.d0
   IF ( lda_plus_u .AND. Hubbard_projectors /= 'pseudo' ) CALL stres_hub( sigmah )
+  ! by LSH
+  IF ( lda_plus_v .AND. Hubbard_projectors /= 'pseudo' ) CALL stres_hub_v( sigmah )
+  ! by LSH
   !
   ! ... Electric field contribution
   !
diff --git a/PW/src/sum_band.f90 b/PW/src/sum_band.f90
index dfd6771e2..9041e0a63 100644
--- a/PW/src/sum_band.f90
+++ b/PW/src/sum_band.f90
@@ -24,6 +24,9 @@ SUBROUTINE sum_band()
   USE gvecs,                ONLY : doublegrid
   USE klist,                ONLY : nks, nkstot, wk, xk, ngk, igk_k
   USE ldaU,                 ONLY : lda_plus_u, lda_plus_u_kind, is_hubbard_back
+  ! by LSH
+  USE ldaV,                 ONLY : lda_plus_v, lacbn0, acbn0_type
+  ! by LSH
   USE lsda_mod,             ONLY : lsda, nspin, current_spin, isk
   USE scf,                  ONLY : rho, rhoz_or_updw
   USE sic_mod,              ONLY : isp, pol_type
@@ -148,6 +151,35 @@ SUBROUTINE sum_band()
        !
     ENDIF
   ENDIF
+  ! by LSH WIY
+  IF ( lda_plus_v ) THEN
+    IF ( noncolin ) THEN
+       IF ( lacbn0 ) THEN
+!          IF ( acbn0_type == 1 ) THEN
+!             CALL new_ns_a0_nc(rho%na0_nc)
+           IF ( acbn0_type == 2 ) THEN
+             CALL new_ns_e0_nc_1(rho%ne0_nc)
+!          ELSEIF ( acbn0_type == 3 ) THEN
+!             CALL new_ns_e0_nc_2(rho%ne0_nc)
+          ENDIF
+       ELSE
+           CALL new_ns_v_nc(rho%ne0_nc)
+       ENDIF
+    ELSE
+        IF ( lacbn0 ) THEN
+           IF ( acbn0_type == 1 ) THEN
+              CALL new_ns_a0(rho%na0)
+           ELSEIF ( acbn0_type == 2 ) THEN
+              CALL new_ns_e0_1(rho%ne0)
+           ELSEIF ( acbn0_type == 3 ) THEN
+              CALL new_ns_e0_2(rho%ne0)
+           ENDIF
+        ELSE
+           CALL new_ns_v(rho%ne0)
+        ENDIF
+    ENDIF
+  ENDIF
+  ! by LSH WIY
 #if defined (__OSCDFT)
   IF (use_oscdft) CALL oscdft_sum_band(oscdft_ctx)
 #endif
diff --git a/PW/src/update_pot.f90 b/PW/src/update_pot.f90
index 8f4386011..b3b7f14d7 100644
--- a/PW/src/update_pot.f90
+++ b/PW/src/update_pot.f90
@@ -386,6 +386,9 @@ SUBROUTINE extrapolate_charge( dirname, rho_extr )
   USE lsda_mod,             ONLY : lsda, nspin
   USE scf,                  ONLY : rho, rho_core, rhog_core, v
   USE ldaU,                 ONLY : eth
+  ! by LSH
+  USE ldaV,                 ONLY : ehubene
+  ! by LSH
   USE ener,                 ONLY : ehart, etxc, vtxc, epaw
   USE extfield,             ONLY : etotefield
   USE cellmd,               ONLY : lmovecell, omega_old
@@ -591,7 +594,9 @@ SUBROUTINE extrapolate_charge( dirname, rho_extr )
   CALL rho_r2g (dfftp, rho%of_r, rho%of_g )
   !
   CALL v_of_rho( rho, rho_core, rhog_core, &
-                 ehart, etxc, vtxc, eth, etotefield, charge, v )
+                 ! by LSH
+                 ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+                 ! by LSH
   IF (okpaw) CALL PAW_potential(rho%bec, ddd_PAW, epaw)
   !
   IF ( ABS( charge - nelec ) / charge > 1.D-7 ) THEN
diff --git a/PW/src/v_hubbard_v.f90 b/PW/src/v_hubbard_v.f90
new file mode 100644
index 000000000..e96522ce8
--- /dev/null
+++ b/PW/src/v_hubbard_v.f90
@@ -0,0 +1,368 @@
+SUBROUTINE v_hubbard_v( ns, v_hub, ehubene ) 
+
+  USE kinds,         ONLY : DP
+  USE ions_base,     ONLY : nat, ityp
+  USE ldaV,          ONLY : ehub_lm_max, ehub_lm,   &
+                            ehub_v, ehub_nn_vect,   &
+                            ehub_nn_dim, ehub_nnnc, &
+                            ehub_csize
+  USE lsda_mod,      ONLY : nspin
+  USE control_flags, ONLY : iverbosity
+  USE io_global,     ONLY : stdout
+
+  IMPLICIT NONE
+
+  REAL(DP), INTENT(IN)  :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+  REAL(DP), INTENT(OUT) :: v_hub(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+  REAL(DP), INTENT(OUT) :: ehubene
+
+  INTEGER :: is
+  INTEGER :: na1, na2, nt1, nt2, m1, m2
+  INTEGER :: n1, n2, n3, nnc, ics
+
+  v_hub = 0.0_DP
+  ehubene = 0.0_DP
+  !
+  ics = ehub_csize + 1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+     DO is = 1, nspin
+        !
+        DO m1 = 1, ehub_lm(nt1)
+           !
+           ehubene = ehubene + 0.5_DP*ehub_v(na1,na1,m1,m1,1)*ns(m1,m1,is,na1,na1,1)
+           v_hub(m1,m1,is,na1,na1,1) = v_hub(m1,m1,is,na1,na1,1) + 0.5_DP*ehub_v(na1,na1,m1,m1,1)
+           !
+           DO m2 = 1, ehub_lm(nt1)
+              !
+              ehubene = ehubene - &
+                        0.5_DP*ehub_v(na1,na1,m1,m2,1)*ns(m1,m2,is,na1,na1,1)*ns(m2,m1,is,na1,na1,1)
+              v_hub(m1,m2,is,na1,na1,1) = v_hub(m1,m2,is,na1,na1,1) - ehub_v(na1,na1,m1,m2,1)*ns(m2,m1,is,na1,na1,1)
+              !
+           ENDDO ! m2
+           !
+        ENDDO ! m1
+        !
+     ENDDO ! is
+     !
+  ENDDO ! na1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     IF ( ehub_lm(nt1) == 0 ) CYCLE
+     !
+  DO na2 = 1, nat
+     nt2 = ityp(na2)
+     !
+     IF ( ehub_lm(nt2) == 0 ) CYCLE
+     !
+     IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+     !
+     DO is = 1, nspin
+        !
+        DO m1 = 1, ehub_lm(nt1)
+        DO m2 = 1, ehub_lm(nt2)
+           !
+           ehubene = ehubene - &
+                     0.5_DP*ehub_v(na1,na2,m1,m2,1)*ns(m1,m2,is,na1,na2,1)*ns(m2,m1,is,na2,na1,1)
+           v_hub(m1,m2,is,na1,na2,1) = v_hub(m1,m2,is,na1,na2,1) - ehub_v(na1,na2,m1,m2,1)*ns(m2,m1,is,na2,na1,1)
+           !
+        ENDDO ! m2
+        ENDDO ! m1
+        !
+     ENDDO ! is
+     !
+  ENDDO ! na2
+  ENDDO ! na1
+  !
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        IF ( ehub_lm(nt1) == 0 ) CYCLE
+        !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        IF ( ehub_lm(nt2) == 0 ) CYCLE
+        !
+        IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+        !
+        DO is = 1, nspin
+           !
+           DO m1 = 1, ehub_lm(nt1)
+           DO m2 = 1, ehub_lm(nt2)
+              ! NOTE: ns* = ns
+              ehubene = ehubene - &
+                        0.5_DP*ehub_v(na1,na2,m1,m2,nnc)*ns(m1,m2,is,na1,na2,nnc)*ns(m1,m2,is,na1,na2,nnc)
+              v_hub(m1,m2,is,na1,na2,nnc) = v_hub(m1,m2,is,na1,na2,nnc) - ehub_v(na1,na2,m1,m2,nnc)*ns(m1,m2,is,na1,na2,nnc)
+              !
+           ENDDO ! m2
+           ENDDO ! m1
+           !
+        ENDDO ! is
+        !
+     ENDDO ! na2
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  IF ( nspin == 1 ) ehubene = 2.0_DP * ehubene
+  !
+  IF ( iverbosity > 0 ) THEN
+     WRITE ( stdout,             * ) ''
+     WRITE ( stdout,             * ) '    ========================='
+     WRITE ( stdout, '(a,f12.9,a)' ) '     E(+U+V) = ', ehubene, ' Ry'
+     WRITE ( stdout,             * ) '    ========================='
+  ENDIF
+  !
+  RETURN
+
+END SUBROUTINE v_hubbard_v
+!
+SUBROUTINE v_hubbard_a0( ns, v_hub, ehubene )
+
+  USE kinds,         ONLY : DP
+  USE ions_base,     ONLY : nat, ityp
+  USE ldaV,          ONLY : ehub_lm_max, ehub_lm, ehub_u
+  USE lsda_mod,      ONLY : nspin
+  USE control_flags, ONLY : iverbosity
+  USE io_global,     ONLY : stdout
+
+  IMPLICIT NONE
+
+  REAL(DP), INTENT(IN)  :: ns(ehub_lm_max,ehub_lm_max,nspin,nat)
+  REAL(DP), INTENT(OUT) :: v_hub(ehub_lm_max,ehub_lm_max,nspin,nat)
+  REAL(DP), INTENT(OUT) :: ehubene
+
+  INTEGER :: is
+  INTEGER :: na, nt, m1, m2
+
+  v_hub = 0.0_DP
+  ehubene = 0.0_DP
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     IF ( ehub_lm(nt) == 0 ) CYCLE
+     !
+     DO is = 1, nspin
+        !
+        DO m1 = 1, ehub_lm(nt)
+           !
+           ehubene = ehubene + 0.5_DP*ehub_u(na,m1,m1)*ns(m1,m1,is,na)
+           v_hub(m1,m1,is,na) = v_hub(m1,m1,is,na) + 0.5_DP*ehub_u(na,m1,m1)
+           !
+           DO m2 = 1, ehub_lm(nt)
+              !
+              ehubene = ehubene - &
+                        0.5_DP*ehub_u(na,m1,m2)*ns(m1,m2,is,na)*ns(m2,m1,is,na)
+              v_hub(m1,m2,is,na) = v_hub(m1,m2,is,na) - ehub_u(na,m1,m2)*ns(m2,m1,is,na)
+              !
+           ENDDO ! m2
+           !
+        ENDDO ! m1
+        !
+     ENDDO ! is
+     !
+  ENDDO ! na
+  !
+  IF ( nspin == 1 ) ehubene = 2.0_DP * ehubene
+  !
+  IF ( iverbosity > 0 ) THEN
+     WRITE ( stdout,             * ) ''
+     WRITE ( stdout,             * ) '    ======================='
+     WRITE ( stdout, '(a,f12.9,a)' ) '     E(+U) = ', ehubene, ' Ry'
+     WRITE ( stdout,             * ) '    ======================='
+  ENDIF
+  !
+  RETURN
+
+END SUBROUTINE v_hubbard_a0
+!
+! WIY
+SUBROUTINE v_hubbard_v_nc( ns, v_hub, ehubene ) 
+   !
+   !! Computes the extended Hubbard potential and energy (noncollinear case)
+   !
+   USE kinds,              ONLY : DP
+   USE ions_base,          ONLY : nat, ityp
+   USE noncollin_module,   ONLY : noncolin
+   USE ldaV,               ONLY : ehub_lm_max, ehub_lm,   &
+                                  ehub_v, ehub_nn_vect,   &
+                                  ehub_nn_dim, ehub_nnnc, &
+                                  ehub_csize
+   USE lsda_mod,           ONLY : nspin
+   USE control_flags,      ONLY : iverbosity
+   USE io_global,          ONLY : stdout
+   !
+   IMPLICIT NONE
+   !
+   COMPLEX(DP), INTENT(IN)  :: ns(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+   !! Occupation matrix
+   COMPLEX(DP), INTENT(OUT) :: v_hub(ehub_lm_max,ehub_lm_max,nspin,nat,nat,ehub_nnnc)
+   !! Hubbard potential
+   REAL(DP), INTENT(OUT) :: ehubene
+   !! Hubbard energy
+   !
+   ! ... local variables
+   !
+   INTEGER :: is, is_prime
+   INTEGER :: na1, na2, nt1, nt2, m1, m2
+   INTEGER :: n1, n2, n3, nnc, ics
+   !REAL(DP) :: mx, my, mz, mag2
+   !COMPLEX(DP) :: n_tot
+   !
+   v_hub = 0.0_DP
+   ehubene = 0.0_DP
+   !
+   ics = ehub_csize + 1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      ! u_matrix in plus_u_full.f90 means <m,m''|V_ee|m',m'''> = \sum(ak*Fk)
+      ! In simplied formular, u_matrix can be replaced with the averaged Hubbard parameters.
+      !
+      DO is = 1, nspin ! is = 1 -> upup, 2 -> updown, 3 -> downup, 4 -> downdown
+         ! Following from Physical Review B 102, 155117 (2020)
+         !
+         IF (is == 2) THEN 
+            is_prime = 3
+         ELSEIF (is == 3) THEN 
+            is_prime = 2
+         ELSE
+            is_prime = is
+         ENDIF
+         !
+         DO m1 = 1, ehub_lm(nt1)
+            !
+            IF ( is_prime == is ) THEN
+               ehubene = ehubene + 0.5_DP*ehub_v(na1,na1,m1,m1,1)*DBLE(ns(m1,m1,is,na1,na1,1))
+               v_hub(m1,m1,is,na1,na1,1) = v_hub(m1,m1,is,na1,na1,1) + 0.5_DP*ehub_v(na1,na1,m1,m1,1)
+            ENDIF
+            !
+            DO m2 = 1, ehub_lm(nt1)
+               !
+               ehubene = ehubene - 0.5_DP*ehub_v(na1,na1,m1,m2,1) &
+                                    *DBLE(ns(m1,m2,is,na1,na1,1)*ns(m2,m1,is_prime,na1,na1,1))
+               v_hub(m1,m2,is,na1,na1,1) = v_hub(m1,m2,is,na1,na1,1) &
+                                          & - ehub_v(na1,na1,m1,m2,1)*ns(m2,m1,is_prime,na1,na1,1)
+               !
+            ENDDO ! m2
+            !
+         ENDDO ! m1
+         !
+      ENDDO ! is
+      !
+   ENDDO ! na1
+   !
+   DO na1 = 1, nat
+      nt1 = ityp(na1)
+      !
+      IF ( ehub_lm(nt1) == 0 ) CYCLE
+      !
+   DO na2 = 1, nat
+      nt2 = ityp(na2)
+      !
+      IF ( ehub_lm(nt2) == 0 ) CYCLE
+      !
+      IF ( ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+      !
+      DO is = 1, nspin
+         !
+         IF (is == 2) THEN 
+            is_prime = 3
+         ELSEIF (is == 3) THEN 
+            is_prime = 2
+         ELSE
+            is_prime = is
+         ENDIF
+         !
+         DO m1 = 1, ehub_lm(nt1)
+         DO m2 = 1, ehub_lm(nt2)
+            !
+            ehubene = ehubene - 0.5_DP*ehub_v(na1,na2,m1,m2,1) &
+                              & *DBLE(ns(m1,m2,is,na1,na2,1)*ns(m2,m1,is_prime,na2,na1,1))
+            v_hub(m1,m2,is,na1,na2,1) = v_hub(m1,m2,is,na1,na2,1) &
+                                       & - ehub_v(na1,na2,m1,m2,1)*ns(m2,m1,is_prime,na2,na1,1)
+            !
+         ENDDO ! m2
+         ENDDO ! m1
+         !
+      ENDDO ! is
+      !
+   ENDDO ! na2
+   ENDDO ! na1
+   !
+   nnc = 2
+   !
+   DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+   DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+   DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+      !
+      IF( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+      !
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         IF ( ehub_lm(nt1) == 0 ) CYCLE
+         !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         IF ( ehub_lm(nt2) == 0 ) CYCLE
+         !
+         IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+         !
+         DO is = 1, nspin
+            !
+            DO m1 = 1, ehub_lm(nt1)
+            DO m2 = 1, ehub_lm(nt2)
+               ehubene = ehubene - 0.5_DP*ehub_v(na1,na2,m1,m2,nnc) & 
+                                 & *DBLE(ns(m1,m2,is,na1,na2,nnc)*CONJG(ns(m1,m2,is,na1,na2,nnc)))
+               v_hub(m1,m2,is,na1,na2,nnc) = v_hub(m1,m2,is,na1,na2,nnc) &
+                                            & - ehub_v(na1,na2,m1,m2,nnc)*CONJG(ns(m1,m2,is,na1,na2,nnc))
+               !
+            ENDDO ! m2
+            ENDDO ! m1
+            !
+         ENDDO ! is
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+      !
+   ENDDO ! n3
+   ENDDO ! n2
+   ENDDO ! n1
+   !
+   IF ( iverbosity > 0 ) THEN
+      WRITE ( stdout,             * ) ''
+      WRITE ( stdout,             * ) '    ========================='
+      WRITE ( stdout, '(a,f12.9,a)' ) '     E(+U+V) = ', ehubene, ' Ry'
+      WRITE ( stdout,             * ) '    ========================='
+   ENDIF
+   !
+   RETURN
+ 
+ END SUBROUTINE v_hubbard_v_nc
+ !WIY
diff --git a/PW/src/v_of_rho.f90 b/PW/src/v_of_rho.f90
index 4692027eb..7d57dc83d 100644
--- a/PW/src/v_of_rho.f90
+++ b/PW/src/v_of_rho.f90
@@ -7,7 +7,9 @@
 !
 !----------------------------------------------------------------------------
 SUBROUTINE v_of_rho( rho, rho_core, rhog_core, &
-                     ehart, etxc, vtxc, eth, etotefield, charge, v )
+                     ! by LSH
+                     ehart, etxc, vtxc, eth, ehubene, etotefield, charge, v )
+                     ! by LSH
   !----------------------------------------------------------------------------
   !! This routine computes the Hartree and Exchange and Correlation
   !! potential and energies which corresponds to a given charge density
@@ -20,7 +22,10 @@ SUBROUTINE v_of_rho( rho, rho_core, rhog_core, &
   USE noncollin_module, ONLY : noncolin, nspin_lsda
   USE ions_base,        ONLY : nat, tau
   USE ldaU,             ONLY : lda_plus_u, lda_plus_u_kind, ldmx_b, &
-                               nsg, v_nsg 
+                               nsg, v_nsg
+  ! by LSH
+  USE ldaV,             ONLY : lda_plus_v, lacbn0, acbn0_type
+  ! by LSH 
   USE xc_lib,           ONLY : xclib_dft_is
   USE scf,              ONLY : scf_type
   USE cell_base,        ONLY : alat
@@ -49,7 +54,9 @@ SUBROUTINE v_of_rho( rho, rho_core, rhog_core, &
   !! the E_xc energy
   REAL(DP), INTENT(OUT) :: ehart
   !! the hartree energy
-  REAL(DP), INTENT(OUT) :: eth
+  ! by LSH
+  REAL(DP), INTENT(OUT) :: eth, ehubene
+  ! by LSH
   !! the hubbard energy
   REAL(DP), INTENT(OUT) :: charge
   !! the integral of the charge
@@ -124,6 +131,32 @@ SUBROUTINE v_of_rho( rho, rho_core, rhog_core, &
      ENDIF
      !
   ENDIF
+  ! by LSH WIY
+  IF ( lda_plus_v ) THEN
+     IF ( noncolin ) THEN
+       IF ( lacbn0 ) THEN
+          IF ( acbn0_type == 1 ) THEN
+          CALL errore('v_of_rho', 'noncollinear ACBN0 is not implemented, yet', 2)
+!                CALL v_hubbard_a0_nc(rho%na0_nc,v%na0_nc,ehubene)
+          ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                CALL v_hubbard_v_nc(rho%ne0_nc,v%ne0_nc,ehubene)
+          ENDIF
+       ELSE
+          CALL v_hubbard_v_nc(rho%ne0_nc,v%ne0_nc,ehubene)
+       ENDIF
+     ELSE
+        IF ( lacbn0 ) THEN
+           IF ( acbn0_type == 1 ) THEN
+                 CALL v_hubbard_a0(rho%na0,v%na0,ehubene)
+           ELSEIF ( acbn0_type == 2 .OR. acbn0_type == 3 ) THEN
+                 CALL v_hubbard_v(rho%ne0,v%ne0,ehubene)
+           ENDIF
+        ELSE
+           CALL v_hubbard_v(rho%ne0,v%ne0,ehubene)
+        ENDIF
+     ENDIF
+  ENDIF
+  ! by LSH WIY
   !
   ! ... add an electric field
   ! 
diff --git a/PW/src/vhpsi_v.f90 b/PW/src/vhpsi_v.f90
new file mode 100644
index 000000000..6076006e9
--- /dev/null
+++ b/PW/src/vhpsi_v.f90
@@ -0,0 +1,448 @@
+SUBROUTINE vhpsi_v( ldap, np, mps, psip, hpsi )
+  !! This routine computes the Hubbard potential applied to the electronic 
+  !! structure of the current k-point. The result is added to hpsi.
+  !
+  USE kinds,         ONLY : DP
+  USE becmod,        ONLY : bec_type, calbec,  &
+                            allocate_bec_type, &
+                            deallocate_bec_type
+  USE ldaV,          ONLY : ehub_lm_max, ehub_lm,      &
+                            ehub_nn_vect, ehub_nn_dim, &
+                            ehub_csize, nwfcv, wfcv, ofstv
+  USE constants,     ONLY : tpi
+  USE cell_base,     ONLY : at
+  USE klist,         ONLY : xk
+  USE wvfct,         ONLY : current_k
+  USE lsda_mod,      ONLY : current_spin
+  USE scf,           ONLY : v
+  USE ions_base,     ONLY : nat, ityp
+  USE control_flags, ONLY : gamma_only
+
+  IMPLICIT NONE
+
+  INTEGER,     INTENT(IN)    :: ldap, np, mps
+  COMPLEX(DP), INTENT(IN)    :: psip(ldap,mps)
+  COMPLEX(DP), INTENT(INOUT) :: hpsi(ldap,mps)
+
+  TYPE(bec_type)             :: proj
+
+  INTEGER                    :: na1, na2, nt1, nt2, ldim1, ldim2
+  INTEGER                    :: n1, n2, n3, nnc, ics
+
+  REAL(DP),    ALLOCATABLE   :: rtemp(:,:)
+  REAL(DP)                   :: arg
+
+  COMPLEX(DP), ALLOCATABLE   :: ctemp(:,:), vtemp(:,:)
+  COMPLEX(DP)                :: kphase
+
+  CALL start_clock('vhpsi_v')
+  !
+  CALL allocate_bec_type(nwfcv, mps, proj)
+  !
+  CALL calbec(np, wfcv, psip, proj)
+  !
+  ics = ehub_csize + 1
+  !
+  DO na1 = 1, nat
+     nt1 = ityp(na1)
+     !
+     ldim1 = ehub_lm(nt1)
+     IF ( ldim1 == 0 ) CYCLE
+     !
+     IF ( gamma_only ) THEN
+        ALLOCATE ( rtemp(ldim1,mps) ) ; rtemp = 0.0_DP
+     ELSE
+        ALLOCATE ( ctemp(ldim1,mps) ) ; ctemp = 0.0_DP
+     ENDIF
+     !
+     DO na2 = 1, nat
+        nt2 = ityp(na2)
+        !
+        ldim2 = ehub_lm(nt2)
+        IF ( ldim2 == 0 ) CYCLE
+        !
+        IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+        !
+        IF ( gamma_only ) THEN
+           !
+           CALL DGEMM('n', 'n', ldim1, mps, ldim2,                      &
+                1.0_dp, v%ne0(1,1,current_spin,na1,na2,1), ehub_lm_max, &
+                proj%r(ofstv(na2)+1,1), nwfcv, 0.0_dp, rtemp, ldim1)
+           CALL DGEMM('n','n', 2*np, mps, ldim1,      &
+                1.0_dp, wfcv(1,ofstv(na1)+1), 2*ldap, &
+                rtemp, ldim1, 1.0_dp, hpsi, 2*ldap)
+           !
+        ELSE
+           !
+           ALLOCATE ( vtemp(ldim1,ldim2) ) ; vtemp = 0.0_DP
+           !
+           vtemp(:,:) = v%ne0(1:ldim1,1:ldim2,current_spin,na1,na2,1)
+           !
+           CALL ZGEMM('n', 'n', ldim1, mps, ldim2, &
+                (1.0_dp,0.0_dp), vtemp, ldim1,     &
+                proj%k(ofstv(na2)+1,1), nwfcv,     &
+                (0.0_dp,0.0_dp), ctemp, ldim1)
+           CALL ZGEMM('n', 'n', np, mps, ldim1,              &
+                (1.0_dp,0.0_dp), wfcv(1,ofstv(na1)+1), ldap, &
+                ctemp, ldim1, (1.0_dp,0.0_dp), hpsi, ldap)
+           !
+           DEALLOCATE ( vtemp )
+           !
+        ENDIF
+        !
+     ENDDO
+     !
+     IF ( gamma_only ) THEN
+        DEALLOCATE ( rtemp )
+     ELSE
+        DEALLOCATE ( ctemp )
+     ENDIF
+     !
+  ENDDO
+
+  nnc = 2
+  !
+  DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+  DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+  DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+     !
+     IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE
+     !
+     arg = tpi * (                                                     &
+      xk(1,current_k) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+      xk(2,current_k) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+      xk(3,current_k) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+     !
+     kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+     !
+     DO na1 = 1, nat
+        nt1 = ityp(na1)
+        !
+        ldim1 = ehub_lm(nt1)
+        IF ( ldim1 == 0 ) CYCLE
+        !
+        IF ( gamma_only ) THEN
+           ALLOCATE ( rtemp(ldim1,mps) ) ; rtemp = 0.0_DP
+        ELSE
+           ALLOCATE ( ctemp(ldim1,mps) ) ; ctemp = 0.0_DP
+        ENDIF
+        !
+        DO na2 = 1, nat
+           nt2 = ityp(na2)
+           !
+           ldim2 = ehub_lm(nt2)
+           IF ( ldim2 == 0 ) CYCLE
+           !
+           IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+           !
+           IF ( gamma_only ) THEN
+              !
+              CALL DGEMM('n', 'n', ldim1, mps, ldim2,                        &
+                   1.0_dp, v%ne0(1,1,current_spin,na1,na2,nnc), ehub_lm_max, &
+                   proj%r(ofstv(na2)+1,1), nwfcv, 0.0_dp, rtemp, ldim1)
+              CALL DGEMM('n','n', 2*np, mps, ldim1,      &
+                   1.0_dp, wfcv(1,ofstv(na1)+1), 2*ldap, &
+                   rtemp, ldim1, 1.0_dp, hpsi, 2*ldap)
+              !
+           ELSE
+              !
+              ALLOCATE ( vtemp(ldim1,ldim2) ) ; vtemp = 0.0_DP
+              !
+              vtemp(:,:) = v%ne0(1:ldim1,1:ldim2,current_spin,na1,na2,nnc)
+              !
+              CALL ZGEMM('n', 'n', ldim1, mps, ldim2, &
+                   kphase, vtemp, ldim1,              &
+                   proj%k(ofstv(na2)+1,1), nwfcv,     &
+                   (0.0_dp,0.0_dp), ctemp, ldim1)
+              CALL ZGEMM('n', 'n', np, mps, ldim1,              &
+                   (1.0_dp,0.0_dp), wfcv(1,ofstv(na1)+1), ldap, &
+                   ctemp, ldim1, (1.0_dp,0.0_dp), hpsi, ldap)
+              !
+              DEALLOCATE ( vtemp )
+              !
+           ENDIF
+           !
+        ENDDO ! na2
+        !
+        IF ( gamma_only ) THEN
+           DEALLOCATE ( rtemp )
+        ELSE
+           DEALLOCATE ( ctemp )
+        ENDIF
+        !
+     ENDDO ! na1
+     !
+     IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+     !
+  ENDDO ! n3
+  ENDDO ! n2
+  ENDDO ! n1
+  !
+  CALL deallocate_bec_type(proj)
+  !
+  CALL stop_clock('vhpsi_v')
+  !
+  RETURN
+
+END SUBROUTINE vhpsi_v
+!
+SUBROUTINE vhpsi_a0( ldap, np, mps, psip, hpsi )
+
+  USE kinds,         ONLY : DP
+  USE becmod,        ONLY : bec_type, calbec,  &
+                            allocate_bec_type, &
+                            deallocate_bec_type
+  USE ldaV,          ONLY : ehub_lm_max, ehub_lm, &
+                            nwfcv, wfcv, ofstv
+  USE lsda_mod,      ONLY : current_spin
+  USE scf,           ONLY : v
+  USE ions_base,     ONLY : nat, ityp
+  USE control_flags, ONLY : gamma_only
+
+  IMPLICIT NONE
+
+  INTEGER,     INTENT(IN)    :: ldap, np, mps
+  COMPLEX(DP), INTENT(IN)    :: psip(ldap,mps)
+  COMPLEX(DP), INTENT(INOUT) :: hpsi(ldap,mps)
+
+  TYPE(bec_type)             :: proj
+
+  INTEGER                    :: na, nt, ldim
+
+  REAL(DP),    ALLOCATABLE   :: rtemp(:,:)
+
+  COMPLEX(DP), ALLOCATABLE   :: ctemp(:,:), vtemp(:,:)
+
+  CALL start_clock('vhpsi_a0')
+  !
+  CALL allocate_bec_type(nwfcv, mps, proj)
+  !
+  CALL calbec(np, wfcv, psip, proj)
+  !
+  DO na = 1, nat
+     nt = ityp(na)
+     !
+     ldim = ehub_lm(nt)
+     IF ( ldim == 0 ) CYCLE
+     !
+     IF ( gamma_only ) THEN
+        ALLOCATE ( rtemp(ldim,mps) ) ; rtemp = 0.0_DP
+     ELSE
+        ALLOCATE ( ctemp(ldim,mps) ) ; ctemp = 0.0_DP
+        ALLOCATE ( vtemp(ldim,ldim) ) ; vtemp = 0.0_DP
+     ENDIF
+     !
+     IF ( gamma_only ) THEN
+        !
+        CALL DGEMM('n', 'n', ldim, mps, ldim,                 &
+             1.0_dp, v%na0(1,1,current_spin,na), ehub_lm_max, &
+             proj%r(ofstv(na)+1,1), nwfcv, 0.0_dp, rtemp, ldim)
+        CALL DGEMM('n','n', 2*np, mps, ldim,      &
+             1.0_dp, wfcv(1,ofstv(na)+1), 2*ldap, &
+             rtemp, ldim, 1.0_dp, hpsi, 2*ldap)
+        !
+     ELSE
+        !
+        vtemp(:,:) =  v%na0(1:ldim,1:ldim,current_spin,na)
+        !
+        CALL ZGEMM('n', 'n', ldim, mps, ldim, &
+             (1.0_dp,0.0_dp), vtemp, ldim,    &
+             proj%k(ofstv(na)+1,1), nwfcv,    &
+             (0.0_dp,0.0_dp), ctemp, ldim)
+        CALL ZGEMM('n', 'n', np, mps, ldim,              &
+             (1.0_dp,0.0_dp), wfcv(1,ofstv(na)+1), ldap, &
+             ctemp, ldim, (1.0_dp,0.0_dp), hpsi, ldap)
+        !
+     ENDIF
+     !
+     IF (gamma_only) THEN
+        DEALLOCATE (rtemp)
+     ELSE
+        DEALLOCATE (ctemp, vtemp)
+     ENDIF
+     !
+  ENDDO
+  !
+  CALL deallocate_bec_type(proj)
+  !
+  CALL stop_clock('vhpsi_a0')
+  !
+  RETURN
+
+END SUBROUTINE vhpsi_a0
+!
+! by WIY
+SUBROUTINE vhpsi_v_nc( ldap, np, mps, psip, hpsi )
+   !! Noncollinear version of vhpsi_v routine following vhpsi_nc routine.
+   !
+   USE kinds,              ONLY : DP
+   USE becmod,             ONLY : bec_type, calbec,  &
+                                  allocate_bec_type, &
+                                  deallocate_bec_type
+   USE ldaV,               ONLY : ehub_lm_max, ehub_lm, ehub_l, &
+                                  ehub_nn_vect, ehub_nn_dim,    &
+                                  ehub_csize, nwfcv, wfcv,      &
+                                  ofstv, counter_lm
+   USE constants,          ONLY : tpi
+   USE cell_base,          ONLY : at
+   USE klist,              ONLY : xk
+   USE wvfct,              ONLY : current_k
+   USE lsda_mod,           ONLY : current_spin
+   USE scf,                ONLY : v
+   USE ions_base,          ONLY : nat, ityp
+   USE noncollin_module,   ONLY : npol, noncolin
+   USE mp_pools,           ONLY : inter_pool_comm
+   USE mp_bands,           ONLY : intra_bgrp_comm
+   USE mp,                 ONLY : mp_sum
+   USE io_global,          ONLY : stdout
+   !
+   IMPLICIT NONE
+   !
+   INTEGER,     INTENT(IN)    :: ldap
+   !! leading dimension of arrays psip, hpsi
+   INTEGER,     INTENT(IN)    :: np
+   !! true dimension of psip, hpsi
+   INTEGER,     INTENT(IN)    :: mps
+   !! number of states psip
+   COMPLEX(DP), INTENT(IN)    :: psip(ldap*npol,mps)
+   !! the wavefunction
+   COMPLEX(DP), INTENT(INOUT) :: hpsi(ldap*npol,mps)
+   !! Hamiltonian dot psi
+   !
+   COMPLEX(DP), ALLOCATABLE   :: proj(:,:)
+   !
+   INTEGER                    :: na, na1, na2, nt1, nt2, ldim1, ldim2
+   INTEGER                    :: n1, n2, n3, nnc, ics
+   INTEGER                    :: is1, is2
+   INTEGER                    :: ibnd, m1, m2
+   !
+   REAL(DP)                   :: arg
+   !
+   COMPLEX(DP)                :: temp
+   COMPLEX(DP)                :: kphase
+   !
+   CALL start_clock('vhpsi_v_nc')
+   !
+   ALLOCATE( proj(nwfcv, mps))
+   !
+   !! proj = <wfcU|psip>
+   !
+   Do ibnd = 1, mps
+      Do na = 1, nwfcv
+         proj(na, ibnd) = DOT_PRODUCT( wfcv(1:ldap*npol, na), psip(1:ldap*npol, ibnd))
+      ENDDO
+   ENDDO
+   !
+   CALL mp_sum( proj, intra_bgrp_comm)
+   !
+   ics = ehub_csize + 1
+   !
+   ! Compute teh action of the Hubbard potential on the KS wave functons:
+   ! V_Hub |psip > = \sum v%ne0 |wfcv><wfcv|psip>
+   ! where v%ne0 is computed in v_hubbard_v.f90
+   !
+   DO ibnd = 1, mps
+      DO na1 = 1, nat
+         nt1 = ityp(na1)
+         !
+         ldim1 = ehub_lm(nt1)
+         IF ( ldim1 == 0 ) CYCLE
+      !
+      DO na2 = 1, nat
+         nt2 = ityp(na2)
+         !
+         ldim2 = ehub_lm(nt2)
+         IF ( ldim2 == 0 ) CYCLE
+         !
+         IF ( na1 /= na2 .AND. ehub_nn_vect(ics,ics,ics,na1,na2) == 0 ) CYCLE
+         !
+         !! Since the order of proj is interwined with quantum lm number and spin index,
+         !! ZGEMM is hard to be used.
+         !
+         DO m1 = 1, ldim1
+         DO is1 = 1, npol
+            !
+            temp = 0.0_DP
+            !
+            DO m2 = 1, ldim2
+            DO is2 = 1, npol
+               temp = temp + v%ne0_nc(m1, m2, npol*(is1-1)+is2, na1, na2, 1) * &
+                              proj(ofstv(na2)+m2+counter_lm(m2,nt2) +          &
+                                  (2*(ehub_l(m2,nt2)-1)+1)*(is2-1), ibnd)
+            ENDDO ! is2
+            ENDDO ! m2
+               CALL ZAXPY(ldap*npol, temp, wfcv(1, ofstv(na1)+m1+counter_lm(m1,nt1) + &
+                                               (2*(ehub_l(m1,nt1)-1)+1)*(is1-1)),     &
+                                               1, hpsi(1, ibnd), 1)
+         !
+         ENDDO ! is1
+         ENDDO ! m1
+         !
+      ENDDO ! na2
+      ENDDO ! na1
+      !
+      nnc = 2
+      !
+      DO n1 = -1*ehub_nn_dim(1), ehub_nn_dim(1)
+      DO n2 = -1*ehub_nn_dim(2), ehub_nn_dim(2)
+      DO n3 = -1*ehub_nn_dim(3), ehub_nn_dim(3)
+         !
+         IF ( n1 == 0 .AND. n2 == 0 .AND. n3 == 0 ) CYCLE 
+         !
+         arg = tpi * (                                                       &
+            xk(1,current_k) * (n1 * at(1,1) + n2 * at(1,2) + n3 * at(1,3)) + &
+            xk(2,current_k) * (n1 * at(2,1) + n2 * at(2,2) + n3 * at(2,3)) + &
+            xk(3,current_k) * (n1 * at(3,1) + n2 * at(3,2) + n3 * at(3,3)))
+         !
+         kphase = CMPLX(COS(arg), SIN(arg), KIND=DP)
+         !
+         DO na1 = 1, nat
+            nt1 = ityp(na1)
+            !
+            ldim1 = ehub_lm(nt1)
+            IF( ldim1 == 0 ) CYCLE 
+            !
+            DO na2 = 1, nat
+               nt2 = ityp(na2)
+               !
+               ldim2 = ehub_lm(nt2)
+               IF( ldim2 == 0 ) CYCLE
+               !
+               IF ( ehub_nn_vect(n1+ics,n2+ics,n3+ics,na1,na2) == 0 ) CYCLE
+               !
+               DO m1 = 1, ldim1
+               DO is1 = 1, npol
+                  !
+                  temp = 0.0_DP
+                  !
+                  DO m2 = 1, ldim2
+                  DO is2 = 1, npol
+                     temp = temp + kphase * v%ne0_nc(m1, m2, npol*(is1-1)+is2, na1, na2, nnc) * &
+                                             proj(ofstv(na2)+m2+counter_lm(m2,nt2) +            &
+                                                 (2*(ehub_l(m2,nt2)-1)+1)*(is2-1), ibnd)
+                  ENDDO ! is2
+                  ENDDO ! m2
+                     CALL ZAXPY(ldap*npol, temp, wfcv(1, ofstv(na1)+m1+counter_lm(m1,nt1) + &
+                                                     (2*(ehub_l(m1,nt1)-1)+1)*(is1-1)),     &
+                                                     1, hpsi(1, ibnd), 1)
+               !
+               ENDDO ! is1
+               ENDDO ! m1
+               !               
+            ENDDO ! na2
+         ENDDO ! na1
+         !
+         IF ( MAXVAL(ehub_nn_vect(n1+ics,n2+ics,n3+ics,:,:)) == 1 ) nnc = nnc + 1
+         !
+      ENDDO ! n3
+      ENDDO ! n2
+      ENDDO ! n1
+   ENDDO ! mps
+   !
+   DEALLOCATE(proj)
+   CALL stop_clock('vhpsi_v_nc')
+   !
+   RETURN
+ 
+ END SUBROUTINE vhpsi_v_nc
+ ! by WIY
diff --git a/PW/src/wfcinit.f90 b/PW/src/wfcinit.f90
index 7f2e602b7..a710f46f9 100644
--- a/PW/src/wfcinit.f90
+++ b/PW/src/wfcinit.f90
@@ -20,9 +20,15 @@ SUBROUTINE wfcinit()
   USE control_flags,        ONLY : io_level, lscf
   USE fixed_occ,            ONLY : one_atom_occupations
   USE ldaU,                 ONLY : lda_plus_u, Hubbard_projectors, wfcU, lda_plus_u_kind
+  ! by LSH
+  USE ldaV,                 ONLY : lda_plus_v, wfcv
+  ! by LSH
   USE lsda_mod,             ONLY : lsda, current_spin, isk
   USE io_files,             ONLY : nwordwfc, nwordwfcU, iunhub, iunwfc,&
-                                   diropn, xmlfile, restart_dir
+                                   ! by LSH
+                                   diropn, xmlfile, restart_dir,&
+                                   nwordwfcv, iunhubv
+                                   ! by LSH
   USE buffers,              ONLY : open_buffer, close_buffer, get_buffer, save_buffer
   USE uspp,                 ONLY : nkb, vkb
   USE wavefunctions,        ONLY : evc
@@ -54,6 +60,9 @@ SUBROUTINE wfcinit()
        CALL errore ( 'wfcinit', 'currently incompatible options', 1 )
   IF ( use_wannier .OR. one_atom_occupations ) CALL orthoatwfc ( use_wannier )
   IF ( lda_plus_u ) CALL orthoUwfc(.FALSE.)
+  ! by LSH
+  IF ( lda_plus_v ) CALL orthowfcv()
+  ! by LSH
   !
   ! ... open files/buffer for wavefunctions (nwordwfc set in openfil)
   ! ... io_level > 1 : open file, otherwise: open buffer
@@ -185,6 +194,13 @@ SUBROUTINE wfcinit()
      !
      IF ( nks > 1 .AND. lda_plus_u .AND. (Hubbard_projectors .NE. 'pseudo') ) &
         CALL get_buffer( wfcU, nwordwfcU, iunhub, ik )
+     ! by LSH
+     !
+     ! ... Needed for DFT+U+V
+     !
+     IF ( nks > 1 .AND. lda_plus_v .AND. (Hubbard_projectors .NE. 'pseudo') ) &
+        CALL get_buffer( wfcv, nwordwfcv, iunhubv, ik )
+     ! by LSH
      !
      ! DFT+U+V: calculate the phase factor at a given k point
      !
diff --git a/UtilXlib/mp.f90 b/UtilXlib/mp.f90
index db5e145dd..024dcddb6 100644
--- a/UtilXlib/mp.f90
+++ b/UtilXlib/mp.f90
@@ -39,14 +39,18 @@ MODULE mp
       mp_bcast_iv, mp_bcast_i8v, mp_bcast_rv, mp_bcast_cv, mp_bcast_l, mp_bcast_rm, &
       mp_bcast_cm, mp_bcast_im, mp_bcast_it, mp_bcast_i4d, mp_bcast_rt, mp_bcast_lv, &
       mp_bcast_lm, mp_bcast_r4d, mp_bcast_r5d, mp_bcast_ct,  mp_bcast_c4d,&
-      mp_bcast_c5d, mp_bcast_c6d
+      ! by LSH
+      mp_bcast_c5d, mp_bcast_c6d, mp_bcast_r6d
+      ! by LSH
 #if defined(__CUDA)
     MODULE PROCEDURE mp_bcast_i1_gpu, mp_bcast_r1_gpu, mp_bcast_c1_gpu, &
       !mp_bcast_z_gpu, mp_bcast_zv_gpu, &
       mp_bcast_iv_gpu, mp_bcast_rv_gpu, mp_bcast_cv_gpu, mp_bcast_l_gpu, mp_bcast_rm_gpu, &
       mp_bcast_cm_gpu, mp_bcast_im_gpu, mp_bcast_it_gpu, mp_bcast_i4d_gpu, mp_bcast_rt_gpu, mp_bcast_lv_gpu, &
       mp_bcast_lm_gpu, mp_bcast_r4d_gpu, mp_bcast_r5d_gpu, mp_bcast_ct_gpu,  mp_bcast_c4d_gpu,&
-      mp_bcast_c5d_gpu, mp_bcast_c6d_gpu
+      ! by LSH
+      mp_bcast_c5d_gpu, mp_bcast_c6d_gpu, mp_bcast_r6d_gpu
+      ! by LSH
 #endif
   END INTERFACE
   ! 
@@ -621,6 +625,25 @@ MODULE mp
 #endif
       END SUBROUTINE mp_bcast_r5d
 
+!
+!------------------------------------------------------------------------------!
+!
+! by LSH
+!
+      SUBROUTINE mp_bcast_r6d(msg, source, gid)
+        IMPLICIT NONE
+        REAL (DP) :: msg(:,:,:,:,:,:)
+        INTEGER, INTENT(IN) :: source
+        INTEGER, INTENT(IN) :: gid
+#if defined(__MPI)
+        INTEGER :: msglen
+        msglen = size(msg)
+        CALL bcast_real( msg, msglen, source, gid )
+#endif
+      END SUBROUTINE mp_bcast_r6d
+
+! by LSH
+
 !------------------------------------------------------------------------------!
 !
       SUBROUTINE mp_bcast_c1(msg,source,gid)
@@ -3387,6 +3410,33 @@ END SUBROUTINE mp_type_free
 #endif
         ierr = cudaDeviceSynchronize()  ! This syncs SERIAL, __MPI
       END SUBROUTINE mp_bcast_r5d_gpu
+! by LSH
+!
+!------------------------------------------------------------------------------!
+!
+      SUBROUTINE mp_bcast_r6d_gpu(msg_d, source, gid)
+        IMPLICIT NONE
+        REAL (DP), DEVICE :: msg_d(:,:,:,:,:,:)
+        REAL (DP), ALLOCATABLE :: msg_h(:,:,:,:,:,:)
+        INTEGER, INTENT(IN) :: source
+        INTEGER, INTENT(IN) :: gid
+        INTEGER :: msglen, ierr
+#if defined(__MPI)
+#if defined(__GPU_MPI)
+        msglen = size(msg_d)
+        ierr = cudaDeviceSynchronize()      ! This syncs __GPU_MPI case
+        CALL bcast_real_gpu( msg_d, msglen, source, gid )
+        RETURN ! Sync done by MPI call (or inside bcast_xxx_gpu)
+#else
+        ALLOCATE( msg_h, source=msg_d )     ! This syncs __MPI case
+        msglen = size(msg_h)
+        CALL bcast_real( msg_h, msglen, source, gid )
+        msg_d = msg_h ; DEALLOCATE(msg_h)
+#endif
+#endif
+        ierr = cudaDeviceSynchronize()  ! This syncs SERIAL, __MPI
+      END SUBROUTINE mp_bcast_r6d_gpu
+! by LSH
 !
 !------------------------------------------------------------------------------!
 !
diff --git a/external/.gitignore b/external/.gitignore
deleted file mode 100644
index cf5afcb20..000000000
--- a/external/.gitignore
+++ /dev/null
@@ -1,45 +0,0 @@
-
-#
-# home files
-#
-config.log
-make.inc
-
-#
-# configuration
-#
-myconfig*
-config/configure.msg
-config/config.status
-include/c_defs.h
-include/configure.h
-include/f_defs.h
-install/make_blas.inc
-install/make_lapack.inc
-
-#
-# compilation
-#
-bin/*.x
-src/*.x
-src/*.o
-src/*.a
-src/*.mod
-src/*.MOD
-src/FortCuda/*.x
-src/FortCuda/*.o
-src/FortCuda/*.a
-src/FortCuda/*.mod
-src/FortCuda/*.MOD
-
-#
-# ext libs
-#
-extlibs/*/*stamp
-extlibs/*/bin/
-extlibs/*/include/
-extlibs/*/lib/
-#
-extlibs/blas/BLAS/
-extlibs/lapack/lapack*/
-
